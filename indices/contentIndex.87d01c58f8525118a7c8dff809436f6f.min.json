{"/":{"title":"🪴 Main Page","content":"\n我會將我所讀所學的一點點摘要進來，希望有一天他們可以建構起強大的知識網路。\n\n\n\n## 近期閱讀\n\n- [[notes/Resource/Books/The Second Brain]]\n\n\n## 文章引導\n\n- [[notes]]\n- [[tags]]\n- [[notes/Project/Effective C++ Series/Effective C++ Outline]]\n\n\n","lastmodified":"2023-09-05T15:34:45.914894221Z","tags":[]},"/notes/Archive/Special-Syntax-in-Theme-Things-2":{"title":"Special Syntax in Theme Things 2","content":"\n## Basic\n- [ ] to-do\n- [/] incomplete\n- [x] done\n- [-] canceled\n- [\u003e] forwarded\n- [\u003c] scheduling\n\n## Extras\n- [?] question\n- [!] important\n- [*] star\n- [\"] quote\n- [l] location\n- [b] bookmark\n- [i] information\n- [S] savings\n- [I] idea\n- [p] pros\n- [c] cons\n- [f] fire\n- [k] key\n- [w] win\n- [u] up\n- [d] down\n\n\nhttps://github.com/colineckert/obsidian-things\n","lastmodified":"2023-09-05T15:34:45.914894221Z","tags":[]},"/notes/Area/Arom/%E7%B2%BE%E6%B2%B9%E6%93%B4%E9%A6%99":{"title":"精油擴香","content":"# 精油擴香配方\n\n\n\n## 驅蚊\n\n沉香籽＋檸檬香茅 or 香茅 or 山雞椒＋甜橙（其他柑橘類也適）比例很隨心所欲，可能的比例 沉香籽 1：柑橘 2：檸檬香茅 0.5。另外再加青檸葉。\n\n","lastmodified":"2023-09-05T15:34:45.914894221Z","tags":[]},"/notes/Area/Arom/DIY":{"title":"DIY","content":"# DIY \n\n## 護唇膏\n\n- 油、脂、蜂蠟，3:1:2。\n- 油、蜂蠟，3:1。\n\n- 實驗: 液體量 40g，油 32 g、蜂蠟 8 g。\n\n","lastmodified":"2023-09-05T15:34:45.914894221Z","tags":[]},"/notes/Area/Hugo/Hugo-Publish-Simple-Page":{"title":"以 Hugo 發佈簡單的頁面","content":"## Hugo 建立部落格的範例\n\n直接用 Hugo 建立部落格，不使用 Quartz 的範例:\n\n### Start\n\nhugo new site quickstart  \ncd quickstart  \ngit init  \ngit submodule add https://github.com/theNewDynamic/gohugo-theme-ananke themes/ananke  \necho \"theme = 'ananke'\" \u003e\u003e config.toml  \nhugo server\n\n[https://gohugo.io/getting-started/quick-start/](https://gohugo.io/getting-started/quick-start/)\n\n### 將 Markdown 檔案轉換成 Web Page\n\nhugo server --buildDrafts  \nhugo server -D\n","lastmodified":"2023-09-05T15:34:45.914894221Z","tags":[]},"/notes/Area/Hugo/Hugo-front-matter":{"title":"Hugo 可使用的metadata","content":"\nSource: https://gohugo.io/content-management/front-matter/\n\n舉例:\n\n```yaml\ncategories:\n- Development\n- VIM\ndate: \"2012-04-06\"\ndescription: spf13-vim is a cross platform distribution of vim plugins and resources\n  for Vim.\nslug: spf13-vim-3-0-release-and-new-website\ntags:\n- .vimrc\n- plugins\n- spf13-vim\n- vim\ntitle: spf13-vim 3.0 release and new website\n```\n\n可建立 Obsidian 模板:\n\n```yaml\ntitle: \ndate: {{date}}\ndescription: \n\nslug: alias-name\ntags:\n- default\ncategories:\n- default\n\n```\n\n本頁所使用的 metadata: \n```yaml\ntitle: \"可使用的metadata\"\ndate: 2023-04-09\nslug: usable meta data # 網址變成此名稱\ncategories:\n- blog\n```\n\n這裡，我讓檔案名稱變成\n- filename: `Hugo front matter.md` \n- title: `可使用的metadata` \u003e 頁面標題\n- slug: `usable meta data` \u003e 連結名稱\n\n\n## Category vs. Tag\n\n在打造第二大腦中，作者提出 Tag 是一種打破資料夾邊界的連結方式。我希望，在我的部落格中，我希望讓網頁會 Category 做資料夾壁壘的分類，有必要時再以 tag 打破邊界。\n\n但似乎 quartz 支援的只有 tags 而沒有 categories。我想參考這篇文章試試看能不能打開該功能: \nhttps://ithelp.ithome.com.tw/articles/10244921\n\n## Description\n沒有用，不會改變預覽頁面的內容。\n","lastmodified":"2023-09-05T15:34:45.914894221Z","tags":[]},"/notes/Area/Obsidian/Obsidian-Map-View":{"title":"Obsidian Map View","content":"[Github: Obsidian Map View](https://github.com/esm7/obsidian-map-view)\n\n## 紀錄\n\n### 導入已記錄在 Map 的地點\n1. 開啟命令面板 -\u003e  \"Map View: add inline geolocation link\"，文字 `[](geo:)` 會被插入。\n2. 在中括號中輸入地點，像是: `[台北101]`，會跳出下拉選單，點選之後經緯度位置會自動填在 `(geo:)` 當中。\n\n### 從 Command 上新增地點\n\n1. 開啟命令面板 -\u003e\"Map View: New geolocation note\"。\n2. 跳出一個 Dialog，貼上連結、或是 Search 地點都可以。\n\t- 網址連結分析的規則: [URL parsing rules](https://github.com/esm7/obsidian-map-view#url-parsing-rules)\n\t- Search 地點會受到選擇哪一個地點資訊提供者所影響: [configured geocoding provider](https://github.com/esm7/obsidian-map-view#changing-a-geocoding-provider) \n\n### 從既有的筆記新增地點\n### Inline geolocation link\n如前面「從 Command 新增地點」，在文章中以 `[](geo:)` 標示地點。\n\n### 以 Metadata 標註本文是一個地點\n\n1. 開啟命令面板 -\u003e\"Add geolocation (front matter) to current note\"。\n\n\n## Changing a Geocoding Provider\n1. 去 Google 申請 Googla Map API\n2. 在 Obsidian Map View 的設定當中把 Provider 改成 Google，貼上 API Key.\nhttps://github.com/esm7/obsidian-map-view#changing-a-geocoding-provider\n\n\nGoogle API 可以設權限 Query 哪些內容，其中 [Places API](https://developers.google.com/maps/documentation/places/web-service/cloud-setup) 可以讓我們在 Command Line 直接搜尋 Google 地點。花費會比較高，但如果是作為筆記軟體，應該會是在 Google 的免費額度 200美金之內。\n\n## 把 Map Source 切換成 Google \n參考 : https://github.com/esm7/obsidian-map-view/issues/51\n在 Map source 中新增一個 Google Map 選項，Url: `https://mts1.google.com/vt/lyrs=m@186112443\u0026hl=x-local\u0026src=app\u0026x={x}\u0026y={y}\u0026z={z}\u0026s=Galile`\n","lastmodified":"2023-09-05T15:34:45.914894221Z","tags":["obsidian"]},"/notes/Area/Obsidian/Obsidian-Plugins":{"title":"Obsidian Plugins","content":"## Theme\n- 當前用的是 Thing2\n- [minimal](https://minimal.guide/Home) 也是熱門的主題，且與許多 plugin 相容\n\t- 但是 header 之間不同階級沒有大小之分，我不喜歡，要用需要改 CSS。\n\n\n\n## Plugin\n- Obsidian Dataview mode: like notion https://ithelp.ithome.com.tw/articles/10279262\n- [[Obsidian Map View]]: [source](https://github.com/esm7/obsidian-map-view#intro)\n- \n","lastmodified":"2023-09-05T15:34:45.914894221Z","tags":[]},"/notes/Area/Obsidian/Sync-Obsidian":{"title":"Obsidian Publish 的替代選擇","content":"想在 IOS 上面也有 Sync 的 Obsidian 可以用!\n\n社群的作法是裝 ISH 以 Git 同步，我想實驗用 Terminus (比起 ISH 有在維護)\n\n- [Sync with git on iOS for free using iSH](https://forum.obsidian.md/t/mobile-sync-with-git-on-ios-for-free-using-ish/20861)\n- [Setting up iOS git-based syncing with mobile app (using Working Copy)](https://forum.obsidian.md/t/mobile-setting-up-ios-git-based-syncing-with-mobile-app-using-working-copy/16499)\n","lastmodified":"2023-09-05T15:34:45.914894221Z","tags":[]},"/notes/Area/Python/Asyncio":{"title":"Asyncio","content":"# Asyncio \n\n在 [Asyncio](https://brainynight.github.io/posts/2022-10-23-python-asyncio) 這篇簡介的文章中，有一個簡單的例子如下。本文將針對此例仔細探討。\n\n```python\nimport asyncio\n\nasync def single_process(cmd):\n    proc = await asyncio.create_subprocess_shell(\n        cmd,\n        stdout=asyncio.subprocess.PIPE,\n        stderr=asyncio.subprocess.PIPE)\n    try:\n        await asyncio.wait_for(proc.communicate(), timeout=2)\n        print(cmd, \"complete\")\n    except asyncio.TimeoutError:\n        print(cmd, \"timeout\")\n        \nasync def run_all(cmds):\n    lt = []\n    for cmd in cmds:\n        lt.append(single_process(cmd))\n    await asyncio.gather(*lt)\n\nif __name__ == \"__main__\":\n    cmds = [\n        \"sleep 1 \u0026\u0026 echo hello\",\n        \"sleep 1.5\",\n        \"echo world\",\n        \"sleep 500\",        \n    ]\n    asyncio.run(run_all(cmds))\n```\n\n## Asyncio \n\nmain page: https://docs.python.org/zh-tw/3/library/asyncio.html\n\n接下來只會介紹 main page 當中高階 API 的部分內容。\n\n- [`asyncio.Runner`](https://docs.python.org/zh-tw/3/library/asyncio-runner.html): 是一個 context manager (使用 `with` 語句)，使我們不用管資源關閉或釋放的問題。\n- [協程與任務 (coroutines and tasks)](https://docs.python.org/zh-tw/3/library/asyncio-task.html): 這兩者是 high level API 使用者主要會使用到的類別，建議可詳讀。\n- [Debug mode](https://docs.python.org/zh-tw/3/library/asyncio-dev.html)\n- [Synchronization Primitives](https://docs.python.org/zh-tw/3/library/asyncio-sync.html): asyncio 提供了一些和 threading 模組相似的物件，像是 Lock, Semaphore。不過要注意，asyncio 模組的內容大多都是 non-thread-safe 的。\n- [High Level API Index](https://docs.python.org/zh-tw/3/library/asyncio-api-index.html)\n\n\n\n\n## Coroutine\n\n官對\"Coroutine\" 這個詞彙的說明，我不打算仔細解釋。\n\n在官方文件中，coroutine 很反覆的被提及，有時指的是 coroutine object ，有時是 coroutine function。\n\n- coroutine function: 被以 `async def` 宣告的 function\n- coroutine object: 呼叫 coroutine function 時所回傳的物件。\n\n詳見 [PEP 492](https://peps.python.org/pep-0492/)。\n\n\u003e 協程 coroutine[¶](https://docs.python.org/3/glossary.html#term-coroutine)\n\u003e\n\u003e Coroutines are a more generalized form of subroutines. Subroutines are entered at one point and exited at another point. Coroutines can be entered, exited, and resumed at many different points. They can be implemented with the [`async def`](https://docs.python.org/3/reference/compound_stmts.html#async-def) statement. See also [**PEP 492**](https://peps.python.org/pep-0492/).\n\u003e\n\u003e 協程函數 coroutine function\n\u003e\n\u003e A function which returns a [coroutine](https://docs.python.org/3/glossary.html#term-coroutine) object. A coroutine function may be defined with the [`async def`](https://docs.python.org/3/reference/compound_stmts.html#async-def) statement, and may contain [`await`](https://docs.python.org/3/reference/expressions.html#await), [`async for`](https://docs.python.org/3/reference/compound_stmts.html#async-for), and [`async with`](https://docs.python.org/3/reference/compound_stmts.html#async-with) keywords. These were introduced by [**PEP 492**](https://peps.python.org/pep-0492/).\n\n\n\n一個協程通常透過協程函數取得，如下例 `cfunc` function ，會回傳一個 coroutine object。\n\n```python\nimport asyncio\n\nasync def cfunc():\n    print('hello')\n    await asyncio.sleep(1)\n    print('world')\n```\n\n何以得知? 如果使用 ipython 這類的互動 console，直接看 `cfunc()` 物件是什麼東西，會看到這樣的內容:\n\n```python\n\u003e\u003e\u003e cfunc()\n\u003ccoroutine object cfunc at 0x7fe9094b2650\u003e\n\u003e\u003e\u003e type(cfunc())\n\u003cclass 'coroutine'\u003e\n```\n\n這表示，此 function 回傳的內容會是一個 coroutine object! 要注意，coroutine object 必須使用一些支援異步執行的函式/語法來正確的運行，例如 `asyncio.run`， `cfunc()` 實質上的功能，就只是回傳一個 coroutine object 而已。\n\n## Awaitable object \n\n指的是可以用在 `await` expression 的物件，主要的三種 awaitable object 是 coroutines, Tasks, 和 Futures，另外就是擁有 `__await__()` 方法的物件。`await` 只能被使用在 coroutine function 內。三種 type 當中，Future 屬於比較底層的 API，將不說明。\n\n### coroutine object\n\n前例的 `asyncio.sleep(1)` ，本質上也是透過一個 coroutine function 取得 coroutine object，因此必須以關鍵字  `await` 接住這個 coroutine object。\n\n若 coroutine function 內還會呼叫另一個 coroutine function，被呼叫的 coroutine function 前必須加 `await`，因為它回傳的是個 coroutine object。\n\n```python\nimport asyncio\nimport time\n\nasync def say_after(delay, what):\n    await asyncio.sleep(delay)\n    print(what)\n\nasync def main():\n    print(f\"started at {time.strftime('%X')}\")\n    # needs to add `await` when call a coroutine function, but not directly execute.\n    await say_after(1, 'hello') \n    await say_after(2, 'world')\n    print(f\"finished at {time.strftime('%X')}\")\n\n# The method for directly execute is asyncio.run\nasyncio.run(main())\n```\n\n-  `asyncio.run` 才會真正執行被給予的 coroutine object\n\n### asyncio.Task\n\n`create_task` 回傳一個 `asyncio.Task` 物件，我們得以提前創造 task，等到需要想要執行這個 task 的地方，再以 `await` 呼叫。\n\n同樣的，這裡的「執行」並不是真的「跑」下去，比較像是標示「我想再這裡執行這個 function」。真正的執行依然是交給 `run`。\n\n\n```python\nasync def main():\n    task1 = asyncio.create_task(say_after(1, 'hello'))\n    task2 = asyncio.create_task(say_after(2, 'world'))\n    \n    print(f\"started at {time.strftime('%X')}\")\n    # Wait until both tasks are completed (should take around 2 seconds.)\n    await task1\n    await task2\n    print(f\"finished at {time.strftime('%X')}\")\nasyncio.run(main())\n```\n\n[`TaskGroup`](https://docs.python.org/3/library/asyncio-task.html#asyncio.TaskGroup) 是另外一種創建 task 並執行的方法，可以不用寫 `await` (隱性的在 `with` 結束時呼叫 await 把 tasks call 一遍)，不過這個 API 只在 Python3.11 起提供，就不多提。\n\n\n\n## asyncio.gather\n\n```python\nasyncio.gather(*aws, return_exceptions=False)\n```\n\n- 接收多個 awaitable 物件，如果 awaitable 物件當中有 coroutine，gather 會把它當作 Task 調度 (scheduled as a `Task`)。\n- 回傳值: 當所有的 awaitable object 都完成任務後，`asyncio.gather` 會把這些任務的回傳值放在一個 list 裡面回傳結果。結果的順序與放進 `gather` 的順序相同。\n- `return_exception` \n    - 預設是 false，當任務執行中發生 exception，會及時 raise exception，並取消 gather (剩下的任務將不會跑到)\n    - 若為 true，則不會 raise exception，而是將 exception 的內容 (?) 當作執行成功的結果，一起在 `gather` 的回傳清單中。\n\n## asyncio.wait\n\n```python\nasyncio.wait(aws, *, timeout=None, return_when=ALL_COMPLETED)\n```\n\n- 接收一個 list，內含多個 awaitable 物件。\n- 程式會停在這裡執行同時所有的任務\n\n\n\n## Subproccess\n\nhttps://docs.python.org/zh-tw/3/library/asyncio-subprocess.html\n\n\n\n\n\n\n\n## A\n\n`asyncio.create_subprocess_shell` 是一個 coroutine function，回傳的是 `asyncio.subprocess.Process` 物件。[doc](https://docs.python.org/zh-tw/3/library/asyncio-subprocess.html#asyncio.create_subprocess_shell) \n\n\n\n\n\n\n\n","lastmodified":"2023-09-05T15:34:45.914894221Z","tags":[]},"/notes/Area/Quartz/%E4%BD%BF%E7%94%A8-Quartz-%E5%BB%BA%E7%AB%8B%E9%83%A8%E8%90%BD%E6%A0%BC":{"title":"使用 Quartz 建立部落格","content":"\n\n## Install\n\n1. Git\n2. Go lang\n3. Hugo: 需要手動加環境變數\n4.  `go-obsidian`\n    ```go\n    go install github.com/jackyzha0/hugo-obsidian@latest\n    ```\n5. **Optional**  `make` `: Windows 下須使用 MinGW 安裝，參考: [C++ 開發環境 在 Windows 11 中安裝 mingw-w64 及設定環境變數](http://kaiching.org/pydoing/cpp-guide4/how-to-install-mingw-w64-and-set-environment-variable.html)\n\nHugo 需要以 [PowerShell](https://learn.microsoft.com/en-us/powershell/scripting/install/installing-powershell-on-windows) 或 WSL , Git Bash 這種 linux-based terminal 運行。\n\n## Start to Quzrtz\n官方網站有相關的教學: \n- https://quartz.jzhao.xyz/notes/setup/\n- https://quartz.jzhao.xyz/notes/obsidian/\n\n以下我將擷取最短步驟\n### 摘要步驟\n\n1. Fork quartz 的 Github 專案，並 clone 到 Local。\n2. 在 Clone 下來的倉庫中找到資料夾 `content`\n3. 在 `content` 資料夾中創建 Obsidian 倉庫，或是把既有的倉庫內容放到 content 裡面。\n4. 將 Obsidian 倉庫轉換成 Hugo 可用的\n\n    ```bash\n     hugo-obsidian -input=content -output=assets/indices -index -root=.\n    ```\n\n    需要注意，markdown 檔名不可以有 `.`，且每一篇文章都要有 metadata: 在頁首有 `title` 的資訊，如下: \n\n    ```markdown\n    ---\n    title: \"Private Stuff\"\n    ---\n    ```\n\n    其實有更多的 meta-data 可以設定，可以看 quartz 給的範例。由於使用 quartz 創建模板必須要 metadata，[作者建議](https://quartz.jzhao.xyz/notes/obsidian/)可以直接在 Obsidian 裡面創建模板，讓每新增一個模板都有這些資訊! \n\n5. 啟用 Hugo Server\n\n    ```bash\n     hugo server --enableGitInfo --minify \t# render faster\n     hugo server --disableFastRender \t\t# search bar will enable\n    ```\n\n\n## 關於 Obsidian 模板功能\n- 可以參考此文介紹如何建立模板 [【Obsidian 使用教學】筆記篇 05 — 結合資訊處理流程，讓筆記的 Metadata 變得更詳細](https://medium.com/pm%E7%9A%84%E7%94%9F%E7%94%A2%E5%8A%9B%E5%B7%A5%E5%85%B7%E7%AE%B1/obsidian-%E4%BD%BF%E7%94%A8%E6%95%99%E5%AD%B8-%E7%AD%86%E8%A8%98%E7%AF%87-05-%E7%B5%90%E5%90%88%E8%B3%87%E8%A8%8A%E8%99%95%E7%90%86%E6%B5%81%E7%A8%8B-e6a953438f43)\n- 要注意，插入模板的時候，需要打完檔案名稱，並把 Insert 的鼠標要在 Header 1 下的第一行。\n\n## Obsidian Embed \n在 Obsidian 會把頁面嵌入，在 Quartz 會直接轉換成內部連結。\n\n## 發佈到 Github Page\n\n參考 [[Publish Quartz to Github Page]]\n\n\n## 修改首頁\n\n如果想在首頁放置一些連結，引導到特定頁面，需要注意以下幾點: 雙向連結內放的是「相對於該頁面的路徑」，路徑對應的是檔案名稱。\n\n1.  當檔案名稱有空白時，網址會以 `-` 取代空白，但在雙向連結的撰寫中不可以寫 `-`。\n```\n[[notes/Area/PKM/Setup Quartz]] # OK  \n[[notes/Area/PKM/Setup-Quartz]] # Broken internal link\n```\n2.  注意結尾不要多加反斜線    \n3.  主頁相對於各檔案都是以 `note/` 開始\n\n## graphConfig\n在 `data/graphConfig` 最下面有一個設定項 `paths`，這是可以設定指定頁面節點的顏色，通常針對 MOC Page，如下例就是把 Effective-C++-Outline 的節點設成藍色。\n\n```yaml\npaths:\n    - /notes/Project/Effective-C++-Series/Effective-C++-Outline: \"#4388cc\"\n```","lastmodified":"2023-09-05T15:34:45.914894221Z","tags":[]},"/notes/Area/Quartz/Publish-Quartz-to-Github-Page":{"title":"將 Quartz 發佈到 Github Page","content":"由於我對 github action 不熟悉，在設置到 github page 的時候遇到了一點困難...。\n\n首先，如果專案是從 templage fork 過來的，它應該分成 `hugo` 跟 `master` 兩個 branch。其中\n\n- `hugo`: 存放 config, markdown files (`content` 底下) 的地方\n- `master`: 利用 github action 把專案內容轉成靜態網頁\n\n我因為是 clone 下來再 push 到自己的專案，沒有遵守這兩個命名方式而遇到了一點困難。在我的專案中，`main` 對應的是存放 markdown files (轉換前) 的 page，`publish` 才是 github page 再生成時所根據的 branch。\n\n## 設置 Github Action \n\n如作者的[教學](https://quartz.jzhao.xyz/notes/hosting/)所說，首先要打開 workflow permission。位置是 `Setting \u003e Action \u003e General`。\n\n![Set workflow Permission](https://quartz.jzhao.xyz/notes/images/github-actions.png)\n\n## 設置 Github Page \n\n在 `Setting \u003e Pages` 當中，將設置 Source 項目的 branch 設成 `master` (我則是設成 `pubslish`)。Domain name 除非自己有特別買網域，否則不用動。\n\n![Github page setting](https://quartz.jzhao.xyz//notes/images/github-pages.png)\n\n## Domain Name \n\n一共會影響兩個地方:\n\n- `config.toml`\n- `.github/workflows/deploy.yaml`\n\n如果用 github 預設的網址會是 `\u003cYOUR-GITHUB-USERNAME\u003e.github.io/\u003cProject-Name\u003e`。`config.toml` 的設定很簡單，就寫這個專案 root 網址為何:\n\n```yaml\nbaseURL = \"https://\u003cYOUR-GITHUB-USERNAME\u003e.github.io/\u003cPROJ\u003e/\"\n```\n\n`.github/workflows/deploy.yaml` 則要小心，這裡直接以我的為例，需要改兩個地方。\n\n```yaml\non:\n  push:\n    branches:\n      - main # 作者的範例是 hugo, 因為我有換 branch name 所以要改      \n```\n\n這樣，每當 push 行為發生在 `main` branch 上，就會觸發這個 action。 \n\n\n```yaml\n      - name: Deploy\n        uses: peaceiris/actions-gh-pages@v3\n        with:\n          github_token: ${{ secrets.GITHUB_TOKEN }}\n          publish_dir: ./public\n          publish_branch: publish\t# 作者預設是 master\n          cname: brainynight.github.io # 不用把 proj name 也寫上去\n```\n\n## 預覽變更\n\nGithub Action 當中，已經把建立 graph (`hugo-obsidian`) 的步驟也包含上去了。但要發布之前我們總需要自己本地先看看。\n\n作者其實有 makefile，應該可以 `make server`，會自動建立 graph 和 `hugo server`，或是懶得安裝 `make` 也可以直接打指令。以 windows 想複製 D 槽檔案為例: \n\n```bash\ncp /d/Database/*.md content/notes\nhugo-obsidian -input=content -output=assets/indices -index -root=.\nhugo server --disableFastRender\n```\n\n","lastmodified":"2023-09-05T15:34:45.914894221Z","tags":["Quartz"]},"/notes/Area/VimSeries/coc-snippets":{"title":"coc-snippets","content":"# Coc-snippets\n\n- 只要檔名有包含語言名稱，就可以被載入\n\n    ```\n    python1.snippets\n    python2.snippets\n    ...\n    ```\n\n    \n","lastmodified":"2023-09-05T15:34:45.914894221Z","tags":[]},"/notes/Project/Effective-C++-Series/%E4%B8%8D%E8%A6%81%E7%82%BA%E9%9D%9E%E5%A4%9A%E5%9E%8B%E7%94%A8%E9%80%94%E7%9A%84-Base-Class-%E5%AE%A3%E5%91%8A-Virtual-Function":{"title":"不要為非多型用途的 Base Class 宣告 Virtual Function","content":"\n\u003e 無端將不該擁有 `virtual` 的 class 宣告 virtual，與無端將所有的 function 宣告成 virtual，都是有毒的。 \n\n當類別不作為 Base Class，或是不作為多型時的基本 Class 時，不應該使用 virtual。\n原因是，`virtual` 背後是以 vptr (virtual table pointer) 和 vtbl (virtual table) 實作 virtual，需要耗費額外的記憶體。\n1. 將不能把資料結構式傳給其他語言 (C, FORTRAN) 撰寫的 function，因為它們沒有 vptr 的對應內容\n2. 增加物件大小，書中舉例一個 `Point` 物件，其中擁有兩個 int (64bits, in 32 bits system)，增加一個 `virtual` (一個 vptr) 將使 memory 達到 96 bits，相當其物件大小的 50%，在 64bits system 甚至達到增加 100%。\n","lastmodified":"2023-09-05T15:34:45.962894855Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/%E4%BA%86%E8%A7%A3%E5%A6%82%E4%BD%95%E5%9C%A8-Template-%E4%B8%AD%E6%8C%87%E6%B6%89-Base-Class-%E6%88%90%E5%93%A1":{"title":"了解如何在 Template 中指涉 Base Class 成員","content":"\n考量以下的類別關係，`Company` classes 會作為 template 的輸入參數傳入 MsgSender 體系的 Template。\n`LoggingMsgSender` 在繼承 `MsgSender` 的時候，刻意為新的 function 取 `sendClearMsg` ，不同於 Base class `sendClear`，這是好的做法，避免了 [[繼承時的名稱遮掩行為]] 以及遵守 [[絕不重新定義繼承來的 Non-virtual Function]]。\n![[Item43.png]]\n以下是 `LoggingMsgSender::sendClearMsg` 的 function body，這段 code 卻**無法通過編譯**\n\n```c++\ntemplate\u003ctypename Company\u003e\nclass LoggingMsgSender: public MsgSender\u003cCompany\u003e {\npublic:\n\t... // ctors, dtor, etc.\n\tvoid sendClearMsg(const MsgInfo\u0026 info)\n\t{\n\t\t// do some log...\n\t\tsendClear(info); // 呼叫繼承來的 base class function\n\t\t// do some log...\n\t}\n...\n}\n```\n\n問題是，當 Compiler 讀到 `class LoggingMsgSender` 的時候，並不知道它繼承的 `MsgSender\u003cCompany\u003e` 具象化起來，是怎麼樣的一個 class，Compiler 沒辦法確保這個未知的 Base class 是否有 `sendClear` function。\n\n## Template 繼承規則與物件導向繼承規則不同\n這正是條款1所說的，C++ 是一個聯邦。Template C++ 與 Object Oriented C++ 有些概念是不同的只能透過 Template Specialization 可以對特定的類別訂製特定的內容，Template 的繼承規則並不如物件導向繼承規則，在知道 `MsgSender\u003cCompany\u003e` 所代表的實體 class 之前，沒辦法確定 sendClear 是從哪來的，因為當前的 LoggingMsgSender 不存在這樣的 function。\n\n## 解決辦法\n以下的作法都是權宜之計，都是假設 Base Class 確實擁有 `sendClear` 的情況，但書中有沒有提更好的解法。\n### 在 Base Class function 前加上 `this-\u003e`\n```c++\ntemplate\u003ctypename Company\u003e\nclass LoggingMsgSender: public MsgSender\u003cCompany\u003e {\npublic:\n\tvoid sendClearMsg(const MsgInfo\u0026 info)\n\t{\n\t\tthis-\u003esendClear(info); // pass, 假設 sendClear 會被繼承\n\t}\n}\n```\n\n### 使用 Using 宣告式\n[[使用關鍵字 using 讓特定 function 在 Scope 內可見]]，使用的方法相同。不過在該例中是為了 [[繼承時的名稱遮掩行為]] 問題，本例的肇因卻是 Compiler 不會進入 Base Class Scope 找 function，我們透過 `using` 請 Compiler 這麼做。\n\n```c++\ntemplate\u003ctypename Company\u003e\nclass LoggingMsgSender: public MsgSender\u003cCompany\u003e {\npublic:\n\tusing MsgSender\u003cCompany\u003e::sendClear;\n\tvoid sendClearMsg(const MsgInfo\u0026 info)\n\t{\n\t\tsendClear(info);\n\t}\n}\n```\n\n\n### 以 Base Class 的 Namespace 呼叫該 Function\n```c++\ntemplate\u003ctypename Company\u003e\nclass LoggingMsgSender: public MsgSender\u003cCompany\u003e {\npublic:\n\tvoid sendClearMsg(const MsgInfo\u0026 info)\n\t{\n\t\tMsgSender\u003cCompany\u003e::sendClear(info);\n\t}\n}\n```\n\n這個方法的缺點是如果被呼叫的是 virtual function，這個明確的修飾(explicit qualification) (`MsgSender\u003cCompany\u003e::`) 會關閉 virtual 的綁定行為。\n\n### 結論\n在 invalid reference to base class member 這個問題上，Compiler 有兩種做法\n1. 在檢視 Derived Class Template Definition 時就診斷，此處的缺點是 Template 參數尚未具象化，無法得知 \"真正的 Base Class\" 的長相\n2. 等到 Template 參數具象化時，再檢視這個 reference 是否有效。\n\nC++ 的政策是傾向第一種，及早診斷。因此 Compiler 彷彿完全不知道 Base Class 有哪些東西可以呼叫一樣。\n\n而上述的三個手段，就是讓 Compiler 不要看到黑影就開槍(爆 error)，「先」假設 Base Class 有這個 function，讓編譯往下走。如果後來發現因為 template specialization 等原因，呼叫的 function 不存在，依然不會通過編譯，這依然是一個無效的 reference。","lastmodified":"2023-09-05T15:34:45.962894855Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/%E4%BA%86%E8%A7%A3-Inline-%E7%9A%84%E8%A3%A1%E8%A3%A1%E5%A4%96%E5%A4%96":{"title":"了解 Inline 的裡裡外外","content":"\n## 原理\n用程式碼取代 function call\n\n## 向 Compiler 發出申請\n\nProgrammer 可以明確的提出請求，或隱喻的提出。但編譯器可以拒絕這個申請，大部分過於複雜的函式都會被拒絕 inline:\n- 有 loop 的\n- 多數的 virtual function (等 Runtime 才確定哪個被喚醒)\n\n顯示與隱式的分別:\n- 顯式: 關鍵字 `inline` 是一種對 Compiler 發出的明確請求，但 Compiler 不一定會聽話。\n- 隱式: 有另一種暗示請求，就是把 function 實作寫在 class 定義裡面。這種通常是 member function，但 friend function 也可直接定義在 class 內，因此也可能被隱式宣告為 inline。\n\n```cpp\nclass Person {\npublic:\n\tint age() const { return theAge; } \n\t// an implicit inline request: age is  defined in a class efinition\nprivate:\n\tint theAge;\n};\n```\n\n\n\n## 優點\n當 inline function 本身很小的時候，把程式碼展開在呼叫者的「函式本體」的成本(object code 大小) ，會比呼叫該 function 所產生的成本來的小! \n\n## 缺點\n1. 當 inline func 函式本體龐大，這些龐大的碼會散布在各個呼叫者的函式本體，導致程式太大。\n2. 由於它的表現相當於直接展開在各個呼叫者身上，一旦 inline function 有更改，caller 也會被更動。而 non-inline 就只會是重新連結的問題，對重新 Compile 的負擔比較小。\n3. Debugger 沒辦法對付 Inline function --- 怎麼對一個不存在的函式設定中斷點呢?\n\n## Guidline \n- 限制 Inline 使用的時機: 它有絕對的理由必須是 inline (template 規定?) [[需要型別轉換時請為模板定義非成員函式]]\n- 十分平淡無奇，像是 `return m_size` 這般無聊。\n\n## Library Provider 必須謹慎評估是否宣告函式為 Inline \n有關 Inline 帶來的壞處，敘述於 [[建構和解構式是 inline 的糟糕人選]]。\n\n要注意，inline 無法隨著函式庫升級而升級，一旦 inline funciton 內容有變更，Client 端所有有用到該 function 的程式都需要重新編譯。\n而若不用 inline，Client 端只需要重新 Link 即可。\n\n## Template and Inline\n\ninline function 通常一定放在 header file 裡面，因為大多數的建置環境會在編譯中做 inlining，為了把 function call 換成「被呼叫函式」本體，必須知道被呼叫函式的內容。\n\nTemplate 也通常放在 header file，因為一旦使用，Compiler 為了具現化，同樣需要知道其內容。\n\n但 inline 具現化與 template 具現化無關，不過，如果 template 的作者**希望** function 為 inline，應該明確以關鍵字 `inline` 宣告。\n\n## 如何決定是否要 Inline? \n善用 [[80-20 Rule]] 找出最關鍵、最常被 Call 的程式碼去判斷是否該用 Inline 優化它!","lastmodified":"2023-09-05T15:34:45.962894855Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/%E4%BB%A5-Const-%E5%8F%96%E4%BB%A3%E4%BD%BF%E7%94%A8-Define":{"title":"以 Const 取代使用 Define","content":"\n## 以編譯器取代前處理器\n\n `#define` 的本質是 word replacement，如: `#define RATIO 1.653`，編譯器可能不認得 `RATIO` 並在錯誤訊息中從頭到尾以 1.653 取代 `RATIO`。\n```cpp\n const double Ratio=1.653; // Prefer\n```\n\n當以 `const` 取代 `#define` 時，有兩個需要注意的點\n1. 定義常數指標 (const pointer): 常數指標用於 「不允許此Pointer更改指向的對象」，因此需要對 pointer 宣告 const\n\n```cpp\nconst std::string = authorName(\"Scott\");\n ```\n\n2. Class 的專屬常數: 目的是限制常數的 Scope，因此要宣告在 class 內部。而為了使這個常數只有一個實體(所有 instance 共享同一個常數)，還需要宣告 `static`。\n\n```cpp\nclass Player {\nprivate:\n\tstatic const int num = 5;\n\tint scores[num];\n}\n ``` \n\n\n## 具有 Access Level\n第二點的用途，設置一個在某特定類別才生效的常數變是 `#define` 做不到的，`#deinfe` 不在乎 scope，不能帶來封裝性，更沒有 `private #deinfe` 這種東西。\n","lastmodified":"2023-09-05T15:34:45.962894855Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/%E4%BD%BF%E7%94%A8%E9%97%9C%E9%8D%B5%E5%AD%97-using-%E8%AE%93%E7%89%B9%E5%AE%9A-function-%E5%9C%A8-Scope-%E5%85%A7%E5%8F%AF%E8%A6%8B":{"title":"使用關鍵字 using 讓特定 function 在 Scope 內可見","content":"首先了解 [[繼承時的名稱遮掩行為]]。\n\n如果，我們只是想為 Derived Class 增加同名稱、Signature 不同的 function? 我們希望 Base Class 的 function 仍然可以被使用! 則，需要做的是用 `using` 讓 Base Function 變得可見，如下例: \n\n```cpp\nclass Derived: public Base {\npublic:\n\tusing Base::mf1; // make all things in Base named mf1 and mf3\n\tusing Base::mf3; // visible (and public) in Derived’s scope\n\tvirtual void mf1();\n\tvoid mf3(); // override Derived::mf3, even \n\tvoid mf4();\n...\n};\n\nDerived d;\nint x;\n...\nd.mf1(); // still fine, still calls Derived::mf1\nd.mf1(x); // now okay, calls Base::mf1\nd.mf2(); // still fine, still calls Base::mf2\nd.mf3(); // fine, calls Derived::mf3\nd.mf3(x); // now okay, calls Base::mf3 \n// (The int x is implicitly converted to a double so that  the call to Base::mf3 is valid.)\n```\n\n`using` 放在 public 是因為 Public 繼承，function 在 Base class 是 public ，基於正確的 public 繼承前提，Derived Class 在 `using` 暴露 Base Class 的 function name 時，也應該要是 Public 。\n\n- 可以不要繼承所有 Base Class 的所有函式嗎?\n\t- 在 Public 繼承下這不可能發生，這違反了 [[確保 Derived Class 和 Base Class 之間必然保持 Is-a 關係]]。\n\n## Private 繼承: 使用 forwarding function 繼承部分函式\n不繼承所有 Base Class 的所有函式，在 Private 繼承是有意義的。同樣的遇到名稱遮掩問題，該怎麼做?\n\n同樣以下圖為例，如果 Derived Class 只要 `void mf3()`，不要 `void mf3(double)`? \n![[Itm33.png]]\n\n那將無法使用 `using`，因為用下去所有的 `Base::mf3` 都會變得可見。這時候要換個手法: forwarding function。\n\n```cpp\nclass Base {\npublic:\n\tvirtual void mf1() = 0;\n\tvirtual void mf1(int);\n\t... // as before\n};\nclass Derived: private Base {\npublic:\n\tvirtual void mf1() { Base::mf1(); } \n\t// forwarding function; implicitly inline — see Item 30. \n\t// (For info on calling a pure virtual function, see Item 34.)\n}; \n\nDerived d;\nint x;\nd.mf1(); // fine, calls Derived::mf1\nd.mf1(x); // error! Base::mf1() is hidden\n```\n\n\n當繼承結合 Template，繼承名稱遭到遮掩的問題會再度發生，參見 [[了解如何在 Template 中指涉 Base Class 成員]]","lastmodified":"2023-09-05T15:34:45.962894855Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/%E5%8D%80%E5%88%86%E4%BB%8B%E9%9D%A2%E7%B9%BC%E6%89%BFinterface%E5%92%8C%E5%AF%A6%E4%BD%9C%E7%B9%BC%E6%89%BFimplement":{"title":"區分介面繼承(interface)和實作繼承(implement)","content":"\n## 背景\nBase Class Designer 在設計界面的時候，可能對 Derived Class 實踐者有三種期許\n- 只繼承 Member Function Interface (承襲宣告式)\n- 同時繼承 Member Function Interface 和**預設的**實作，也可以 override。\n- 同時繼承 Member Function Interface 和實作，不允許 override (不要自己改實作!)\n\n## Pure Virtual Function : 只繼承 Interface 需自行實做\n[[Pure Virtual Function]] 相當於告訴 Client: 你需要提供一個這樣的函式，但我不干涉你怎麼做它。\n```cpp\nclass Shape {\npublic:\n\tvirtual void draw() const = 0;\n};\n```\n\n## Impure Virtual Function : 繼承 Interface 和預設實作\n```cpp\nclass Shape {\npublic:\n\tvirtual void error(const std::string\u0026 msg);\n};\n```\n\n相當於告訴 Client: 你需要提供一個這樣的函式，如果不想自己寫，可以用預設的內容! \n\n但是，讓 impure virtual function 同時擔任「要求 client 給一個這樣的函式」又在「實作中放了預設行為」 Client 端可能在不知情下忽略要自己實作，而引發問題 [[Impure Virtual Function]]。\n\n## Non-Virtual Function: 繼承介面與實作，不應重新撰寫實作\n代表不變性(invariant)、凌駕特異性(specialization，因此不該在 Derived Class 中重新被定義。\n[[絕不重新定義繼承來的 Non-virtual Function]]\n\n## Conclustion\n1. 不該將所有的函式宣告成 non-virtual，這會導致 Derived 沒有空間特異化，特別是 non-virtual destructor 會帶來問題: [[為多型用途的基礎類別宣告 virtual 解構式]]\n2. 不該將所有的函式宣告成 virtual，某些時候這是正確的，像是 Interface Class。但多數時候這是 Base Class Designer 沒有堅定立場，某些 Function 就是不該在 Base Class 被重新定義! \n\n","lastmodified":"2023-09-05T15:34:45.962894855Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/%E5%A4%9A%E9%87%8D%E7%B9%BC%E6%89%BF-Multiple-Inheritance-MI":{"title":"多重繼承","content":"- 單一繼承 (Single Inheritance, SI)\n- 多重繼承 (Multiple Inheritance, MI)\n---\n\n## 了解 C++ 如何解決歧異 (ambiguity)\n\n函式名稱、typedef 都可能發生歧異。C++ 解決歧異的方式與決議(resolving) overloading function 的規則相同\n- 先找最匹配的呼叫函式\n- 如果匹配度相同，才會發生歧異，因為沒有最佳匹配。\n\n面對歧異，在呼叫的時候需要明指呼叫的是哪一個 class 的 function:\n```cpp\nobj.BaseClass::someFunc();\nobj.DerivedClass::someFunc();\n```\n\n## 鑽石繼承\n試想下圖，假設 `File` 裡面有一個 member data `fileName`，而在 `IOFile` 當中，它該有幾個 `fileName` data?\n![[Item40.png]]\n\n1. 來自 `InputFile::fileName`, `OutputFile::fileName`各一份\n2. 只該一份，來自兩個 Parent Class 的 fileName 應該要相同，且只有一份 `fileName` 資料握在 `IOFile`。\n\nC++ 的預設做法是 (1)，各複製一份。但同時也支援 (2)，只是在繼承時需要宣告 virtual: [[Virtual Base Class]]。\n\n## 結論\n- 有單一繼承，就用單一繼承\n- 如果多重繼承能帶來比單一繼承低的維護成本、且合理，別猶豫。\n\t- 其中一種例子 (P195~199) : public 繼承某個 Interface class, private 繼承某個協作實作的 class，就是多重繼承的一個合理展現。\n","lastmodified":"2023-09-05T15:34:45.962894855Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/%E5%AF%A9%E6%85%8E%E7%9A%84%E4%BD%BF%E7%94%A8-Private-%E7%B9%BC%E6%89%BF":{"title":"審慎的使用 Private 繼承","content":"- Private 繼承代表 implemented in terms of (根據某物實作出)\n- 當 `class D` 以 Private 繼承 `class B`，目的是「調用 class B 的 API」，通常意味著只有實作要被繼承，介面不需要。所以 private 繼承來的 function 也只應該放在 private 區塊。\n- Private 繼承是實作上的手段，跟 OO design 沒有關係。\n\n## implemented in terms of (根據某物實作出)\n在 [[確定 Composition 塑造的是 'Has-A'關係 或 '根據某物實作'的關係]] 裡面也提及 implemented in terms of (根據某物實作出) 的關係。\n\n在多數的情況下，composition 是優於 private 繼承的，只有當\n- 要調用 protected member \n- virtual function 需要重新定義\n被牽扯進來時才應該考慮 Private 繼承。\n\n即使必須使用 Private 繼承，記住[[讓介面易於被使用，不易誤用]]，我們可以透過一些手段把 Private 繼承的影響「藏起來」\n## Private 繼承的範例\n情境\n1. 有一個 `Widget` 物件，我們想要知道他被呼叫的次數，並且會週期性的檢視它的資料。\n2. 為此，需要一個計時器 `Timer`，在工具箱中發現了它! 只要重新定義 `onTick`，在裡面寫取出 Widget 物件的狀態即可!\n```c++\nclass Timer {\npublic:\n\texplicit Timer(int tickFrequency);\n\tvirtual void onTick() const; // automatically called for each tick\n...\n};\n```\n\n- Question: 應該讓 Widget 繼承 Timer 嗎?\n\t- Public 繼承: Widget 並非 Timer，這違反 [[確保 Derived Class 和 Base Class 之間必然保持 Is-a 關係]]\n\t- Private 繼承: 可以重新定義 `onTick`，客戶端也沒能力呼叫到它，OK。\n\n## Composition + Private 繼承\n比起直接的 Private 繼承，我們有更好的做法。\n![[Item39.png]]\n\n此作法的好處有兩個\n### 為 Base Class 設計做考量\n- 如果 Widget 被設計成 Base Class，卻不希望 Derived Class 重新定義 `onTick`，就不適合直接讓 Widget 以 Private 繼承 Timer。但新的設計讓 `WidgetTimer`繼承 Timer 得以重新定義 virtual function，並把 timer 物件放在 private，現在 derived class 想碰也碰不到 timer 了。\n```c++\nclass Widget {\nprivate:\n\tclass WidgetTimer: public Timer {\n\tpublic:\n\t\tvirtual void onTick() const;\n\t\t...\n\t};\n WidgetTimer timer;\n...\n}\n```\n\n### 降低編譯依存性\n如果 Widget 繼承 Timer ，則 Widget 被編譯時，Timer 的定義也必須可見。也就是說 Widget 需要 `#include Timer.h`。但如果把 `WidgetTimer` 以一個 pointer 存在 `Widget`，則不再需要 include，達到 decoupling。\n[[將檔案的編譯依存關係降到最低]]\n\n```c++\nclass Widget {\nprivate:\n\tWidgetTimer* timer; // better way: use smart pointer\n}\n\n// In another file\nclass WidgetTimer: public Timer {\npublic:\n\tvirtual void onTick() const;\n\t...\n};\n```\n\n## 其他\n[[EBO (Empty Base Optimization)]]","lastmodified":"2023-09-05T15:34:45.962894855Z","tags":["cpp",""]},"/notes/Project/Effective-C++-Series/%E5%B0%87%E6%AA%94%E6%A1%88%E7%9A%84%E7%B7%A8%E8%AD%AF%E4%BE%9D%E5%AD%98%E9%97%9C%E4%BF%82%E9%99%8D%E5%88%B0%E6%9C%80%E4%BD%8E":{"title":"將檔案的編譯依存關係降到最低","content":"\n首先清楚此內容: [[編譯依存-宣告式、定義式與實作細節]]。\n接著，需要分清楚「被 include 的對象」與「被前置宣告的對象」。\n\n## 被 include 的對象\n1. 當需要創建某類別的物件，例如 : 要創建 member data `m_date`，則需要 include Date.hpp。\n2. 有用到 STL 物件，則直接 include STL 函式庫。\n\n對於 STL 函式庫，應該用 `#include`，而不是使用前置宣告。include 標準函式庫的 header file 幾乎不會造成編譯瓶頸。\n\n```c++\n// 正確做法\n#include \u003cstring\u003e\n\n// 錯誤作法\nnamespace std {\n\tclass string;\n}\n```\n\n## 被前置宣告的對象\n只要不是要創建物件，不是 STL 物件，就可以使用前置宣告解決需求!! \nSTL 物件已經經過優化，不用擔心 include 負擔。\n\n## 降低編譯依存的手法: Pimpl Idiom\n\n[[pimpl idiom (pointer to implementation)]]\n","lastmodified":"2023-09-05T15:34:45.962894855Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/%E5%B0%91%E5%81%9A%E8%BD%89%E5%9E%8B%E5%8B%95%E4%BD%9CMinimize-casting":{"title":"少做轉型 Minimize casting","content":"## 常見的轉型語法\n\n```cpp\n// 舊式轉型\n(T) expr; // C-style\nT(expr);  // func style\n\n// New-style/ C++ Style  casting \nconst_cast\u003cT\u003e(expr);\nstatic_cast\u003cT\u003e(expr);\nreinterpret_cast\u003cT\u003e(expr);\ndynamic_cast\u003cT\u003e(expr);\n```\n\n- `dynamic_cast`: 安全向下轉型 (safe downcasting)，是一個可能耗費重大執行成本的轉型動作\n- `static_cast`: 強迫隱式轉換，像是 non-const to const, int to double...，但不能做 const to non-const.\n- `const_cast`: 唯一可以做到 const to non-const.\n\n即使舊式轉型依然有用，通常建議用新式，好處是\n1. 容易在程式碼中被搜尋\n2. 意圖窄化，像是如果想移除 constness，則必須使用 const_cast，其他都不會通過編譯。\n```cpp\nconst int a = 1;\nint b = static_cast\u003cint\u003e(a); // fail\nint b = const_cast\u003cint\u003e(a); // ok\n```\n\n\n## 不是圖臆測轉型的 Pointer 如何實作\n\n在某些語言中，Drived Class 轉成 Base Class 在 Pointer 上只是一個 Offset。但在 C++ 中，Pointer 是怎麼「算」出來的取決於 Compiler。不要試圖「猜」要抓哪個 Address，相當於 Casting，該用 `static_cast` 就乖乖用。\n\n\n## 常見的轉型誤用: 試圖使用 Casting 以呼叫 Base Class 方法\n有些框架要求 Drived Classes 的 Virtual func 實作時，要先呼叫 Base Class 的對應函式。\n在 Python 中，呼叫 Parent 的方法可以使用 `super()`，在 C++ 中，直接在 Drived Class 當中，使用 Base Class 的名稱空間以呼叫 Base Class 方法! \n\nExample: \n```cpp\nclass Window {\npublic:\n\tvirtual void onResize;\n}\n\nclass SpecicalWindow: public Window {\npublic: \n\tvirtual void onResize() {\n\t\t// 錯誤作法\n\t\tstatic_cast\u003cWindow\u003e(*this).onResize();\n\t\t// 正確做法\n\t\tWindow::onResize();\n}\n```\n\n錯誤方法的呼叫，相當於\n```cpp\nWindow tmp = static_cast\u003cWindow\u003e(*this);\ntmp.onResize();\n```\n\n## Dynamic Cast\n\n### 效率問題\n`dynamic_cast` 有嚴重的效率問題，多重繼承/深度繼承越多，效率成本越大。\n某些時候採用它有必要的原因: 需要支援動態連結。\n\n## 如何避免使用?\n### Dynamic Cast 的使用場合\n手上握有一個 base class pointer/reference，但你認定這個 base class pointer 所指向的對象是某一個 dirved classs。\n\n### Solution1 使用 Type-Safe Container\n同樣接續上例的 `Window`\n\n```cpp\n\nstd::vector\u003cWindow\u003e winPtrs;\n\ntypedef std::shared_ptr\u003cSpecialWindow\u003e SPW;\nSPW sp_ptr;\nsp_ptr = *winPtrs.begin();\n```\n\n\u003e [!question] \n\u003e 1. 這裡本質不還是 static cast?\n\u003e 2. 如何保證 type 正確?? container 有測試?\n\n### Solution2 在 Base Class 撰寫對應的 Virtual Func\n[[區分介面繼承(interface)和實作繼承(implement)]]\n\n```cpp\nclass Window {\npublic:\n\tvirtual void onResize;\n\tvirtual void blink() {};\n}\n\nclass SpecicalWindow: public Window {\npublic: \n\tvirtual void onResize() {...};\n\tvirtual void blink() {\n\t\t// implement!!\n\t};\n}\n```\n\n","lastmodified":"2023-09-05T15:34:45.962894855Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/%E5%B7%A5%E5%BB%A0%E5%87%BD%E5%BC%8F-Factory-Function":{"title":"工廠函式 (Factory Function)","content":"\u003e Factory method pattern enables us to create an object without exposing the creation logic to the client and refer to the newly-created object using a common interface. It is one of the most widely used creational patterns.\n\u003e This pattern is also known as the Virtual Constructor.\n\n\nhttps://dzone.com/articles/factory-method-design-pattern","lastmodified":"2023-09-05T15:34:45.962894855Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/%E5%BB%BA%E6%A7%8B%E5%92%8C%E8%A7%A3%E6%A7%8B%E5%BC%8F%E6%98%AF-inline-%E7%9A%84%E7%B3%9F%E7%B3%95%E4%BA%BA%E9%81%B8":{"title":"建構和解構式是 inline 的糟糕人選","content":"\n考量以下例子:\n```cpp\nclass Base {\npublic:\n...\nprivate:\n\tstd::string bm1, bm2; // base members 1 and 2\n};\nclass Derived: public Base {\npublic:\n\tDerived() {} // Derived’s ctor is empty — or is it?\n...\nprivate:\n\tstd::string dm1, dm2, dm3; // derived members 1–3\n};\n```\n建構式 `Derived::Derived` 乍看內容是「空的」很適合 inlining?\n\n別忘了，物件產生的時候，每一個 Base Class、每一個成員變數的 constructor 都會被呼叫，反之，物件被銷毀時，destructor 也會依序呼叫。\n\n這些動作並非憑空發生，Compiler 在編譯期間會代為產生，並安插到程式碼中，彷彿以下內容就是 Compiler 代為成生的 (這並非實際會生成的，編譯器會更精巧的處理 exception)。\n\n```cpp\nDerived::Derived() // conceptual implementation of\n{ // “empty” Derived ctor\n\tBase::Base(); // initialize Base part\n\ttry { dm1.std::string::string(); } // try to construct dm1\n\tcatch (...) { // if it throws,\n\tBase::~Base(); // destroy base class part and\n\tthrow; // propagate the exception\n}\ntry { dm2.std::string::string(); } // try to construct dm2\ncatch(...) { // if it throws,\n\tdm1.std::string::~string(); // destroy dm1,\n\tBase::~Base(); // destroy base class part, and\n\tthrow; // propagate the exception\n}\ntry { dm3.std::string::string(); } // construct dm3\ncatch(...) { // if it throws,\n\tdm2.std::string::~string(); // destroy dm2,\n\tdm1.std::string::~string(); // destroy dm1, \n\tBase::~Base(); // destroy base class part, and\n\tthrow; // propagate the exception\n}\n}\n```\n\n但從本例我們可以看到，`Derived::Derived` 會去呼叫 `Base::Base` ，如果試圖對 `Derived::Derived` 做 `inline`，Compiler 會檢視 `Derived::Derived` 所呼叫的 funciton，決定 `Derived::Derived` 是否有被 `inline` 的資格。\n\n如果每一個在 `Derived::Derived` 當中被呼叫的都是 inlined function .... 讓我們一一檢視這件事\n\n- 假設 std::string constructor 是 inline function。\n- `Base::Base` 被宣告 inline ，它要呼叫 `bm1`, `bm2` 兩次 std::string constructor。\n- `Derived::Derived`: 被宣告 inline ，光是自己的 member data (不含 base) 要呼叫 `dm1`, `dm2`, `dm3` 三次 std::string constructor。\n\n`Derived::Derived` 總共要呼叫 5次 std::string constructor，一旦宣告成 inline，std::string constructor code 會插入**5份**在 `Derived::Derived` !!\n\n\n\n","lastmodified":"2023-09-05T15:34:45.962894855Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/%E6%80%9D%E7%B6%AD%E8%AA%A4%E5%8D%80-%E7%89%A9%E4%BB%B6%E5%BE%88%E5%B0%8F%E5%B0%B1%E5%8F%AF%E4%BB%A5-Pass-By-value":{"title":"思維誤區-物件很小就可以 Pass By Value","content":"有三個主因: \n1. 並非「該物件/container」**看起來**很小，用 Pass by value 就沒有問題。許多  STL Container 在實作上的大小也就一個 Pointer 大一點，但 Copy Container 卻有「複製每一個 Pointer 所指向的物件」的風險在。\n2. 視 Compiler 而定，有些 Compiler 對待 Custom class 跟 built-in class 的態度大不相同，即使底層表述(underlying representation) 相同，仍可能以不同的操作對待，導致 Copy 在 Custom Class 就是比較慢。\n3. Type 實作可能發生改變，現在 Copy 的代價不昂貴，不代表以後不會。\n\n## Pass By Value 的代價\n[[Pass by value 當中的 Copy 行為]]\n","lastmodified":"2023-09-05T15:34:45.962894855Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/%E6%89%93%E7%A0%B4-Constness-%E9%99%90%E5%88%B6":{"title":"打破 Constness 限制","content":"\n### Physical Constness\n\u003e 編譯器堅守的觀點: Physical Constness，又稱 Bitwise constness。Const member function 不可以修改任何 non-static member data。\n\n然而，請看下例: `operator[]` 確實不會更動到 member data，可以通過 Bitwise Testing，卻把「改動權」暴露給 Client 端，造成不應該的賦值行為。\n- [[避免傳回 Handles 指向物件的 Private \u0026 Protected Member Data]]\n\n```cpp\nclass CTextBlock {\n\npublic:\n    // inappropriate (but bitwise const) declaration of operator[]\n    char\u0026 operator[](std::size_t position) const\n    { return pText[position]; }\n    \nprivate:\n    char *pText;\n}\n\nconst CTextBlock ctb(\"World\");\nctb[0]='F'; // Become \"Forld\"\n```\n此例應該將回傳型態修改為 `const char\u0026`。\n\n編譯器堅守的 Bitwise constness 觀念，造成 Const Function 作用過於綁手綁腳，甚至在 Const \u0026 Non-Const function 之間我們可能需要 Own 兩份相似的 Code! \n接下來將說明 `mutable` 與 const cast，他們將幫助我們破除 const 的限制，使程式設計更加靈活。\n\n### Logical Constness\n\u003e 概念上的常數性 (Conceptual Constness)\n\n我對這個論點的解讀是，某些 data 是藏於封裝底下，沒有暴露給 User 修改的。這種 member data 在 logical constness 的觀念下是可被修改的。\n書中舉例，若我們在 `CTextBlock` 當中有一個快取 (cache) 的 member data ，用來記當前字串的長度。當字串沒有修改長度的行為(增加/減少)時，此快取都是有效的。但若有修改行為，則在 `length()` 被 Query 時，我們會需要更新這個快取。\n\n在 Bitwise Constness 的觀念下，修改這個快取用途的 member data 是不合法的，且這也是 Compiler 的觀點。\n解決辦法是，使用關鍵字 `mutable` 宣告這些有資格在 const function 內被改動的 data，`mutable` 使得 const function 在實踐上有討價還價的空間。\n\n\u003e `mutable` 釋放 non-static member data 的 bitwise constness 約束 (釋放 member data 的不可變動性)。\n\n\n### Avoiding Duplication in const and Non-const Member Functions\n\u003e 當 const 和 non-const member function 有等價的實作時，讓 non-const 呼叫 const 可以避免 duplicated code。\n\n若我們在 const \u0026 non-const function 當中，都有相同的程序要做: 邊界檢查、write log、verty data...，即使子步驟都可以抽出來，還是造成「走 flow 的流程」會重複在兩個 function 當中。\n\n```cpp\nclass TextBlock \n{\n\tconst char\u0026 operator[](std::size_t position) const;\n\tchar\u0026 operator[](std::size_t position);\n}\n```\n\n我們該做的是，把所有的東西寫在其中一個，而另一個去呼叫寫著 flow 的 function。這說明了我們的一個需求: 去除 Constness!\n\n我懷疑這個手法在 C++11 \u0026 14 可能有其他解，這裡先跳過細究。簡單來說就是透過 `const_cast` 將 const function 的結果再轉成非 const。\n\n```cpp\nclass TextBlock {\npublic:  \n\t// same as before\n    const char\u0026 operator[](std::size_t position) const {\n        return text[position];\n    }\n\t// now just calls const op[]\n    char\u0026 operator[](std::size_t position) \n    {\n        // cast away const on op[]’s return type\n        // add const to *this's type, call const version of op[]\n        return const_cast\u003cchar\u0026\u003e(\\\n\t        static_cast\u003cconst TextBlock\u0026\u003e(*this)[position]\n\t\t);\n    }\n};\n```\n ","lastmodified":"2023-09-05T15:34:45.962894855Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/%E7%82%BA%E4%BB%80%E9%BA%BC%E8%A6%81%E7%94%A8%E7%8D%A8%E7%AB%8B%E5%8F%A5%E5%B0%87%E7%89%A9%E4%BB%B6%E6%94%BE%E5%85%A5-Smart-Pointer":{"title":"為什麼要用獨立句將物件放入 Smart Pointer","content":"\u003e 盡可能確保 `new` 出來的物件，可以立即被放入 smart pointer 裡面，避免任何額外的步驟。只要有多餘的步驟，就可能因為意外而使得 smart pointer 沒有真正掌控到資源。\n\n以獨立一句話將 newed 物件加入 smart pointer，格式如下\n\n```cpp\nstd::shared_ptr\u003cWidget\u003e pw(new Widget);\nprocessWidget(pw, priority());\n```\n\n---\n\n其原因是，如果像以下寫法\n```cpp\nprocessWidget(std::shared_ptr\u003cWidget\u003e pw(new Widget), priority());\n```\n\n編譯器要做的有三件事\n1. 呼叫 `priority`\n2. 執行 `new` \n3. 呼叫 smart pointer constructor\n\n而我們無法確保這三件事的最終順序為何，必然的關係只有 「會先 `new` ，再執行 smart pointer constructor」。而 `priority` 是**可能**安插於 new 之後的。\n\n1. `new` \n2. `priority` (發生錯誤)\n3. smart pointer constructor\n\n如果不幸的，編譯器選擇這種順序，並且在把物件放入 smart pointer 之前發生了錯誤，這塊記憶體將沒有 smart pointer 協助銷毀! \n","lastmodified":"2023-09-05T15:34:45.962894855Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/%E7%82%BA%E5%A4%9A%E5%9E%8B%E7%94%A8%E9%80%94%E7%9A%84%E5%9F%BA%E7%A4%8E%E9%A1%9E%E5%88%A5%E5%AE%A3%E5%91%8A-virtual-%E8%A7%A3%E6%A7%8B%E5%BC%8F":{"title":"為多型用途的基礎類別宣告 virtual 解構式","content":"\n## 多型\n多型有個特點: Base Class 的存在是為了「經由 Base Class Interface 處置 Drived Class Object」，以下例來說， `TimeKeeper` 是一個 Polymorphic Base Class，所以持有一個 `TimeKeeper` Pointer 就可以處理 `WaterClock`, `WristWatch` 物件，這就是上面那句話的意思。\n\n```cpp\nclass TimeKeeper {\npublic:\n\tTimeKeeper();\n\tvirtural ~TimeKeeper();\n};\nclass AtomicClock: public TimeKeeper { ... };\nclass WaterClock: public TimeKeeper { ... };\nclass WristWatch: public TimeKeeper { ... };\n\nTimeKeeper* getTimeKeeper(); \n// Returned pointer may be AtomicClock, WaterClock, WristWatch\n// But they can be owned by base class \"TimeKeeper\"\n// This is polymorphy.\n```\n\n繼承與多型之間並非充分必要條件，**非所有的 Base Class 都是作為多型使用**。\n像是 [[Item47 Use traits classes for information about types]] 的 `input_iterator_tag`，繼承更像是 \"enable 某種特性\" 的用途。 \n\n\n## 多型的 Base Class 沒有 Virtural Destructor 又如何\n多型 (polymorphic) 的手法使我們可以持有 base class 的 Pointer 指向各種 child class 的實作。[[工廠函式 (Factory Function)]]  就是典型的實作。\n\n\u003e [!question]\n\u003e 為了遵守 factory function 的規矩，哪來的規矩?\n\n為了遵守 factory function 的規矩，factory function 回傳的物件必須位於 heap (在 function 中被 `new` 出來的)，被 `new` 出來的物件必須手動刪除它。\n```cpp\nTimeKeeper* ptk = getTimeKeeper();\ndelete ptk;\n```\n\n儘管 [[Smart Pointer|條款13 使用資源管理器]] 和 [[讓介面易於被使用，不易誤用]] 說明了依賴 client 做 `delete` 有潛在的危險跟不確定，這裡要說明的是更嚴重、更根本性的問題。\n- 我們宣告的是 **Base class pointer**，指向的是 **child class 物件**。\n- Base class 擁有一個 non-virtural 的 destructor\n- C++ 明白的告訴我們，當 child 物件經由擁有 non-virtural destructor 的 Base class pointer 持有，而這個 pointer 被刪除時，屬於 **Undefined behavior**\n\n此 Undefined Behavior **通常**會發生的是，屬於 Base class 部分成功銷毀，只屬於 Child Class 的 member data **沒有被銷毀**，造成**部分銷毀**的詭異狀況。\n\n要消除這種作法的解答就是，給 Base class 的 destructor 設置 `virtural`。\n\n\u003e 一個 Class 若有帶有 `virtural` 的函式，幾乎可以確定**該有**會帶有 `virtural` 的 destructor。如果一個 class 不帶有 `virtural` function，通常代表它不意圖被當作 base class。\n\n (實作都寫完在 base 了，還特意搞繼承 override 幹嘛?)。然而，`virtural` 也不應該亂用: [[不要為非多型用途的 Base Class 宣告 Virtual Function]]。\n\n## 企圖以多型設計架構前，檢查 Base Class 的 Destructor 是否為 Virtual\n\n如果不是 virtural destructor，請想別的辦法!! \n接續前面章節，**並非** class 中沒有 `virtural` function，**就不需要** 考慮 non-virtural destructor 的問題。\n\n以例子來說，若有個 `SpecialString` 繼承 `std::string` (non-virtural destructor)，在 `new` 一個 `SpecialString` 之後指給 `std::string` pointer 之後就會遇到 Undefined Behavior 的問題! \n\n```cpp\nSpecialString *pss = new SpecialString(\"Impending Doom\");\nstd::string *ps;\n\nps = pss;\ndelete ps; // undefined behavior\n```\n\n同樣需要注意的如 `std::vector`, `std::list`, `tr1::unordered_map` ([[Item55 Familiarize yourself with Boost]]) 等。如果你想繼承一個 STL container，但它沒有 virtural destructor，請千萬不要嘗試繼承它! 這只會帶來災難。\n\n## 想要一個抽象類嗎\n想要一個抽象類，卻苦於沒有人選(function)「被 virtural」? 考慮 Destructor 吧: [[Pure Virtual Destructor]]\n\n\n","lastmodified":"2023-09-05T15:34:45.962894855Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/%E7%82%BA%E7%95%B0%E5%B8%B8%E5%AE%89%E5%85%A8-Exception-safe-%E8%80%8C%E5%8A%AA%E5%8A%9B%E6%98%AF%E5%80%BC%E5%BE%97%E7%9A%84":{"title":"為異常安全 (Exception-safe) 而努力是值得的","content":"\n## 異常安全的條件\n1. 不洩漏任何資源\n2. 不允許資料敗壞\n\n## Bad Case\n\n先看一個很糟糕的例子: \n```cpp\nclass PrettyMenu {\npublic:\n...\nvoid changeBackground(std::istream\u0026 imgSrc); // change background\n... // image\nprivate:\n Mutex mutex; // mutex for this object \nImage *bgImage; // current background image\nint imageChanges; // # of times image has been changed\n};\n\nvoid PrettyMenu::changeBackground(std::istream\u0026 imgSrc)\n{\nlock(\u0026mutex); // acquire mutex (as in Item 14)\ndelete bgImage; // get rid of old background\n++imageChanges; // update image change count\nbgImage = new Image(imgSrc); // install new background\nunlock(\u0026mutex); // release mutex\n}\n```\n\n1. 不洩漏任何資源: 第 17 行，一旦 `new` 過程中拋出 exception，第 18 行就不會執行，mutex 永遠不會 unlock。\n\t- 可透過 smart pointer 管理 heap-based 資源 (created by `new` ) 洩漏問題。\n\t- 使用 [[Mutex]] 的 `Lock` 確保離開 `changeBackground` 之後，mutex 就會自動解鎖。\n```cpp\nvoid PrettyMenu::changeBackground(std::istream\u0026 imgSrc)\n{\nLock ml(\u0026mutex); // from Item 14: acquire mutex and ensure its later release\ndelete bgImage;\n++imageChanges;\nbgImage = new Image(imgSrc);\n}\n```\n\n2. 不允許資料敗壞: 一旦 `new Image(imgSrc)` 的過程拋出 exception\n\t1. `bgImage` 會指向一個已經刪除的物件\n\t2. image 沒有創建成功，`imageChanges` 記數卻已經加上去。\n在解決資料敗壞問題之前，先導入 exception safe 的保證\n\n## Exception-Safe Functions\n必須提供三者之一\n1. 基本承諾: \n\t- 如果異常被拋出，程式的任何資料都處於有效的狀態 (只要有效即可，不保證是哪一個 status)。\n\t- 程式內任何的資料、狀態仍處於前後一致的狀態 -- 但現實中有些不可能，舉例上面的程式，當 `changeBackground` 拋出 exception 時，`PrettyMenu` 物件要使用哪一種背景? 預設背景? 原背景? Client 端需要 query 才知道。\n2. 強烈保證: 如果異常被拋出，呼叫者的程式狀態不改變。呼叫異常安全函式者會知道: 函式成功則完全成功，失敗則程式回到「呼叫函式」之前。\n\t- 這種保證比基本承諾好，Client 不用猜測「合法狀態」是哪一種狀態。\n3. 不拋擲 (nothrow) 保證: 承諾決不拋出異常，內建型別 (int, pointer) 身上的所有操作都屬於此類。\n\t- 要注意，Empty exception specification 不是 nothrow 函式，而是如果此函式拋出異常，將是嚴重的錯誤，會有意想不到的函式 (搜尋 C++ 文件 `set_unexpected`) 被喚起。\n\t- [[Modern C++ noexcept]]\n```cpp\nint doSomething() thorw(); // empty exception specification\n```\n\n\u003e [!todo]\n\u003e P132\n\n\n\n\n\n\n\n\n\n\n","lastmodified":"2023-09-05T15:34:45.962894855Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/%E7%95%B6%E6%89%80%E6%9C%89%E7%9A%84%E5%8F%83%E6%95%B8%E9%83%BD%E9%9C%80%E8%A6%81%E5%9E%8B%E5%88%A5%E8%BD%89%E6%8F%9B%E6%8E%A1%E7%94%A8-Non-member-Function":{"title":"當所有的參數都需要型別轉換，採用 Non-member Function","content":"\n讓 Class 支援隱式轉換通常不是好事 -- 但也有例外，最常見的就是數值型別。書中以有理數 `Rational` 為例，他設計了一個允許 Int 隱式轉換成 Rational 的 Constructor。\n```cpp\nclass Rational {\n    public:\n        Rational(int numerator=0, int denominator=1); \n        // 允許 int-to-Rational 的隱式轉換\n\n        int numerator(); // 分子\n        int denominator(); // 分母\n        const Rational operator*(const Rational rhs) const;\n}\n```\n\n當實作乘法運算時，若兩個數字都是有理數沒有問題。與 Int 相乘，Int 在前項卻出了問題。\n```cpp\nRational oneEight(1, 8);\nRational oneHalf(1, 2);\n\nRational res = oneEight*oneHalf; // OK\nres = res*oneEight; // OK\n\n# eq3\nres = oneHalf*2; // OK: oneHalf.operator*(2)\n# eq4\nres = 2*oneHalf; // Error: 2.operator*(oneHalf)\n```\n在 eq4 會錯誤是因為，乘法隱含的是\n1. 尋找 `2` 的 `operator*`，但這不存在 (2 沒有對應的 class)\n2. Compiler 嘗試尋找 Namespace 下或 global scrope 下， Signature 能相配合的 `operator*`，也就是嘗試 `res = operator*(2, oneHalf)` 能否成立。但這也找不到而\n3. 沒招了，引發 error。\n\n而 eq3 能成功是因為 Compiler 嘗試先呼叫 `oneHalf.operator*`，2 在傳進去時會因為 Rational 接受隱式轉換 (implicit type conversion)，而若 constructor 限定要 explicit type conversion，甚至會連 eq3 都不過! \n\n## 原因: 只有列於參數列 (Parameter List) 才能參與隱式轉換\n\n綜合 eq3, eq4 所述，只有當 `int` 列在 `Rational` 物件後面，也就是成為 `Rational::operator*`  的 Parameter List，才是隱式轉換的合格參與者。\n\n## 解法:以 Non-member Function 定義 operator*\n只要將 `operator*` 拆離 class `Rational`，讓 operator 的兩個參數 `lhs` \u0026 `rhs` 都有參與隱式轉換的資格，那麼 eq3 和 eq4 就都可以通過了!\n甚至，這個 non-member function 也不需要定義為 friend，因為光透過 Rational 的 Public interface 就可滿足一切需求了! \n[[operator overloading]]\n\n```cpp\n\nclass Rational {\n    ...\n};\n\nconst Rational operator*(const Rational\u0026 lhs, const Rational\u0026 rhs) {\n    return Rational(lhs.numerator()*rhs.numerator(), \\\n\t\t\t\t\tlhs.denominator()*rhs.denominator());\n}\n```\n\t\n","lastmodified":"2023-09-05T15:34:45.962894855Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/%E7%9B%A1%E5%8F%AF%E8%83%BD%E5%BB%B6%E5%BE%8C%E8%AE%8A%E6%95%B8%E5%AE%9A%E7%BE%A9%E5%BC%8F%E7%9A%84%E5%87%BA%E7%8F%BE%E6%99%82%E9%96%93":{"title":"盡可能延後變數定義式的出現時間","content":"\n\u003e 不只延後變數的定義式的出現，甚至該嘗試延後這份定義直到能夠給它初始值引數為止。\n\n- 盡可能延後參數的定義，直到它被使用的前一刻再定義。\n\t- 過早的定義它，有可能根本沒用到就先 return 了，無謂的承受了該變數的 construct \u0026 destruct 成本。\n- 「前一刻」甚至是指: 得到初始值了再一口氣「建構並指定初始值」\n\n```cpp\nstd::string worstCase(const std::string\u0026 password) {\n\tstd::string encrypted;  // 過早宣告: 承受建構成本\n\tif (password.length() \u003c 8 ) {\n\t\treturn;  // 沒用到卻承受解構成本\n\t}\n\treturn encrypted(password); \n}\n\n// worse: 先定義、再給值\nstd::string encrypted;  // default constructor\nencrypted = password;   // copy assignment.\n\n// better: 最好在定義時就給值，只要呼叫一次 constructor\nstd::string encrypted(password); \n\n\n```\n\n## 迴圈怎麼辦\n\n採取方法 A 或 B 取決於\n1. 知道賦值成本 \u003c (建構+解構)\n2. 程式碼 Performance-sensitive\n否則，通常選 B 比較好。\n\n- 方法A: 先宣告，在迴圈中賦值\n\t- 1 ctor + 1 dtor + n 個賦值\n\t- 優點: 當 Class 賦值成本低於建構+解構，A方法比較高效，特別是 n 很大時。\n\t- 缺點: Variable Name Scope 比較大\n\n- 方法B: 在迴圈中創建\n\t- n ctor + n dtor\n\t- 除非滿足上述的兩個條件，否則通常此方法比較好，變數名稱影響的範圍只在 For Loop 當中。\n\n```cpp\n// Method A\nWidget w;\nfor (int i=0; i \u003c n; ++i) {\n\tw = ...;\n}\n\n// Method B\nfor (int i=0; i \u003c n; ++i) {\n\tWidget w(...);\n}\n```","lastmodified":"2023-09-05T15:34:45.962894855Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/%E7%A2%BA%E4%BF%9D-Derived-Class-%E5%92%8C-Base-Class-%E4%B9%8B%E9%96%93%E5%BF%85%E7%84%B6%E4%BF%9D%E6%8C%81-Is-a-%E9%97%9C%E4%BF%82":{"title":"確保 Derived Class 和 Base Class 之間必然保持 Is-a 關係","content":"\n\"Is A\" 關係，代表是用於 Base Class 的每一件事，**必定**也是用在 Derived Class，因為每一個 Derived Class 都 \"Is A\" Base Class。\n\n物件導向上的關係可能跟真實世界的理解有所不同，\n例如: 企鵝是一種鳥，若 \n- Base Class 為 Bird、Bird 裡面有個 function `fly`。\n- Derived Class 為 Penguin，Penguin 繼承 Bird，但企鵝不會飛!! \n這就不是一個適當的繼承， `fly` 並不能適用在 Derived Class Penguin。\n\n又比如，Rectangle 與 Square，Square 繼承 Rectangle，Square 有長寬必定相等的強烈保證。但在以下 function 中，傳入 `Square` 物件時，Assert 一定會發生!\n```cpp\nvoid makeBigger(Rectangle\u0026 r) // function to increase r’s area\n{\n\tint oldHeight = r.height();\n\tr.setWidth(r.width() + 10); // add 10 to r’s width\n\tassert(r.height() == oldHeight); // assert that r’s\n}\n```\n\n這就代表，在物件導向的視角，Rectangle 的每一件事並不能完全套用在 Square 上，這個繼承關係是有問題的。\n\n查覺到不適合以 Is A 關係塑模，可以考慮 [[Has A]] 跟 [[Is Implemented in Terms of]]，這些將在 [[確定 Composition 塑造的是 'Has-A'關係 或 '根據某物實作'的關係]]、 [[審慎的使用 Private 繼承]]\n","lastmodified":"2023-09-05T15:34:45.962894855Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/%E7%A2%BA%E5%AE%9A-Composition-%E5%A1%91%E9%80%A0%E7%9A%84%E6%98%AF-Has-A%E9%97%9C%E4%BF%82-%E6%88%96-%E6%A0%B9%E6%93%9A%E6%9F%90%E7%89%A9%E5%AF%A6%E4%BD%9C%E7%9A%84%E9%97%9C%E4%BF%82":{"title":"確定 Composition 塑造的是 'Has-A'關係 或 '根據某物實作'的關係","content":"\n## Has A 關係\n\"Has-A\" 指的是擁有一個 應用域 (application domain) 的物件，像是 \n- Person 'has a' name.\n- Person 'has a' address\n- ...\n這沒什麼爭議。\n\n## 根據某物實作出的關係\n這是指 實作域 (implementation domain)，表示 is-implemented-in-terms-of 關係。像是\n- buffer\n- mutex\n- search tree\n\n這麼說還是很抽象，舉例: \nstd::set 是一個以平衡樹實作的資料結構，每一個元素需要耗費三個 pointer，它重視速度大於空間用量。若我們有一個「空間用量比速度更重要」的需求，則無法使用 std::set，有需求自己撰寫 Template。\n現在，我們經歷了這一串掙扎: \n\n1. 實作 set 有很多種方法，想採用 linked list 的作法。\n2. 想到了 std::list 就是這樣的資料結構，我該繼承它嗎?\n3. 一旦繼承就代表 IS-A 關係，適用於 std::list 的每件事，這個新的 set 都可以接受\n4. 但是 std::list 允許重複的元素出現在容器中，set 不允許，在插入新元素 (insert) 時會做處置。這違反了 IS-A 規則。\n5. 不適合使用繼承。\n\n### 以一個 Private member data 擁有 (has a) 一個 std::list container\n正確的做法是，讓 Set 物件是根據一個 std::list 物件實作出來。我們會以一個 private member data 去 own (has a) 一個 std::list 物件，藉此達到 reuse linked list 的需求。\n\n```c++\ntemplate\u003cclass T\u003e // the right way to use list for Set\nclass Set {\npublic:\n\tbool member(const T\u0026 item) const;\n\tvoid insert(const T\u0026 item);\n\tvoid remove(const T\u0026 item);\n\tstd::size_t size() const;\nprivate:\n\tstd::list\u003cT\u003e rep; // representation for Set data \n};\n\n// 取一個函式實作舉例\ntemplate\u003ctypename T\u003e\nstd::size_t Set\u003cT\u003e::size() const\n{\nreturn rep.size();\n}\n...\n```\n\n對於每個 member function 的實作，在 own 了一個 `std::list` container 之後，可以很輕易的呼叫 std::list API 達到我們的需求，達到 reuse 的目的。甚至相當適合把這些 function 寫成 inline function! \n\n不過在做 inline 之前，先檢視 [[了解 Inline 的裡裡外外]]。\n","lastmodified":"2023-09-05T15:34:45.962894855Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/%E7%B5%95%E4%B8%8D%E9%87%8D%E6%96%B0%E5%AE%9A%E7%BE%A9%E7%B9%BC%E6%89%BF%E4%BE%86%E7%9A%84-Non-virtual-Function":{"title":"絕不重新定義繼承來的 Non-virtual Function","content":"![[Item36.png]]\n試想圖中這個繼承關係，`D` 繼承 `B`。而下面這段 code 分別以 `B` pointer 和 `D` pointer 持有 `x` 物件後呼叫 `mf` 方法。你會預期，這兩者的結果會相同，因為他們指向同一個物件。\n```cpp\nD x; // x is an object of type D\n\nB *pB = \u0026x; // get pointer to x\npB-\u003emf(); // call mf through pointer\n\nD *pD = \u0026x; // get pointer to x\npD-\u003emf(); // call mf through pointer\n```\n\n事實卻是，當 `D` 繼承 `B` 後如果自行實作了 `mf`，在以上這段例子中，`x` 會因為被 `B*` 或 `D*` 持有，而有不同的表現!! 當 `D` 有如此實作時，相當於藏住了 `B::mf`。參見 [[繼承時的名稱遮掩行為]]\n```cpp\nclass D: public B {\npublic:\n\tvoid mf();\n...\n};\n```\n\n造成這個現象的原因，參見 [[靜態綁定 (statically bound) 與動態綁定 (dynamically bound)]]\n\n## 絕對遵守 Is-A 關係\n本條款其實是 [[確保 Derived Class 和 Base Class 之間必然保持 Is-a 關係]] 的延伸，在\n[[區分介面繼承(interface)和實作繼承(implement)]] 說到 non-virtual 代表不變性，綜合此二條規定檢視這個繼承關係\n1. 適用 Base Class 的每件事都適用於 Derived Class。\n2. 對於 Non-virtual function，Derived Class 應該繼承**介面與實作**\n\n一旦 `D::mf` 重新定義，就違反了 Is-A 關係，特異性凌駕了不變性。","lastmodified":"2023-09-05T15:34:45.962894855Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/%E7%B7%A8%E8%AD%AF%E4%BE%9D%E5%AD%98-%E5%AE%A3%E5%91%8A%E5%BC%8F%E5%AE%9A%E7%BE%A9%E5%BC%8F%E8%88%87%E5%AF%A6%E4%BD%9C%E7%B4%B0%E7%AF%80":{"title":"編譯依存-宣告式、定義式與實作細節","content":"\n分辨以下三個名詞\n- 宣告式: 僅僅宣告某個類別名稱(?)\n- 定義式: 定義物件的 member data、function，透過定義式可以得知物件的大小\n- 實踐細節: 演算法細節。\n\n```cpp\nclass Date; // 宣告式\nclass Person {\npublic:\n\tPerson(const std::string\u0026 name, const Date\u0026 birthday,\n\tconst Address\u0026 addr);\n\nprivate: // ptr to implementation;\n\tstd::tr1::shared_ptr\u003cPersonImpl\u003e pImpl; // see Item 13 for info on\n};\n```\n\nCompiler 在編譯期間需要知道物件的大小，如下例。Compiler 可以輕鬆知道 built in type `int`的大小，但 `Person` 呢? 這得向它的定義式詢問要配多少空間。因此，會需要 `include person.hpp` \n```cpp\n#include \u003cperson.hpp\u003e\n\nint main()\n{\n\tint x; // 定義一個 int object\n\tPerson p(params) // 定義一個 Person object\n}\n```\n\n### 能用 object reference/pointer 就不要 own 一個 object。\nReference \u0026 Pointer 都可以 forward declare，宣告一個 object 卻必須 include header file (取得物件的定義式)。\n\n### 以宣告式取代定義式\n\n宣告一個 Function。而它要用到某個 Class的時候，都不需要該 Class 的定義。即使 Pass by value 也是!!! \n\n```cpp\nclass Date; // forward declare\n\nDate today(); // declare a function which return Date object. OK!!\nvoid clearAppointments(Date d); // Pass by value. OK!!\n```\n\n#### 即使回傳一個 object 也不需要定義式?\n在上例中，`today()` 函式回傳一個 `Date` 物件，卻不需要 include Date 的 header file? 聽起來很奇怪，但原理也極簡單。\n\n一旦有人試圖呼叫 `today()`，`Date` 的定義式需要先被曝光: 呼叫者需要先創建一個 Date 物件來接住 `today()` 的回傳值! 這個 include 的責任交給呼叫者就好。\n\n試想，這份 header file 並非每個人都要用到 `today()` 函式，導入 `Date.hpp` 就會增加依賴性。但，要呼叫 `today()` 的人**必須**導入 `Date` 的定義式 (hpp)，所以 include 可以交給 Client 端就好! \n\n### 為宣告式與定義式提供不同的 header file\n程式庫的提供者應該把宣告式和定義式分開，讓客戶端導入要用到的 header file 即可。\n接續前面的例子，當 Client 端想宣告 `today` 時，應該 `include  \"datefwd.h\"`，而非手動作 forward declaration，這是 Provider 必須提供的。而 `datefwd.h` 這個命名方式，則是跟 STL 的 [`iosfwd`](https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/std/iosfwd) 相同。\n\n```cpp\n#include \"datefwd.h\"\n\nDate today(); // declare a function which return Date object. OK!!\nvoid clearAppointments(Date d); // Pass by value. OK!\n```\n\nSTL 所提供的 `iosfwd` 包含了來自 `sstream, iostream, fstream ...` 多個 header file 的 forward declaration，也就是說，他們的定義式實際散在多個 header file ，但  forward declaration 集中放在同一個 header file。\n\n\n\n\n\n\n","lastmodified":"2023-09-05T15:34:45.962894855Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/%E7%B9%BC%E6%89%BF%E6%99%82%E7%9A%84%E5%90%8D%E7%A8%B1%E9%81%AE%E6%8E%A9%E8%A1%8C%E7%82%BA":{"title":"繼承時的名稱遮掩行為","content":"\n當 Derived 和 Base Class 有相同名稱的 function 時，Derived 的 function 會直接**遮住** Base Class 的同名稱 function (讓 Compiler 不會去找 Base Class 的該同名 function)，即使 signature 不同、不是做 override，也會找不到該 Base Class Function。\n\n![[Itm33.png]]\n如圖中撰寫，其結果: \n```cpp\nDerived d;\nint x;\n...\nd.mf1(); // fine, calls Derived::mf1\nd.mf1(x); // error! Derived::mf1 hides Base::mf1\nd.mf2(); // fine, calls Base::mf2\nd.mf3(); // fine, calls Derived::mf3\nd.mf3(x); // error! Derived::mf3 hides Base::mf3\n```\n","lastmodified":"2023-09-05T15:34:45.962894855Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/%E8%97%89%E7%94%B1-Function-Pointer-%E5%92%8C-tr1-function-%E6%89%8B%E6%B3%95%E5%AF%A6%E7%8F%BE-Strategy-Pattern":{"title":"藉由 Function Pointer 手法實現 Strategy Pattern","content":"\nNVI 方法為 Public Virtual Function 提供了替代方案，但仍沒有脫離 virtual。\n新的做法是，把 Function 用 Function Pointer 傳入，這實際上是  [[Classic Strategy Pattern|Strategy Pattern]] 的一種實作。\n\n```cpp\nclass GameCharacter; // forward declaration\n// function for the default health calculation algorithm\nint defaultHealthCalc(const GameCharacter\u0026 gc);\nclass GameCharacter {\npublic:\n\ttypedef int (*HealthCalcFunc)(const GameCharacter\u0026);\n\n\texplicit GameCharacter(HealthCalcFunc hcf = defaultHealthCalc)\n\t: healthFunc(hcf) {}\n\t\n\tint healthValue() const { return healthFunc(*this); }\n\nprivate:\n\tHealthCalcFunc healthFunc;\n}\n```\n\n更進一步的，使用 `tr1::function`，使得任何像是 function 一般 callable 且 signature 符合的 callable 物件 (`std::tr1::function\u003cint (const GameCharacter\u0026)\u003e`)，都可以是被傳入的物件。\n[[C++11 std function]]\n\n```cpp\nclass GameCharacter; // as before\nint defaultHealthCalc(const GameCharacter\u0026 gc); // as before\nclass GameCharacter {\npublic:\n// HealthCalcFunc is any callable entity that can be called with\n// anything compatible with a GameCharacter and that returns anything\n// compatible with an int; see below for details\ntypedef std::tr1::function\u003cint (const GameCharacter\u0026)\u003e HealthCalcFunc;\nexplicit GameCharacter(HealthCalcFunc hcf = defaultHealthCalc)\n: healthFunc(hcf )\n{}\nint healthValue() const \n{ return healthFunc(*this); }\n...\nprivate:\nHealthCalcFunc healthFunc;\n}\n```\n\n## 優點\n- 可以在 RT 期間決定傳入的函式\n\n## 缺點\n當我們想計算的內容都可以用 Public Interface 取得相關資訊，沒有問題。但如果需要取得 non-public data (內部資訊)，就有疑慮了。\n- 讓 class 的某個**內部**機能依賴於外部的某個 [[non-member \u0026\u0026 non-friend function]] 是個爭議。\n- 解決作法是弱化 class 的封裝，宣告該 function 為 friend function 就是一種弱化的作法，或是提供一個 public getter。\n\n","lastmodified":"2023-09-05T15:34:45.962894855Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/%E8%97%89%E7%94%B1-Non-Virtual-Interface-%E6%89%8B%E6%B3%95%E5%AF%A6%E7%8F%BE-Template-Method-Pattern":{"title":"藉由 Non-Virtual Interface 手法實現 Template Method Pattern","content":"\u003e The Template Method Pattern via the Non-Virtual Interface Idiom\n\n這個方法是 Design Pattern [[Template Method]] 的表現形式，而跟 C++ Template 無關。\n\n## Non-Virtual Interface (NVI)\nNVI 主張 Virtual 應為 Private，如果有暴露的需求，則應該以一個 Public non-virtual function (as a *wrapper*) 呼叫 Private virtual function。\n\n## wrapper function\nWrapper 的優點可以把一些呼叫 virtual 前後需要處理的事情藏起來，確保這些事情必定會執行: \n例如\n- 在呼叫 virtual function 前: 為 Mutex 上鎖, Log entry, 驗證事前條件...\n- 在呼叫 virtual function 之後: 為 Mutex 解鎖, 驗證事後條件...\n\n如果把 Virtual 設成 Public (相當允許客戶端自行重新定義它)，這些事件將無處置放，也無法確保事前事後條件絕對會被執行 (Client 端實作時可能會忽略)。\n\n## 保留何時呼叫 virtual function 的權利\nNVI 手法把「如何實現機能 (重新定義函式)」的權利交給了客戶端，「何時呼叫函式 (when to call non-virtual function)」的權利留在手上。\n\n## NVI 允許 Protected\n某些時候，Derived Class 會需要呼叫 Base Class 的 function，當這個 function 正是前面所說 NVI 的主角 -- 是一個 virtual function 的時候，它必須得宣告成 protected，這在 NVI 中也是被允許的。\n\n某些時候，virtual function 必須是 Public (ex. 多型用途的 Base Class 解構式, [[不要為非多型用途的 Base Class 宣告 Virtual Function]]) 他們則不是用於 NVI 手法。\n","lastmodified":"2023-09-05T15:34:45.962894855Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/%E8%A7%A3%E6%A7%8B%E5%BC%8F%E8%88%87%E7%95%B0%E5%B8%B8":{"title":"解構式與異常","content":"\u003e 在 C++11 中，Destructor and `delete` 被自動宣告為  `noexcept`。\n\n\n\n[[Modern C++ noexcept]]\n\n## 情境: 當Destructor 必須執行某項會丟Exception 的程序\n舉例，我們有一個資料庫連線的 class `DBConnection`，這類資源管理的 Class 在 [[Chapter3]] 中會有更詳細的探討。\n```cpp\nclass DBConnection {\npublic:\n...\nstatic DBConnection create();   // function to return DBConnection objects; params omitted for simplicity\nvoid close(); \n// close connection; throw an exception if closing fails\n};  \n```\n\n\n### 直接 Catch Exception\n為了防止 client 沒有 close connection 就直接刪除物件，我們需要在 destructor 呼叫 `close`，然而這個 function 有丟出 exception 的風險。\n有兩種做法可以簡單的解決\n1. 使用 `std::abort` 提前中止程式，它可以搶在 Exception 傳出去之前，也就是 Undefined Behavior 傳出去之前，強迫程式結束。\n\t```cpp\nDBConn::~DBConn() {\n\ttry { db.close(); }\n\tcatch (...) {\n\t\t// make log entry that the call to close failed;\n\t\tstd::abort();\n\t}\n}\n\t```\n2. 吞下異常。一般來說，這是個壞主意，它抑制了錯誤被知道的機會。\n\t```cpp\nDBConn::~DBConn() {\n\ttry { db.close(); }\n\tcatch (...) {\n\t\t// make log entry that the call to close failed;\n\t}\n}\n\t```\n\n哪種方法好，端看情境如何取捨。不過此兩者做法都不是根本解決之道。\n\n## 解決方法: 讓 Cilent 自己接住 Exception\n更好的做法是重新設計 Interface，讓 client 端自己 `close`，對 Exception 做反應。並在 destructor 當中再設一道確保關閉的雙重保障 -- 如果客戶還是忘了關，再讓 destructor 動手吧! \n\n\n## 質疑\n- 轉移責任到 Client 身上的嫌疑? 並沒有，因為 destructor 中也是有一道 Check。\n- 違反[[讓介面易於被使用，不易誤用]]? \n\n如果某個操作有 raise exception 的風險，又必須處理該 exception，這個異常必須來自 destructor 之外的某個 function (此例: 來自 `close`)，而這有讓 client 端接手的必要性，將它轉移出 destructor 能避免 undefined behavior 的發生有更大的價值。\n","lastmodified":"2023-09-05T15:34:45.962894855Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/%E8%A8%AD%E8%A8%88%E6%96%B0-Class-%E7%9A%84%E6%BA%96%E5%89%87":{"title":"設計新 Class 的準則","content":"在設計 class 之前，思考以下問題\n- 記憶體如何產生跟銷毀? (參見第八章)\n- 物件初始化與賦值的差別? Constructor \u0026 Assignment\n\t-  [[Effective C++ Outline#條款4 確定物件在使用前已經初始化 |條款4 確定物件在使用前已經初始化]]\n- Pass by value 對它代表甚麼? Copy constructor\n- Member data 的合法值?\n\t- 在不管是 constructor, assignment, setter function 在設 data 時，都需要進行錯誤檢查。\n\t- 這意味著你需要考量函式拋出的意外。\n- 它需要配合某個繼承圖系(inheritance graph) 嗎?\n\t- 會受到父輩們的約束，特別是函式是 virtural or non-virtual [[區分介面繼承(interface)和實作繼承(implement)]]、[[Item36 Never redefine an inherited non-virtual function]]。\n\t- 如果允許其他類別繼承此 class，請將必要的函式宣告為 virtual，特別是 destructor。\n\t\t- [[Effective C++ Outline#條款7 為多型用途的基礎類別宣告 virtual 解構式|條款7 為多型用途的基礎類別宣告 virtual 解構式]]\n- 需要考量轉換嗎? 隱性轉換與顯性轉換?\n- 甚麼運算子與函式對此新類別式合理的?\n\t- [[Non-member \u0026\u0026 Non-friend Function 的封裝度優於 Member Function]]\n\t- [[當所有的參數都需要型別轉換，採用 Non-member Function]]\n\t- [[盡可能延後變數定義式的出現時間]]\n- 什麼標準宣告式是需要駁回的? 請用 `delete` 明確刪除它。\n- 哪些 member 需要暴露出來? (public/private/protected)\n- 什麼是它的未宣告介面(undeclared interface)?\n\t- 這我看不懂。\n- 這個新的 class 有多一般化? 若要定義的是 type family (一堆 type) ，是否該採用 class template?\n- ","lastmodified":"2023-09-05T15:34:45.962894855Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/%E8%AE%93%E4%BB%8B%E9%9D%A2%E6%98%93%E6%96%BC%E8%A2%AB%E4%BD%BF%E7%94%A8%E4%B8%8D%E6%98%93%E8%AA%A4%E7%94%A8":{"title":"讓介面易於被使用，不易誤用","content":"\n## 用 `struct` 包覆簡單的資料結構可以帶來可讀性\n\n考量下面的例子: \n\n```cpp\nclass Date {\npublic:\n\tDate(int month, int day, int year);\n}\nDate(3, 31, 1999); // 正確\nDate(30, 3, 1999); // 可能會誤打\nDate(3, 40, 1999); // 可能有無效值\n```\n\n如果我們改以 `struct`如下，你幾乎不會犯下寫錯格的錯，Compiler 會自動提醒! 甚至可以在 Struct 內簡單的做數值檢驗。\n\n```cpp\nstruct Month;\nstruct Day;\nstruct Year;\n\nclass Date {\npublic:\n\tDate(Month m, Day d, Year y);\n}\n\nDate(Month(3), Day(31), Year(1999)); // 正確\nDate(Day(3), Month(31), Year(1999)); // 型別錯誤\n```\n\n\n## 以函式取代物件\n\n像是月份這樣有一定的範圍，甚至可以直接列舉 12 月份，Client 端透過介面得到月份物件，幾乎沒有錯誤數值的問題!!\n\n類似用法可以參見 [[Static Object]] 當中的 non-local static object 初始化問題。\n\n```cpp\nclass Month {\npublic:\n\tstatic Month Jan() {return Month(1)};\n\tstatic Month Feb() {return Month(2)};\n\t...\nprivate:\n\texplicit Month(int m);\n}\nDate(Month::Jan(), Day(30), Year(1999));\n```\n\n## 和內建型別的行為一致，不要搞怪\n\n當有和 STL lib 相似的屬性時，盡量用一樣的形式。\n\n## 任何介面如果有要求客戶「記得做」某件事，就有「不正確使用」的傾向，因為客戶可能會忘記。\n\n例如: 比起回傳一個 raw pointer 並期許客戶端記得刪除記憶體，回傳 smart pointer 能解決問題。\n\n防範客戶端可能發生的錯誤是有代價的，像是 Shared pointer，它比原本的體積更大、且更慢。但在許多程式中這些成本的影響並不顯著，防範客戶端愚蠢行為帶來的益處卻極為顯著。\n\n\n## Return Const Value\n避免回傳值被修改，如此例中，類別 `Rational` (有理數) 的乘積符號禁止其回傳值被賦予值 (assignment)。\n\n```cpp\nclass Rational { ... }; \nconst Rational operator*(const Rational\u0026 lhs, const Rational\u0026 rhs);\n```\n\n聽起來有點怪，但它可以預防 client 端寫出這種 code: \n```cpp\nRational a, b, c;\n(a*b) = c;\n\nif (a*b = c) { ... };\n```\n\n我想，作者的舉這個例子有 Defensive programming 的概念在。如若這些變數是內建型別 (ex. int)，這種寫法直接就會被擋掉。但像此例，它們是 User-defined 的型別，對於設計 class 的 designer 而言，最好將這種無意義的行為擋掉。","lastmodified":"2023-09-05T15:34:45.962894855Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/%E9%81%8B%E7%94%A8%E6%88%90%E5%93%A1%E5%87%BD%E5%BC%8F%E6%A8%A1%E6%9D%BF%E6%8E%A5%E5%8F%97%E6%89%80%E6%9C%89%E7%9B%B8%E5%AE%B9%E7%9A%84%E5%9E%8B%E5%88%A5":{"title":"運用成員函式模板，接受所有相容的型別","content":"\n參考以下繼承體系的範例: 在原生的 Pointer 系統當中，在合理的繼承關係之下，這些不同類別在 Raw Pointer 很容易互相轉換。\n\n```cpp\nclass Top { ... };\nclass Middle: public Top { ... };\nclass Bottom: public Middle { ... };\nTop *pt1 = new Middle; // convert Middle* ⇒ Top*\nTop *pt2 = new Bottom; // convert Bottom* ⇒ Top*\nconst Top *pct2 = pt1; // convert Top* ⇒ const Top*\n```\n\n然而思考以下範例: 我們使用 template 完成一個 `SmartPtr`，它能像 RAW pointer 一般互相轉換嗎? 沒辦法，以下這段程式不會通過編譯。\n\n```cpp\ntemplate\u003ctypename T\u003e\nclass SmartPtr {\npublic: // smart pointers are typically\nexplicit SmartPtr(T *realPtr); // initialized by built-in pointers \n...\n};\n// convert SmartPtr\u003cMiddle\u003e ⇒ SmartPtr\u003cTop\u003e\nSmartPtr\u003cTop\u003e pt1 = SmartPtr\u003cMiddle\u003e(new Middle); \n// convert SmartPtr\u003cBottom\u003e ⇒ SmartPtr\u003cTop\u003e\nSmartPtr\u003cTop\u003e pt2 = SmartPtr\u003cBottom\u003e(new Bottom);\n// convert SmartPtr\u003cTop\u003e ⇒ SmartPtr\u003cconst Top\u003e\nSmartPtr\u003cconst Top\u003e pct2 = pt1; \n```\n\n即使 Middle 繼承自 Top，透過**模板具現化的類別** `SmartPtr\u003cTop\u003e` 跟 `SmartPtr\u003cMiddle\u003e` 之間，卻**沒有任何關係**.... 他們的關係大概跟 `vector\u003cdouble\u003e` 和 `Widget` 這般疏遠 -- 牛馬不相干! \n若希望這個客製化的 `SmartPtr` 可以有如 Raw Pointer 一般能夠輕易地轉換，需要費點功夫。\n\n要讓上面的範例通過編譯，必須要有對應的、合法的 Copy Constructor。難道要如此逐一列舉....?\n\n\u003e[!todo]\n\u003e確定是 ctor?? copy assignment??\n\n```cpp\ntemplate\u003c\u003e\nclass SmartPtr\u003cTop\u003e {\npublic:\n    explicit SmartPtr(Top *realPtr) { heldPtr = realPtr; }\n    Top* get() const { return heldPtr; }\n\n\tSmartPtr(const SmartPtr\u003cMiddle\u003e\u0026 other) { heldPtr = other.get(); }\n\tSmartPtr(const SmartPtr\u003cBottom\u003e\u0026 other) { heldPtr = other.get(); }\n    void print() { heldPtr-\u003eprint(); }\nprivate:\n    Top *heldPtr;\n};\n\n```\n但我們不可能把所有的組合列舉出來，這樣一旦繼承體系中有新增/更動類別，就需要再重寫。\n\n[[Template and Generic Programming]]\n\n\n","lastmodified":"2023-09-05T15:34:45.962894855Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/%E9%81%BF%E5%85%8D%E5%82%B3%E5%9B%9E-Handles-%E6%8C%87%E5%90%91%E7%89%A9%E4%BB%B6%E7%9A%84-Private-Protected-Member-Data":{"title":"避免傳回 Handles 指向物件的 Private \u0026 Protected Member Data","content":"\n\u003e 消滅 handles 的暴露可能\n\n\n## 大忌: 回傳一個 Non-Const handles \n在 [[打破 Constness 限制#Physical Constness]] 當中，我們探討過 Physical (bitwise) Constness 的問題。\n讓 Getter 回傳一個 non-const reference 指向 member data，會出現讓 private data 暴露在外 (等同於 public) 的詭異現象。\n此問題不限於 ref，pointer、iterator 這些 handles (用以取得某個物件)，都有相同的風險。\n\n## 回傳一個 Const Handles 就沒問題了嗎?\n\n```cpp\nstruct RecData {\n\tPoint ulhc;\n\tPoint lrhc;\n}\n\nclass Rectangle {\npublic:\n\tconst Point\u0026 upperLeft() const {return pData-\u003eulhc;}\n}\n\nclass GUIObj;\nconst Rectangle bbox (cosnt GUIObj\u0026 obj);\n\nGUIObj* pgo;\nconst Point* pUpperLeft = \u0026(bbox(*pgo).upperLeft()); // dangling\n```\n\n此例的第 15 行，\n1. 相當於先創建了 `tmp = bbox(*pgo*)`\n2. 對 `tmp.upperLeft()`取得一個 `const Point\u0026` 內部資料 ``\n3. 對此內部資料取 address，傳給 `pUpperLeft`\n4. 15 行執行完畢，`pUpperLeft` 直接變成 dangling pointer\n\n最大的問題是，**handles 比其所屬的物件更長壽**!! 最簡單的就是消滅 handles 的暴露可能。\n\n但並不意味不能回傳 handles，有時是必須的，像是 `operator[]` 就必須回傳 reference 指向 container 內部元素。\n\n\n\n\n\n[[Effective C++ Outline#條款3 盡可能使用 const]]\n","lastmodified":"2023-09-05T15:34:45.962894855Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/%E9%97%9C%E9%8D%B5%E5%AD%97-typename-%E5%9C%A8-Template-%E4%B8%AD%E7%9A%84%E6%84%8F%E6%B6%B5":{"title":"關鍵字 typename 在 Template 中的意涵","content":"試想，下例中使用 `class` 跟 `typname` 之間有甚麼區別?\n```c++\ntemplate\u003cclass T\u003e class Widget; // uses “class”\ntemplate\u003ctypename T\u003e class Widget; // uses “typename”\n```\n答案是意義完全相同，在宣告 template 參數時，這兩個 keywords 並沒有差別，但 `class` 與 `typename` 並不是總是等價。\n\n\n## 指涉 (refer to)\n\n- 從屬名稱 (dependent names): 在 template 當中的某個**名稱**相依於 template 參數。\n- 巢狀從屬名稱 (nested dependent names): 當從屬名稱在 template 內並且是 nested 的。(ex. `T::member_data`)\n- 巢狀從屬型別名稱 (nested dependent type names): 是巢狀從屬名稱，且這個名稱代表一個**型別** (Type)。(ex. `T::`)\n- 非從屬名稱 (non-dependent names): 類別與 template 參數沒有相依性。\n\n## 區分「巢狀從屬型別名稱」與「巢狀從屬名稱」\n巢狀從屬型別名稱會造成 parsing 困難，以下例來說，在不知道 `C` 是什麼之前，要如何解讀 `C::const_iterator * x;`?\n1. `C::const_iterator` 可能是一個 member data? 而 `x` 可能是一個 global int variable !\n2. `C` 是一個 STL container，則 `const_iterator` 是一個 nested type name.\n隨著解讀的方式不同，`*` 符號也有不同的意思。\n1. 表示乘法\n2. 表示 Type Pointer\n\n這就是 Compiler 遇到的的困境。\n\n```c++\ntemplate\u003ctypename C\u003e\nvoid print2nd(const C\u0026 container)\n{ \n\tC::const_iterator * x;\n\tC::const_iterator y;\n}\n```\n\n## Typename 必須做為 Nested Dependent Type Name 的前導詞\n在上述的困境 (nested dependent name OR nested dependent *type* name ) 裡，Compiler 預設行為是 **假設 C 並非一個型別**，除非以 `typename` 明確告訴它這是型別。\n按照這個規則再看一次上例，由於沒有 typename 明確指涉 C::const_iterator 是 type name，compiler 認為這代表一個 member data，那 `y` 是什麼? 以空白相隔? 這違反語法，會直接引發錯誤。\n\n作法如下，直接在想要指涉的 nested dependent type name 前面加上關鍵字 `typename` 即可，在 signature 或是直接寫在 function body 內都可以使用這個 keyword。甚至與 `typedef` 結合也沒問題，[[typedef and using]]\n\n```c++\ntemplate\u003ctypename C\u003e\nvoid f(const C\u0026 container, typename C::const_iterator* x);\n\n\ntemplate\u003ctypename C\u003e\nvoid print2nd(const C\u0026 container)\n{ \n\ttypename C::const_iterator y = container.begin();\n\ttypedef typename C::const_iterator citor;\n}\n```\n\n`typename` 除了用在 template 參數，就只允許被使用於**指涉 nested dependent type name**，非 nested 的不能加。\n```c++\ntemplate\u003ctypename C\u003e // OK, 等價於 `class`\nvoid f( const C\u0026 container, // non-nested name 不能以 typename 指涉\n\t\ttypename C::iterator iter); // nested name 必須以 typename 明確指涉，否則編譯會有問題\n```\n\n## Typename 不得用在 Base Classes List 與 Member Initializer List \n\n- Base Class List: 繼承時候冒號後面那一串，不能、也不需要用 `typename` 標示 (能放在這裡就已經是 type 了)\n- Member Initializer List 也不需要\n除了上述的兩個例外，其他地方照樣能用 `typedef`\n\n```c++\ntemplate\u003ctypename T\u003e\nclass Derived: public Base\u003cT\u003e::Nested { // base class list: typename not allowed\npublic:\nexplicit Derived(int x): \n\tBase\u003cT\u003e::Nested(x)  // base class identifier: \n\t\t\t\t\t\t// in member initializer list typename not allowed\n{\n\ttypename Base\u003cT\u003e::Nested temp;  // use of nested dependent type\n\t\t\t\t\t\t\t\t\t// name not in a base class list or\n} // as a base class identifier in a mem. init. list: typename required\n};\n```\n\n\u003e [!todo]\n\u003e 實驗 mem init list 為何不用?\n\n\n\n","lastmodified":"2023-09-05T15:34:45.966894908Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/%E9%9C%80%E8%A6%81%E5%9E%8B%E5%88%A5%E8%BD%89%E6%8F%9B%E6%99%82%E8%AB%8B%E7%82%BA%E6%A8%A1%E6%9D%BF%E5%AE%9A%E7%BE%A9%E9%9D%9E%E6%88%90%E5%93%A1%E5%87%BD%E5%BC%8F":{"title":"需要型別轉換時請為模板定義非成員函式","content":"文章 [[當所有的參數都需要型別轉換，採用 Non-member Function]] 中提到，能被隱式轉換的只有位於參數列的對象，因此針對 `operator*` 採用了 Non-member function。\n\n現在，將這個 `operator*` 改成 Template function。\n\n```cpp\ntemplate\u003ctypename T\u003e\nclass Rational {\npublic:\n\tRational(const T\u0026 numerator = 0, // see Item 20 for why params\n\tconst T\u0026 denominator = 1); // are now passed by reference\n\tconst T numerator() const; // see Item 28 for why return\n\tconst T denominator() const; // values are still passed by value,\n};\n\ntemplate\u003ctypename T\u003e\nconst Rational\u003cT\u003e operator*(const Rational\u003cT\u003e\u0026 lhs, const Rational\u003cT\u003e\u0026 rhs) \n{  \n\t\n}\n```","lastmodified":"2023-09-05T15:34:45.966894908Z","tags":["empty"]},"/notes/Project/Effective-C++-Series/%E9%9D%9C%E6%85%8B%E7%B6%81%E5%AE%9A-statically-bound-%E8%88%87%E5%8B%95%E6%85%8B%E7%B6%81%E5%AE%9A-dynamically-bound":{"title":"靜態綁定 (statically bound) 與動態綁定 (dynamically bound)","content":"## 靜態綁定 (statically bound, early binding) \n- Non-virtual function\n- Default Parameter\nNon-virtual function 是 statically bound，也就是說，由 Base Class Pointer 喚起的物件在呼叫 non-virtual function 時，就只會呼叫 Base Class 的版本，即使 Base Class Pointer 指向的物件是 Derived Class Instance 亦然。\n這會形成 [[絕不重新定義繼承來的 Non-virtual Function]] 當中敘述的，由 Base Class Pointer 和 Derived Class Pointer 指向同一個物件，卻導致不同的行為結果這種，非預期中的奇怪狀態。不只是 Pointer 有此問題，Reference 也相同。\n\n## 動態綁定 (dynamically bound, late binding)\n- virtual function\nvirtual function 走的卻是動態綁定 (dynamically bound)，它不受此困擾，不管由 `B*` 或 `D*` 指向物件 `x` (`D` 的 instance)，都會喚起 `D::func`。\n\n## 物件的動態型別與靜態型別\n\n物件分成動態與靜態型別\n- 靜態型別 (static type): 宣告時的型別\n- 動態型別 (dynamic type): 執行期間所指的物件的型別\n![[Item37.png]]\n\n```cpp\nShape *ps; // static type = Shape*\nShape *pc = new Circle; // static type = Shape*\nShape *pr = new Rectangle; // static type = Shape*\n\nps = pc; // ps’s dynamic type is now Circle*\nps = pr; // ps’s dynamic type is now Rectangle*\n```\n\nVirtual function 透過動態綁定而來，因此呼叫 virtual function 時是叫到哪一個 function，是看當下動態型別。\n```cpp\npc-\u003edraw(Shape::Red); // calls Circle::draw(Shape::Red)\npr-\u003edraw(Shape::Red); // calls Rectangle::draw(Shape::Red)\n```\n然而，參數是靜態綁定的，假設 `Shape::draw` 的預設參數為 `Red`，`Rectangle` 預設參數為 `Green`，而使用 Shape pointer `pr` 不給輸入參數的呼叫 `draw` 時，卻會呼叫 `Rectangle::draw` 但傳入 `Shape::draw` 的預設參數! \n\n```cpp\n// a class for geometric shapes\nclass Shape {\npublic:\n\tenum ShapeColor { Red, Green, Blue };\n\t// all shapes must offer a function to draw themselves\n\tvirtual void draw(ShapeColor color = Red) const = 0;\n};\n\nclass Rectangle: public Shape {\npublic:\n\t// notice the different default parameter value — bad!\n\tvirtual void draw(ShapeColor color = Green) const;\n};\n\nclass Circle: public Shape {\npublic:\n\tvirtual void draw(ShapeColor color) const;\n};\n\npr-\u003edraw(); // calls Rectangle::draw(Shape::Red)!\n```\n\n預設參數由靜態綁定，是 C++ 為了執行效率的考量，在編譯時就已經決定好。\n## 以 NVI 手法解決預設參數是靜態綁定帶來的問題\n透過 [[藉由 Non-Virtual Interface 手法實現 Template Method Pattern|NVI]] 手法: 以一個 public non-virtual function 呼叫 private virtual function，是給予 virtual funciton 預設參數的好方法。\n\n1. 宣告一個 public non-virtual function，給予預設的輸入參數。基於繼承的 Is-A 關係，這個 function 不會被 override。\n2. 定義一個 pure virtual function，讓 Derived Class 繼承介面，自行實作。\n3. 在 public non-virtual function 當中呼叫該 pure virtual function，並把預設的參數傳入。\n\n如此一來，將不會有 Derived Class 擅自改寫預設參數的問題。\n\n","lastmodified":"2023-09-05T15:34:45.966894908Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/80-20-Rule":{"title":"80-20 Rule","content":"## Effective C++ 的 80/20 Rule\n程式往往把 80% 的時間花費在 20% 的程式碼上，你應該針對這 20% 的程式碼做優化，才能有效增進程式的效率。\n\n\n## 網路資源\n「80/20法則」又被稱為「帕雷托法則（Pareto principle）」，維基百科上對這個條目的解釋是：「在眾多現象中，80％的結果取決於20％的原因」\n\n\u003e 80％的收穫源自於20％的努力，其餘20％的結果卻必須付出80％的力氣才能獲得。\n\n善用這種因與果之間不平衡的自然現象，就可以發揮以少博多的槓桿效應。  \n  \n在設計上所面臨的許多限制條件，彼此之間往往是相衝突的。好比，我一再提到的彈性和複雜度的取捨──想增加彈性，就得付出提高複雜度做為代價，到底我們需要多少彈性？又得付出多少複雜度做為代價，才能換取到這些彈性呢？我們在購買各種商品的時候，常常會談到C/P（Cost/Performance）比的概念，事實上，設計上的取捨也可以套用相同的觀念。究竟我們以多少的A去換取多少的B是最划算的呢？而80/20法則就是在告訴你，要適當運用、操作20與80這種不平衡的因果關係，而且就因為這種情況，使得槓桿效應得以發揮作用。  \n  \n就好比，在許多系統的開發中，付出20％的複雜度，多半可以換取到80％的彈性，但想要得到100％的彈性，又得付出其餘的80％的複雜度。對我們來說，用20％的複雜度去換80％的彈性，是C/P比最高的。\n\n摘錄自: https://www.ithome.com.tw/article/47319","lastmodified":"2023-09-05T15:34:45.914894221Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/Array-As-an-Argument":{"title":"Array As an Argument","content":"\u003e- 當 Template 定義成 Pass by value 形式時，傳入的 array name 會轉換成 point to array (the first item)。\n\u003e - 當 Template 定義成 Pass by ref 形式時，傳入的 array name 是 **真的傳入整個 Object**。\n\n在進入正文之前須釐清一個觀念，array type 和 pointer type 是不同的，儘管有時候他們「看起來」可以互換。\n```cpp\nconst char name [] = \"AAA\";   // Type of name is: const char[13]\nconst char* ptrToName = name; // array decays to pointer\n```\n\n`const char[13]` 和 `const char*` 是不同的!! 但是由於有 array-to-pointer decay(退化) rule的規則在，因此上面範例中的 code 是可 compiled 的。\n\n```cpp\ntemplate \u003ctypename T\u003e\nvoid f(T param);\n```\n\n在進入 template deduction 前，先看 array 作為 function parameter 宣告時的兩種形式，這兩種宣告在執行上是等價的。\n```cpp\nvoid myFunc(int param[]); // Is treated as a pointer declaration\nvoid myFunc(int* param);  // Like this.\n```\n\nArray Parameter 和 Pointer Parameter 之間的等價性源自於 C 語言，並且在 C++ 中保留，這使人誤解 Array Type 和 Pointer Type 是相同的。\n\n根據在 Function Parameter 當中，Array Parameter 被當作 Pointer Parameter 對待，當 Array 被傳入 Template 時會被推斷成 Pointer Type。\n```cpp\nf(name); // T: const char*\n```\n\n但是!! 雖然在 Function Declaration 中，以 Array Parameter 的形式宣告會被以 Pointer 的方式對待，而非以整個 Array 的形式對待，卻可以宣告 **Array Reference** ，就可以傳整個 array 進去。\n\n```cpp\ntemplate \u003ctypename T\u003e\nvoid f(T\u0026 param);\n\nf(name); // pass array to f\n\t\t // T is const char[13]\n\t\t // ParamType is const char(\u0026)[13]\n```\n\n有趣的是，不只 `T` 可以被推斷，甚至連 number of elements in array `N` 也可以作為推斷的項目之一。\n```cpp\ntemplate \u003ctypename T, std::size_t N\u003e\nconstexpr std::size_t arraySize(T (\u0026)[N]) no except\n{\n\treturn N;\n}\n```\n- About `constexpr`: [[Item15 constexpr]]\n- About `noexcept`: [[Modern C++ noexcept]]","lastmodified":"2023-09-05T15:34:45.914894221Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/C++11-std-function":{"title":"C++11 std function","content":"","lastmodified":"2023-09-05T15:34:45.914894221Z","tags":["empty","cpp11"]},"/notes/Project/Effective-C++-Series/Classic-Strategy-Pattern":{"title":"Classic Strategy Pattern","content":"\n![[Item35_Classic_Strategy_Pattern.png]]\n","lastmodified":"2023-09-05T15:34:45.914894221Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/Const-in-C++":{"title":"Const in C++","content":"\n#### Const Iterator\n同理上述，宣告一個 iterator 為 `const` 表示這個 iterator 不能改變指向的對象，但是指向的對象之內容本身可以變。 \n```cpp\nconst std::vector\u003cint\u003e::iterator iter = vec.bgein();\n```\n如果想要指向一個不可被改變內容的物件，需要使用 `const_iterator`\n```cpp\nstd::vector\u003cint\u003e::const_iterator citer = vec.bgein();\n```\n\n#### Return Const Value\n[[讓介面易於被使用，不易誤用#Return Const Value]]\n\n#### Const member function\n[[Const member function]]\n\n#### Const Argument\n在真實的程式設計中，比較多用於 function argument 是 const pointer / const referecne。\n如下例: `print` function 定義了一個 const reference 的 argument，當它在調用 operator `[]` 的時候，就會用到上面的 API。且定義 const return value 可以避免錯誤的寫入值，達成 const object 的目的。\n```cpp\nvoid print(const TextBlock\u0026 ctb) // in this function, ctb is const \n{ \n\tstd::cout \u003c\u003c ctb[0]; // calls const TextBlock::operator[] \n\tctb[1] = 'x';        // raise error!!!\n}\n```\n\n#### 打破 Constness 限制\n前面說的是對於 Client 端，我們須保持資料的不可變動性。\n\n然而在類別內部的設計中，基於維護性、或某些理念，我們希望它不要那麼死板，比起 Compiler 所堅持的 Constness，或許邏輯上的 Constness 更加重要。接下來，將說明 Compiler 認知 Constness 為何 ，與如何「部分的」打破 Const 限制。\n[[打破 Constness 限制]]\n","lastmodified":"2023-09-05T15:34:45.914894221Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/Const-member-function":{"title":"Const member function","content":"\n\u003e The purpose of const on member functions is to identify which member functions may be invoked on const object.\n\n使 Interface 意圖更加清楚，有兩個重要的優點\n1. 可知道哪個 function 會更動到物件\n2. 改善 C++ 程式效率與 \"pass by reference to const\" 息息相關，使 function 可操作 Const Object 。\n\n直接看例子: 我們定義了如下的 Interface。\n\n```cpp\nclass TextBlock\n{\npublic:\n\t// operator[] for const objects\n\tconst char\u0026 operator[](std::size_t position) const\n\t{ return text[position]; }\n\t\n\t// operator[] for non-const objects\n\tchar\u0026 operator[](std::size_t position) \n\t{ return text[position]; }\nprivate:\n\tstd::string text;\n};\n```\n\n在 Client 端，`const TextBlock` 與 `TextBlock` 物件會 call 到的  `TextBlock::operator[]` **是不同的**!! 有宣告 Interface 的第一條 (const function)，才有辦法操作 `const TextBlock` 的物件。\n```cpp\nconst TextBlock ctb(\"World\");\nstd::cout \u003c\u003c ctb[0]; // calls const TextBlock::operator[]\n\nTextBlock tb(\"Hello\");\nstd::cout \u003c\u003c tb[0]; // calls non-const TextBlock::operator[]\n```\n\n## Experiment\n實驗以下這份 code，\n1. 當 const 與 non-const function 都寫時\n```cpp\ncall non-const func A\ncall const func B\n```\n2. 當只寫 const 時\n```cpp\ncall const func A\ncall const func B\n```\n3. 當只寫 non-const 時 (宣告 const object, 但不宣告 `const operator[]` )，Compile 的時候就會出問題 \n```cpp\nItem3.cpp:32:20: error: passing ‘const TextBlock’ as ‘this’ argument discards qualifiers [-fpermissive]\n   32 |     std::cout\u003c\u003ct2[0] \u003c\u003cstd::endl;\n      |                    ^\nItem3.cpp:17:15: note:   in call to ‘char\u0026 TextBlock::operator[](std::size_t)’\n   17 |         char\u0026 operator[](std::size_t position)\n      |               ^~~~~~~~\n```\n\n程式本體:\n```cpp\n#include \u003cstring\u003e\n#include \u003ciostream\u003e\n// g++ -o main Item3.cpp\nclass TextBlock\n{\npublic:\n    TextBlock(std::string text):m_text(text) { }\n\t// operator[] for const objects\n\tconst char\u0026 operator[](std::size_t position) const\n\t{ \n        std::cout\u003c\u003c\"call const func \";\n        return m_text[position]; \n    }\n\t\n\t// operator[] for non-const objects\n\tchar\u0026 operator[](std::size_t position) \n\t{ \n        std::cout\u003c\u003c\"call non-const func \";\n        return m_text[position]; \n    }\n\nprivate:\n\tstd::string m_text;\n};\n\nint main() {\n    TextBlock t1 = TextBlock(\"AAAA\");\n    const TextBlock t2 = TextBlock(\"BBB\");\n    std::cout\u003c\u003ct1[0] \u003c\u003c std::endl; \n    std::cout\u003c\u003ct2[0] \u003c\u003cstd::endl;\n}\n```\n","lastmodified":"2023-09-05T15:34:45.914894221Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/Copying-Function":{"title":"Copying Function","content":"\n\u003e Effective C++ 中，Copying Function 指的是 Copy construcot \u0026 Copy Assignment\n\n1. 當 Programmer 自己定義 Copying function 時，Compiler 不會警告你出錯!\n2. 在繼承的架構中\n\t1. 不只屬於 Child Class 的 member data 要全部 copy\n\t2. 還要記得 call Parent Class 的 copying function。\n\n    ```cpp\n    // Copy Construcotr \n    PriorityCustomer::PriorityCustomer(const PriorityCustomer\u0026 rhs)\n    : Customer(rhs), // invoke base class copy ctor\n    priority(rhs.priority)\n    {\n\t    logCall(\"PriorityCustomer copy constructor\");\n    }\n   \n    // Copy Assignment\n    PriorityCustomer\u0026\n    PriorityCustomer::operator=(const PriorityCustomer\u0026 rhs)\n    {\n        logCall(\"PriorityCustomer copy assignment operator\");\n        Customer::operator=(rhs); // assign base class parts\n        priority = rhs.priority;\n        return *this;\n    }\n\t\n\t ```\n\n3. Copy Constructor 與 Copy Assignment 不應該 Call 彼此，如果有 Reusable Code，應該另外抽一個 private function 去共用。","lastmodified":"2023-09-05T15:34:45.914894221Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/Default-Generated-Functions":{"title":"Default Generated Functions","content":"\n```cpp\nclass Empty; // you declare, but implement nothing. \n\n// Compiler silently create.\nclass Empty {\npublic:\n\n    Empty() { ... } // default constructor\n    Empty(const Empty\u0026 rhs) { ... } // copy constructor\n    ~Empty() { ... } // destructor — see below for whether it's virtual\n    Empty\u0026 operator=(const Empty\u0026 rhs) { ... } // copy assignment operator\n}\n\nEmpty e1;      // default constructor\n\t\t\t   // destructor\nEmpty e2(e1);  // copy constructor\ne2 = e1;       // copy assignment\n```\n\n\n- Default constructor (without parameter) \u0026 destructor\n\t- 給編譯器放一些喚起 base class, non-static member data constructor \u0026 destructor 的地方。\n\t- Compiler 生成的 destructor 是一個 non-virtural\n\t  [[為多型用途的基礎類別宣告 virtual 解構式]]\n\t- 只要有宣告 Constructor，編譯器就不會幫我們多掛 default constructor 上去。\n- Copy Constructor \u0026 Copy Assignment: 將 source 物件的每一個 non-static member data copy 過去。[[Copying Function]]\n\n## Default Copy Assignment\n儘管 Copy Assignment `operator=` 也可以自動生成，卻是有條件的自動生成，只有當自動生成的代碼合法時才會生成。\n\n但 default copy assignment 常很有機會變得幾乎無用武之地。\n1. 當 User-defined Class 有 member data 是 Reference 或 `const`，自動生成的 code 會不合法。\n2. 當 base class 把 copy assignment 宣告成 private，compiler 無法喚起 parent 的 private function，直接裝死。\n\n在 C++ 當中，一旦 Reference 被宣告，是不允許改指向不同物件的，而 Compiler 更不會自動去修改 \"被 Reference 物件\" 的內容。這種情況，Compiler 會直接拒絕生成 Copy assignment。\n如果想讓一個有 reference member data 的 class 有 Copy assignment，需要自行實作。相似的，更改 `const` 成員是不合法的，需自行實作。","lastmodified":"2023-09-05T15:34:45.914894221Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/Deleted-Function":{"title":"Deleted Function","content":"\n\n```cpp\nclass A{    \npublic:\n  A(int x) : m(x) {}\n  A\u0026 operator = (const A \u0026) = delete;  // Declare the copy assignment operator\n                                       // as a deleted function.\n  A(const A\u0026) = delete;                // Declare the copy constructor\n                                       // as a deleted function.\n\nprivate:\n  int m;\n};\n\nint main(){\n  A a1(1), a2(2), a3(3);\n  a1 = a2;     // Error, the usage of the copy assignment operator is disabled.\n  a3 = A(a2);  // Error, the usage of the copy constructor is disabled.\n}\n```\n\n\n## 舊的做法\n以 C++11 為分水嶺，C++98 只能透過宣告 private 藏住不要 Compiler 生成的 function。\n確實 client code 會無法呼叫。但這並不絕對安全，因為 member function 跟 frient function 還是可以呼叫 private function。更安全的做法是，宣告 private 後故意不實作。\n","lastmodified":"2023-09-05T15:34:45.914894221Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/EBO-Empty-Base-Optimization":{"title":"EBO (Empty Base Optimization)","content":"空白基本類別最佳化\neffective c++ 191","lastmodified":"2023-09-05T15:34:45.914894221Z","tags":["empty"]},"/notes/Project/Effective-C++-Series/Effective-C++-Outline":{"title":"Effective C++ Outline","content":"## Chapter 1\n\n### 條款1 C++ 是一個語言聯邦\nC++ 融合了多種形式的 programming 手法，物件導向、procedural、generic、metaprogramming、functional...。\n\n### 條款2 盡量以 `const` , `enum`, `inline` 取代 `#define`\n- 以 const, enum, inline 取代 `#define`， 寧可以編譯器 (compiler) 取代前處理器 (pre-processor)。 \n- 對於單純的常數，以 `const` 或 `enum` 取代\n- 對於形似 function 的巨集(macro)，用 `inline` 取代。\n#### Const\n- [[以 Const 取代使用 Define]]\n- [[The definition and declaration of static const]]\n#### Enum\n- [[enum hack]]\n#### Inline\n\n\n### 條款3 盡可能使用 const\n盡可能的使用 `const`，它可以確保物件不被改變。特別是 custom class designer 更加需要注意 operator 的 constness。\n\n- `const` 在星號左邊: 被 point 的物件是常數\n- `const` 在星號右邊: pointer 自身是常數\n```c++\nchar greeting[] = \"Hello\";\nchar* p greeting;\n\nconst char* p = gretting; // non-const ptr, const data\nchar const* p = gretting; // same \n\nchar* const p = greeting; // const ptr, non-const data\nconst char* const p = greeting; // const ptr, const data\n```\n\n當 `const` 在 `*` 前，不管是先寫 const 修飾的類、或是先寫 const 都是一樣的，就是在修飾 `char` 物件具有常數性。\n\n[[Const in C++]]\n\n### 條款4 確定物件在使用前已經初始化\n不是所有的物件宣告時自帶初始化，它的規則過於複雜，只需要謹記: 宣告時就要初始化!\n(通常是 C-style 的，像是 array 不保證會發生初始化)，而 non-C part 的 (like `std::vector`) 有其他規則，就自帶初始化)\n\n對於內建型別 (int, char, double)，初始化就是手動給值。對於內建型別之外的，則要寫 constructor。\n\n為了避免沒有初始化帶來的不確定性，確保三件事\n1. 對於不是 member data 的 built-in type object，手動初始化。C++ 並不保證會初始化所有的 Built-in type Object (ex. array)。\n2. 對於 Custom Class，使用 [[Member Initialization List]] 初始化 member data。原因參見 [[Identify Initialization and Assignment]]\n3. 若初始化順序具有不確定性，想辦法加強 design，確保不會發生 circle (兩個變數相互依賴) 或競速問題。\n4. 當 static object 之間有依賴關係時，local static objects 勝過 non-local static objects。參見 [[Static Object]]\n\n## Chapter2 建構、解構、賦值運算\n\n### 條款5 了解 C++默默編寫並呼叫哪些函式\n\n當我們宣告了一個 Class，而不去實踐任何細節，Compiler 會偷偷地幫我們生成一些 function，他們分別是\n- default constructor, destructor\n```cpp\nEmpty() { ... } // default constructor\n~Empty() { ... }\n```\n- copy constructor, copy assignment\n```cpp\nEmpty(const Empty\u0026 rhs) { ... } // copy constructor\nEmpty\u0026 operator=(const Empty\u0026 rhs) { ... } // copy assignment \n```\n\n並且，都是 public inline function!! 關於這些 function 被 inline 會帶來什麼危害，見 [[建構和解構式是 inline 的糟糕人選]]。\n\n更確切來說，是當這些 function 被需要 (被呼叫) 時產生: [[Default Generated Functions]]\n\n### 條款6 明確拒絕不要編譯器自動生成的函式\n在 C++11 引入了新的概念 [Deleted functions](https://www.ibm.com/docs/en/zos/2.4.0?topic=definitions-deleted-functions-c11)，書中教的方法依然有其壞處。直接在 declaration 後面接著 `=delete` 就可以阻止 copmiler 生成它。\n\n```cpp\nA(const A\u0026) = delete;\n```\n\n[[Deleted Function]]\n\n### 條款7 為多型用途的基礎類別宣告 virtual 解構式\n申明，這條規則**只針對**多型的 Base Class\n- 首先就先說明多型的用意: [[為多型用途的基礎類別宣告 virtual 解構式]]\n\n### 條款8 不讓異常逃離解構式\nC++ 不會禁止 Exception 發生於 Destructor，但這麼做具有相當的風險。一旦 Exception 發生而跳出了 Destructor，會中止銷毀物件的程序。\n特別是 STL Container 或 Array 這種資料結構中，若前面有某個 element 在銷毀過程中 thorw Exception 使得 Container 的 Destructor 被中斷，則後面的 elements 有可能不被銷毀，而導致記憶體洩漏! \n\n[[解構式與異常]]\n\n### 條款9 不在建構與解構中呼叫 virtual 函式\n\n不要在 Constructor 與 Destructor 中呼叫 virtural 函式。這和 Java 與 C# 不同!!!\n\n[[Virtual Function]]\n\n\n### 條款10 讓 operator= 回傳自身的 reference\n讓 `operator=`, `operator+=` 等 assignment 符號回傳自身的 Reference。\n這是一項協議，並非強制規定。但在 STL 提供的型別，或是即將 support 的 type ([[Item54 Familiarize yourself with the standard library including TR1]])，都會遵守這個協定，請從眾。\n\n### 條款11 在 operator= 處理自我賦值\n\n在撰寫 `operator=` 時，需要考量當 `rhs==this` 的狀況。\n即使不是如下面的方式 handle 自我賦值，記住，不要讓這個函式 raise exception (exception safety) 就對了。\n\n```cpp\nWidget\u0026 Widget::operator=(const Widget\u0026 rhs)\n{\n\tif (this == \u0026rhs) return *this; // assignment to self\n\tdelete pb;\n\tpb = new Bitmap(*rhs.pb);\n\treturn *this;\n}\n```\n\n### 條款12 複製物件時記得每一個部分\n\n當 Programmer 自己定義 [[Copying function]] 時，Compiler 不會警告你出錯! 你需要自己注意!!\n\n## Chapter3 資源管理\n\n### 條款13 使用資源管理器\n\n- 資源取得的時機就是初始化的時機 (Resource Acquisition Is Initialization, [RAII](https://zh.wikipedia.org/zh-tw/RAII))\n- [[Smart Pointer]] 是個好選擇\n\n### 條款14 仔細考慮資源管理類別的 Copy 行為\n- Smart Pointer 那類的資源管理器，適合用來掌握 heap-based resource 的生命週期。\n- 並非所有的資源物件，都適合用 Smart Pointer 管理。\n- 書中以 [[Mutex]] (互斥鎖) 舉例。\n\n\u003e [!Todo]\n\u003e 1. 查一查 RAII，這整個章節我看不太懂。\n\u003e 2. 看到 P67，面對複製的問題還沒看。\n\n\n\u003e [!question]\n\u003e (此處是舊版，新版有對應的東西嗎?\n\n### 條款15 在資源管理類中提供對原始資源的存取\n\n儘管使用 [[Smart Pointer]] 管理資源很方便，我們仍有機會需要取得原始的 Pointer。Smart Pointer 同時有提供顯示介面 (explicit) 與隱式介面: \n- explicit : 以 `get` 取得 Raw Pointer。\n- implicit : `operator*`, `operator-\u003e`。\n\n### 條款16 成對的使用 `new` 和 `delete` 並採用相同型式\n1. 盡可能不要用 C-style Array\n2. STL所提供的 vector, string 等 templates 可以降低對 Array 的需求，減少錯誤的發生。\n\n\n### 條款17 以獨立的語句將物件放入 Smart Pointer\n\n```c++\nstd::shared_ptr\u003cWidget\u003e pw(new Widget);\nprocessWidget(pw, priority());\n```\n\n[[為什麼要用獨立句將物件放入 Smart Pointer]]\n\n## Chapter 4 設計與宣告\n### 條款18 讓介面容易被使用、防範誤用\n\n[[讓介面易於被使用，不易誤用]]\n\n### 條款19 設計 Class 猶如設計 Type\n設計 Class 請遵守準則想過一遍: [[設計新 Class 的準則]]\n\n### 條款20 以 Pass by Const Ref 取代 Pass by Value \n\n合理的 Pass by value 幾乎只有下面三種選擇\n1. 內建型態\n2. STL Iterator \n3. Function Object\n\n除此之外，包含 STL Container 應盡可能用 Pass by const reference !\n- [[思維誤區-物件很小就可以 Pass By Value]]\n\n### 條款21 當必須回傳物件時，不要考慮回傳 Reference \n\n絕對不要\n 1. 將 Pointer 或 Reference 指向一個 local 物件回傳。\n 2. 讓 Reference 指向 heap-based object (`new`)\n 3. 當設計出「回傳 ptr/ref 指向 local static」，並且有很多個物件都採用這種形式時提高警覺，很有可能走入了 Bad design。對於怎麼樣是「合理」使用 Local static object : 參見 [[Static Object]]。\n\n\n### 條款22 將成員變數宣告成 Private\n\n- 只提供必要的 Getter 給客戶端，隱藏你的實作有絕佳的好處。\n- [[Protected 與 Public 都是低封裝度的 Access Level]]\n\n\n### 條款23 寧以non-member, non-friend替換 member函數\n\n這條是針對 Object-Oriented C++ 的法則，[[Non-member \u0026\u0026 Non-friend Function 的封裝度優於 Member Function]]。\n站在 Template C++ 又有其他需要考慮的地方，形成了 [[需要型別轉換時請為模板定義非成員函式]]。\n\n\n### 條款24 如果所有的參數都需要型別轉換，請為此採用 non-member 函式\n[[當所有的參數都需要型別轉換，採用 Non-member Function]]\n\n\n### 條款25 考慮寫出一個不拋異常的 Swap 函式\n[[Swap and pimpl]]\n\n\u003e [!danger]\n\u003e 讀到 P111，我懷疑 C++11 之後有不同的做法，先不細看。\n\n\n---\n\n## Ch5 Implementation\n### 條款26 盡可能延後變數定義式的出現時間\n盡可能等到已經擁有初始值了，再一口氣定義+賦予初始值。如此不必調用多餘的 constructor ! \n- [[盡可能延後變數定義式的出現時間]]\n\n\n### 條款27 少做轉型動作 (Minimize Casting)\n- 如果轉型是必要的，試圖把它隱藏在函式之後，不讓 User 在他們的程式中轉型。\n- 作為 Client，如果需要轉型，考慮使用新式的轉型，即使用舊式看起來也合情合理。\n[[少做轉型動作(Minimize casting)]]\n\n### 條款28 避免傳回 Handles 指向物件內部成分\n[[避免傳回 Handles 指向物件的 Private \u0026 Protected Member Data]]，目的是盡可能消滅 dangling handles 出現的可能。\n\n\n### 條款29 為異常安全 (Exception-safe) 而努力是值得的\n\n[[為異常安全 (Exception-safe) 而努力是值得的]]\n\n\u003e [!Todo]\n\u003e Read to P132\n \n### 條款30 透徹了解 Inline\n\n宣告 inline 前，先透徹讀完: [[了解 Inline 的裡裡外外]]\n\n### 條款31 將檔案間的編譯依存降到最低\n[[將檔案的編譯依存關係降到最低]]\n\n\n---\n\n## Ch6 繼承與物件導向\n\n### 條款32 確定 Public 繼承塑造出 is-a 關係\n[[確保 Derived Class 和 Base Class 之間必然保持 Is-a 關係]]\n\nPublic inheritance 意味著 Is-A 關係，Private inheritance 的意義則完全不同 [[審慎的使用 Private 繼承]]。\n\n\n\n\n### 條款33 避免遮掩繼承而來的名稱\n當 Base Class 和 Drived Class 有相同名稱的 function 但不同 signature 時，override 不會發生，而是直接覆蓋掉 Base Class 的 function，等同於 Drived Class 的 function 脫離了 Base Class 的掌控，這就是本條款想強調的: 這個行為遮掩了繼承來的名字。\n\n[[使用關鍵字 using 讓特定 function 在 Scope 內可見]]\n[[override]]\n\n### 條款34 區分介面繼承與實作繼承\n透過 Pure virtual function, Impure virtual, non-virtual function 三種 function 區分 Base Class Designer 的意圖。\n\n[[區分介面繼承(interface)和實作繼承(implement)]]\n\n### 條款35 考慮 Virtual 函式以外的其他選擇\n除了 Virtual function，我們還有其他手法可以達到「讓 Derived Class 提供相同的介面、不同實作的手法」\n- [[藉由 Non-Virtual Interface 手法實現 Template Method Pattern]]\n- [[藉由 Function Pointer 和 tr1 function 手法實現 Strategy Pattern]]\n\n### 條款36 絕不重新定義繼承來的 Non-virtual Function\n[[絕不重新定義繼承來的 Non-virtual Function]]\n\n### 條款37 絕不重新定義繼承來的預設參數值\n[[靜態綁定 (statically bound) 與動態綁定 (dynamically bound)]]\n\n### 條款38 確定 Composition 塑造的是 Has-A 關係或根據某物實作的關係\n\nModel \"has-a\" or \"is-implemented in terms of \" through composition.\n[[確定 Composition 塑造的是 'Has-A'關係 或 '根據某物實作'的關係]]\n\n### 條款39 明智審慎的使用 Private 繼承\n[[審慎的使用 Private 繼承]]\n\n### 條款40 明智審慎的使用多重繼承\n[[多重繼承 (Multiple Inheritance, MI)]]\n\n\n## Ch7 Template and Generic Programming\n[[Template 的用途]]\n\n\n### 條款41 了解隱式介面和編譯多型\n[[Template 與隱式介面]]\n\n### 條款42 了解 typename 的雙重意義\n[[關鍵字 typename 在 Template 中的意涵]]\n\n### 條款43 學習處理模板化基礎類別內的名稱\nknow how to access names in templatized base classes.\n[[了解如何在 Template 中指涉 Base Class 成員]]\n\n### 條款44 將與參數無關的程式碼抽離 Templates\n[[Template 帶來的程式碼膨脹]]\n\n### 條款45 運用成員函式模板接受所有相容型別\n[[運用成員函式模板，接受所有相容的型別]]\n\n\n### 條款46 需要型別轉換時請為模板定義非成員函式\n\n\n- [[需要型別轉換時請為模板定義非成員函式]]\n\n### 條款47 請使用 Traits Classes 表現型別資訊\n\n### 條款48 認識 Template 超編程\n\n## Ch8 自訂 new 和 delete\n\n### 條款49 了解 new-handler 的行為\n\n### 條款50 了解 new 和 delete 的合理替換時機\n\n### 條款51 編寫 new 和 delete 時需固守常規\n\n### 條款52 寫了 placement new 也要寫 placement delete\n\n\n\n## Ch9 雜項討論\n### 條款53 不要輕忽邊義器的警告\n\n### 條款54 讓自己熟悉包刮 TR1 在內的標準函式庫\n[[Item54 Familiarize yourself with the standard library including TR1]]\n\n### 條款55 讓自己熟悉 Boost\n\n[[Item55 Familiarize yourself with Boost]]\n\n\n簡體目錄: https://blog.csdn.net/weixin_45926547/article/details/121276226\n","lastmodified":"2023-09-05T15:34:45.954894749Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/Effective-modern-C++-Outline":{"title":"Effective modern C++ Outline","content":"## 外部資源\n- [網友中譯版](https://github.com/CnTransGroup/EffectiveModernCppChinese)\n\n## Deducing Types\n\n### 條款1 了解 Template 的型別推斷規則\n[[Template ParamType deduction]]\n\n### 條款2 了解 auto 的型別推斷規則\n\n\n### 條款3 了解 decltype\n\n\n### 條款4 了解如何檢視型別推斷\n\n## auto\nItem 5: Prefer auto to explicit type declarations\nItem 6: Use the explicitly typed initializer idiom when auto deduces\nundesired types\n\n## Moving to Modern C++\nItem 7: Distinguish between () and {} when creating objects\nItem 8: Prefer nullptr to 0 and NULL\n### Item 9: Prefer alias declarations to typedefs\n[[typedef and using]]\n\nItem 10: Prefer scoped enums to unscoped enums\nItem 11: Prefer deleted functions to private undefined ones\nItem 12: Declare overriding functions override\n## 條款12 對要 override 的 function 以關鍵字 override 明確宣告 \n[[override]]\nItem 13: Prefer const_iterators to iterators\nItem 14: Declare functions noexcept if they won’t emit exceptions\n[[Modern C++ noexcept]]\n\nItem 15: Use constexpr whenever possible\n[[Item15 constexpr]]\nItem 16: Make const member functions thread safe\nItem 17: Understand special member function generation\n\n## Smart Pointers\nItem 18: Use std::unique_ptr for exclusive-ownership resource management\nItem 19: Use std::shared_ptr for shared-ownership resource management\nItem 20: Use std::weak_ptr for std::shared_ptr-like pointers that can dangle\nItem 21: Prefer std::make_unique and std::make_shared to direct use of new\nItem 22: When using the Pimpl Idiom, define special member functions in the implementation file\n\n## Rvalue References, Move Semantics, and Perfect Forwarding\nItem 23: Understand std::move and std::forward\nItem 24: Distinguish universal references from rvalue references\nItem 25: Use std::move on rvalue references, std::forward on universal references\nItem 26: Avoid overloading on universal references\nItem 27: Familiarize yourself with alternatives to overloading on universal references\nItem 28: Understand reference collapsing\nItem 29: Assume that move operations are not present, not cheap, and not used\nItem 30: Familiarize yourself with perfect forwarding failure cases\n\n## Lambda Expressions\nItem 31: Avoid default capture modes\nItem 32: Use init capture to move objects into closures\nItem 33: Use decltype on auto\u0026\u0026 parameters to std::forward them\nItem 34: Prefer lambdas to std::bind\n\n## The Concurrency API\nItem 35: Prefer task-based programming to thread-based\nItem 36: Specify std::launch::async if asynchronicity is essential\nItem 37: Make std::threads unjoinable on all paths\nItem 38: Be aware of varying thread handle destructor behavior\nItem 39: Consider void futures for one-shot event communication\nItem 40: Use std::atomic for concurrency, volatile for special memory\n\n## Tweaks\nItem 41: Consider pass by value for copyable parameters that are cheap to move and always copied\nItem 42: Consider emplacement instead of insertion\n\n## Item1 Template ParamType deduction\n\n\n\n## 參考中文\n###   推斷型別\n\n項目1：理解模板型別推斷 項目2：理解自動型別推斷 項目3：理解decltype 項目4：了解如何查看推斷的型別\n\n## auto\n\n項目5：優先使用auto而非顯式型別聲明 項目6：在auto推斷出不希望的型別時使用顯式型別初始化惯用法\n\n## 遷移到現代C++\n\n項目7：在創建對象時區分()和{} 項目8：優先使用nullptr而非0和NULL 項目9：優先使用別名宣告而非typedef 項目10：優先使用有作用域的枚舉而非無作用域的枚舉 項目11：優先使用已刪除的函數而非私有的未定義函數 項目12：聲明覆蓋的函數使用override 項目13：優先使用const_iterators而非iterators 項目14：如果函數不會引發異常，聲明函數為noexcept 項目15：盡可能使用constexpr 項目16：使const成員函數線程安全 項目17：理解特殊成員函數的生成\n\n## 智能指針\n\n項目18：使用std::unique_ptr進行獨占性資源管理 項目19：使用std::shared_ptr進行共享性資源管理 項目20：使用std::weak_ptr表示可以懸空的std::shared_ptr指針 項目21：優先使用std::make_unique和std::make_shared，而非直接使用new 項目22：在實現文件中定義特殊成員函數時使用Pimpl技法\n\n## Rvalue引用、移動語義和完美轉發\n\n項目23：理解std::move和std::forward 項目24：區分萬能引用和右值引用 項目25：對右值引用使用std::move，對萬能引用使用std::forward 項目26：避免對萬能引用進行重載 項目27：熟悉在萬能引用上進行重載的替代方案 項目28：理解引用折疊 項目29：假設移動操作不存在、不廉價且不被使用 項目30：熟悉完美轉發失敗的情況\n\n\n### Item5\n[[C++11 std function]]\n\n\n","lastmodified":"2023-09-05T15:34:45.954894749Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/Friend-Function":{"title":"Friend Function","content":"\n\u003e 提供私用成員給某些外部函式來存取，這個有權調用某類別私有成員的函式就稱為 Friend Function \n\nFriend Function 實質上定義在外面，但是在 Class 內部需要用 keyword `friend` 再提及一次該 function。因此，Friend Function 是 Non-member function !\n\n```cpp\nclass Ball;\n\nint compare(Ball \u0026b1, Ball \u0026b2) {\n    // 可直接存取私用成員\n    if(b1._radius == b2._radius)\n        return 0;\n    else if(b1._radius \u003e b2._radius)\n        return 1;\n    else\n        return -1;\n}\n\nclass Ball { \npublic: \n    Ball(double, char*); \n    void radius(double radius) {\n        _radius = radius;\n    } \n    // 宣告朋友函式 \n    friend int compare(Ball\u0026, Ball\u0026);\n \nprivate:\n    double _radius; // 半徑\n};\n```\n\n\n\n\n\n\n\n## Resource\n\n[friend 函式、friend 類別](https://openhome.cc/Gossip/CppGossip/friendFunctionClass.html)\n","lastmodified":"2023-09-05T15:34:45.958894802Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/Function-As-an-Argument":{"title":"Function As an Argument","content":"\n\u003e Array 並不是 C++ 中唯一可以 decay 成 pointer 的東西。function type 也同樣的可以 decay 成 function pointer。\n\nFunction Argument 在 Template Type Deduction 的原則跟 Array Argumnet 是一樣的。\n```cpp\nvoid func(int double); // function Type: void(int, double)\n\ntemplate \u003ctypename T\u003e\nvoid f1(T param);\n\ntemplate \u003ctypename T\u003e\nvoid f2(T\u0026 param);\n```\n\n把 `func` 放入 `f1` 與 `f2` 後，型態推斷如下: \n|  Code   | ParamType  | `T`|\n|  ----  | ----  | ---|\n| `f1(func)`  | `void (*) (int, double)` |`void (*) (int, double)`|\n|  `f2(func)` | `void (\u0026) (int, double)` | `void (int, double)`|\n","lastmodified":"2023-09-05T15:34:45.958894802Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/Identify-Initialization-and-Assignment":{"title":"Identify Initialization and Assignment","content":"\n\u003e C++ 規定，member data initialization 發生在**進入 Constructor 之前**。在 Constructor 賦值屬於 assignment。 正確的 initialization 是使用 member initialization list (成員初值列)，取代賦值 (assignment)。\n\n此例中，第一種的做法效率好: \n- 第一種作法使用  member initialization list 是對 member data 做 Copy Construct。\n- 第二種作法 `m_name`會隱含的 call 一次 `std::string` 的 default constructor，再以 Copy assignment 被賦予值\n\n```cpp\nclass Book {\n    private:\n        std::string m_name;\n    public:\n        // good way\n        Book(const std::string\u0026 name): m_name { // copy construct\n        }\n        // bad way\n        Book(const std::string\u0026 name) {\n            m_name = name;  // copy assignment\n        }\n}\n```\n","lastmodified":"2023-09-05T15:34:45.958894802Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/Implicit-TemplateInstantiation":{"title":"Implicit TemplateInstantiation","content":"\u003e Occurs when a template is used to declare a pointer variable or a variable with the provided arguments","lastmodified":"2023-09-05T15:34:45.958894802Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/Impure-Virtual-Function":{"title":"Impure Virtual Function","content":"```cpp\nclass Airport { ... }; // represents airports\nclass Airplane {\npublic:\n\tvirtual void fly(const Airport\u0026 destination);\n...\n};\nvoid Airplane::fly(const Airport\u0026 destination)\n{\n\t// default code for flying an airplane to the given destination\n}\nclass ModelA: public Airplane { ... };\nclass ModelB: public Airplane { ... };\n```\n\n相當於告訴 Client: 你需要提供一個這樣的函式，如果不想自己寫，可以用預設的內容! \n\n但是，讓 impure virtual function 同時擔任「要求 client 給一個這樣的函式」又在「實作中放了預設行為，相當於假設所有的 Derived Class 都可以接受這個預設行為」可能導致其他問題: Client 端沒有主動說明「我要這個預設行為」。\n當 Client 端忽略了有這個 function 要 override，就會導致錯誤 -- 該 Derived 可能無法執行這個預設行為。\n\n## 把預設行為跟提供介面切開\n一個好的做法是--斷開兩者的連結。利用 [[Pure Virtual Function]] 提到的做法，把預設的實作寫在 Pure Virtual Function 裡面，當 Derived 想要用預設實作時自己去 call 就好。\n\n\n```cpp\nclass Airplane {\npublic:\n\tvirtual void fly(const Airport\u0026 destination) = 0; // 提供介面\n}\n\nvoid Airplane::fly(const Airport\u0026 destination)\n{ // 為 pure virtual function 提供實作\n\tdefault code for flying an airplane to the given destination\n}\n\nclass ModelA: public Airplane {\npublic:\nvirtual void fly(const Airport\u0026 destination)\n{ Airplane::fly(destination); }\n};\n\nclass ModelC: public Airplane {\npublic:\nvirtual void fly(const Airport\u0026 destination);\n...\n};\nvoid ModelC::fly(const Airport\u0026 destination)\n{ // ModelC 不用預設的實作，就不要 Call Airplane::fly，自己寫\ncode for flying a ModelC airplane to the given destination\n}\n```","lastmodified":"2023-09-05T15:34:45.958894802Z","tags":[]},"/notes/Project/Effective-C++-Series/Item15-constexpr":{"title":"Item15 constexpr","content":"","lastmodified":"2023-09-05T15:34:45.958894802Z","tags":["empty","cpp11"]},"/notes/Project/Effective-C++-Series/Item47-Use-traits-classes-for-information-about-types":{"title":"Item47 Use traits classes for information about types","content":"","lastmodified":"2023-09-05T15:34:45.958894802Z","tags":["empty"]},"/notes/Project/Effective-C++-Series/Item54-Familiarize-yourself-with-the-standard-library-including-TR1":{"title":"Item54 Familiarize yourself with the standard library including TR1","content":"","lastmodified":"2023-09-05T15:34:45.958894802Z","tags":["empty"]},"/notes/Project/Effective-C++-Series/Item55-Familiarize-yourself-with-Boost":{"title":"Item55 Familiarize yourself with Boost","content":"","lastmodified":"2023-09-05T15:34:45.958894802Z","tags":["empty"]},"/notes/Project/Effective-C++-Series/Member-Function-Template":{"title":"Member Function Template","content":"並不限用於 constructor，它常被用來處理賦值操作。\n\n以 `shared_ptr` 為例，它的 copy ctor 可以接受 `weak_ptr` 與 `shared_ptr` (不限此二類，沒有全列)。且包含 copy assignment 也是透過 member function template 達成。\n\n只不過 constructor 類的，除了 generic copy constructor (接收 shared pointer type 的) 是接受隱式轉換的， \n\n```cpp\ntemplate\u003cclass T\u003e class shared_ptr {\npublic:\n\t// constructor\n\ttemplate\u003cclass Y\u003e // construct from\n\texplicit shared_ptr(Y * p); // any compatible\n\t// copy ctor for share_ptr type \n\ttemplate\u003cclass Y\u003e // built-in pointer,\n\tshared_ptr(shared_ptr\u003cY\u003e const\u0026 r); // shared_ptr,\n\t// copy ctor for weak_ptr type \n\ttemplate\u003cclass Y\u003e // weak_ptr, or\n\texplicit shared_ptr(weak_ptr\u003cY\u003e const\u0026 r); // auto_ptr\n\t\n\ttemplate\u003cclass Y\u003e // assign from\n\tshared_ptr\u0026 operator=(shared_ptr\u003cY\u003e const\u0026 r); // any compatible\n\t\n\ttemplate\u003cclass Y\u003e // shared_ptr or\n\tshared_ptr\u0026 operator=(auto_ptr\u003cY\u003e\u0026 r); // auto_ptr\n};\n```\n\n## 編譯器依然會自動產生 copying function\n\n條款5中說到，編譯器會自動產生一些 function: [[Default Generated Functions]]\n儘管以上透過 member function template 撰寫了 copying function，這不會阻止 compiler 自動生成 那些預設生成的函式!!\n\n試想，當 `T` 和 `U` 相同，呼叫的 funciton 會是 compiler 自動生成的版本? 還是根據模板函式生成一個 `SmartPtr(const SmartPtr\u003cTop\u003e\u0026 other)` 的 function? \n```cpp\ntemplate\u003ctypename T\u003e\nclass SmartPtr {\npublic:\n\ttemplate\u003ctypename U\u003e // member template \n\tSmartPtr(const SmartPtr\u003cU\u003e\u0026 other); // for a ”generalized copy constructor”\n}\n\nSmartPtr\u003cTop\u003e pt2 = SmartPtr\u003cTop\u003e(new Top);\n```\n\n在 class 內宣告模板函式，並會阻止編譯器生成預設的 copy ctor (non-template)，如果希望完全掌控 copy ctor，則必須**都宣告**\n```cpp\ntemplate\u003ctypename T\u003e\nclass SmartPtr {\npublic:\n\tSmartPtr(SmartPtr const\u0026 rhs); // non-template copy ctor\n\n\ttemplate\u003ctypename U\u003e // template copy ctor\n\tSmartPtr(const SmartPtr\u003cU\u003e\u0026 other); \n}\n\n```","lastmodified":"2023-09-05T15:34:45.958894802Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/Member-Initialization-List":{"title":"Member Initialization List","content":"\n\u003e 無論如何，使用 member initializer list 對 member data 初始化是最好的。儘管這麼做對內建型別的資料沒差，對非內建型別卻有巨大的意義。\n\n如果你就是想要 call member data 的 default constructor，依然可以透過 member initializer list 達成。只要給予空括號，不填內容即可。\n這樣的好處是明白地列出所有 member data，避免有 data 忘記給初始值，特別是對**非內建型別**的member data，沒有初始化的結果是災難的。\n\n對於內建型別的 Reference \u0026 const，他們**不能被賦值**，**必須透過 member initializer list 初始化**。\n- Related: [[Effective C++ Outline#條款5 了解 C++默默編寫並呼叫哪些函式]]\n\n\n## 合理的使用 Assignment\n某些時候，類別擁有多個 Constructor，每個 Constructor 都需要有自己的 Member initializer list，這又會導致 dumplicated。\n這時候可以是當地將一些 Assignment 和 Initialize 效率差不多的 member data (通常是內建型別)，移到一個 \"統一初始化\" 的 private function，供所有的 Constructor 呼叫。\n這種作法 (pseudo-initialization, 偽初始化) 特別在數值是由讀檔得到的時候特別有用，但可以的話，盡可能使用 member initializer list。\n","lastmodified":"2023-09-05T15:34:45.958894802Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/Modern-C++-noexcept":{"title":"Modern C++ noexcept","content":"\n[[為異常安全 (Exception-safe) 而努力是值得的]]\nC++11 中新增的 `noexcept` 有如 `const` 一般，是 function signature 的一部分。\n\n\n固然，在 Effective Modern C++ Item 14 當中提及將 function 標示為 noexcept 所帶來的 object file optimize 益處。仍需要切記，`noexcept` 也是 signature 的一部分，如果只是想要享受優化的好處，而沒有仔細審視 function 是否真的 exception safe，直接將 API 暴露給客戶端，而在日後發現並非 exception safe 而收回 noexcept 保證，這將嚴重影響客戶端的使用。\n多數的 function 是 exception natural (中性的)，意即，不主動拋出 exception，但 exception 可能從此 func 所  invoke 的 function 中被拋出來。這就表示此 function 非 exception safe\n\n\n","lastmodified":"2023-09-05T15:34:45.958894802Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/Mutex":{"title":"Mutex","content":"假設我們用 C API 處理 `Mutex` 物件\n```cpp\nvoid lock(Mutex *pm); // lock mutex pointed to by pm\nvoid unlock(Mutex *pm); // unlock the mutex\n```\n\n使用者需要自己手動分別呼叫 `lock` 與 `unlock`。為了確保不會忘記幫 Mutex 解鎖，可以建立一個由 RAII 守則支配的 Class --資源在建構期間獲得(lock)，在解構期間釋放(unlock)--來管理資源「Mutex 物件」。\n\n```cpp\nclass Lock {\npublic:\nexplicit Lock(Mutex *pm) : mutexPtr(pm) \n\t{ lock(mutexPtr); } // acquire resource\n~Lock() { unlock(mutexPtr); } // release resource\n\nprivate:\nMutex *mutexPtr;\n};\n\n```\n而客戶端調用，也符合 RAII 方式\n```cpp\nMutex m;     // define the mutex you need to use\n...\n{            // create block to define critical section\nLock ml(\u0026m); // lock the mutex\n...          // perform critical section operations\n}            // automatically unlock mutex at end of block\n```\n現在，客戶在也不會因忘記為  `unlock(Mutex)` 而出問題!\n\n## 如果有人試圖複製 `Lock` ?","lastmodified":"2023-09-05T15:34:45.958894802Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/Non-member-Non-friend-Function-%E7%9A%84%E5%B0%81%E8%A3%9D%E5%BA%A6%E5%84%AA%E6%96%BC-Member-Function":{"title":"Non-member \u0026\u0026 Non-friend Function 的封裝度優於 Member Function","content":"\n\u003e Non-member function 帶來更佳的封裝度、與 Packaging 彈性。\n\n\n這邊說的是 Non-member 且(AND) Non-friend function (Pure function) vs. Member Function。(關於 [[Friend Function]] )\n\n物件導向要求，資料(data) 以及操作資料的函式應該盡量綁在一起，不代表物件導向推崇 member function 是比較好的選擇。\n\n物件導向要求資料應該盡可能地被封裝，卻與直觀相反的，non-member function 的封裝性優於  member function。為什麼? \n\n## 封裝為什麼封裝被推崇? \n\u003e 封裝使得我們在改變事物時，只影響有限的客戶。\n\n- 被封裝的東西變得不可見 -\u003e 越多封裝就越少 client 可以 access -\u003e 對實作方而言，有更大的彈性改變它，因為能 access 它的客戶有限，改變的影響力小。\n- 還有另一個優點是: 帶來包裹彈性 (packaging flexibility)，這與 Namespace \u0026 header file 相關，後面會提及。\n\n## 如何衡量封裝程度\n這個問句可以換句話說，如何量測「有多少 function 可以看到某一塊資料?」。\n\n\u003e 計算能夠存取該資料的函式，越多函式存取則封裝度越低。\n\n對於 Private Member data 而言，能存取它的就是所有的 member function。\nFriend function 雖然不是 non-member function，但他和 member function 同樣擁有 access private data 的能力，所以兩者的封裝度是同樣低的。 \n\n同理，前面章節說的 [[Protected 與 Public 都是低封裝度的 Access Level]]。\n\n## 將有編譯相依的函式放在同一個 Header File\n當我們遵守本頁的守則，拆出許多 Utility Function (工具箱) 之後，該考慮將 Function 依照編譯相依性拆分到不同的 Header file，在不同的 Header file 間共用同一個 namespace 即可。\n\n書中以 `WebBrowser` 舉例，Utility Function 可能有 cookie, bookmark, core funcion (幾乎每個客戶都要的 non-member function)，cookie functions 之間有編譯相依性，放在一塊以此類推。\n\n```cpp\n// web_browser_core.hpp\nnamespace WebBrowserStuff {\n\t// core function\n\tclass WebBrowser;\n}\n\n// cookie.hpp\nnamespace WebBrowserStuff {\n\t// cookie functions\n}\n\n// bookmark.hpp\nnamespace WebBrowserStuff {\n\t// bookmark functions\n}\n```\n\n這也是 STL 的組織方式，當 User 要用 std::list 時不會去 Include 到 `\u003cvector\u003e` 這個 header file。\n\nNamespace 提供一個比較寬鬆的組織方式，即使跨越 header file 仍能隸屬相同的 namespace。\n\n甚至對 Client 而言，擴展 Utility Function 也同樣容易，只要共用 namespace 、在自己的 header file 增加客製化的 utility function 即可 -- 畢竟 Namespace 可以跨 header file! \n\n這是以 Namespace 組織，優於以 class 組織的另一個好處 : 對 Client 端而言，他們無法改變 Class 的定義式，但 namespace 他們可以自由共用。\n\n## 有著繼承也無法取代的優點\n\n當然，不能改變定義式，繼承是個解決方法。\n\n然而 C++ 的繼承中，Child 是不能取得 Parent 的 Private Data 的。繼承可以擴充 Public 方法，這點跟 non-member \u0026\u0026 non-friend function 如出一轍，沒有佔上風，卻在 package fexility 上輸了一截。\n\n這種程度的「擴展機能」相較共用 Namespace 能拆分 Header file 依賴度，就打了折扣。","lastmodified":"2023-09-05T15:34:45.958894802Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/ODR-use":{"title":"ODR use","content":"https://en.cppreference.com/w/cpp/language/definition#ODR-use\n\n- 當一個物件被稱為 odr use: 物件被讀取 (例外: compile time constant) 或寫入、它的 address 被取用，或有 reference 綁到他身上\n- 當一個 reference 被稱為 odr use: 當它所 reference 到的物件在 compile 期間是未知的\n- 一個 function 被稱為 odr use: 有產生對它的 function call，或它的 address 被取用\n總結: 當一個物件、reference 或 function 被稱為 odr use，表示它的定義必定 exist 於 program 的某處，違反這一點會導致 Link time error。","lastmodified":"2023-09-05T15:34:45.958894802Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/One-Definition-Rule":{"title":"One Definition Rule","content":"Source: https://en.cppreference.com/w/cpp/language/definition\nSource: https://en.wikipedia.org/wiki/One_Definition_Rule\n\n1. 在一個 translation unit 當中，template, type, function, object 只能一份 definition (一份實作)。\n2. 在整個 program 當中，一個 object 或 non-inline function 不能有多於一個 definition\n3. Some things, like types, templates, and [extern](https://en.wikipedia.org/wiki/Extern \"Extern\") inline functions, can be defined in more than one translation unit. For a given entity, each definition must have the same sequence of [tokens](https://en.wikipedia.org/wiki/Lexical_analysis \"Lexical analysis\"). Non-extern objects and functions in different translation units are different entities, even if their names and types are the same.","lastmodified":"2023-09-05T15:34:45.958894802Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/ParamType-%E6%98%AF-Pointer-%E6%88%96-Reference-%E4%BD%86%E4%B8%8D%E6%98%AF-Universal-Reference":{"title":"ParamType 是 Pointer 或 Reference 但不是 Universal Reference","content":"\nRule: \n1. If expr(argument) has **reference**, ignore the reference part. \n2. T = ArgumentType - declared ParamType.\n","lastmodified":"2023-09-05T15:34:45.958894802Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/ParamType-%E6%98%AF-Universal-Reference":{"title":"ParamType 是 Universal Reference","content":"當 ParamType 被宣告成 `T\u0026\u0026` (Universal Reference) 時，傳入的變數是 rvalue 或 lvalue 在推斷的流程是**不同的**。詳細在 [[Item24 Distinguish universal references from rvalue references]] 會說明。\n\n原則是: \n 1. 當傳入的是 lvalue，`T` 和 `ParamType` 都會推斷成 lvalue reference type。注意，在 Case 1. 當中，`T` 的推斷是不會保留 reference part 的。\n 2. 當傳入的是 rvalue，則規則有如 [[ParamType 是 Pointer 或 Reference，但不是 Universal Reference]]","lastmodified":"2023-09-05T15:34:45.958894802Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/ParamType-%E9%9D%9E-Reference-%E6%88%96-Pointer":{"title":"ParamType 非 Reference 或 Pointer","content":"當 ParamType 不是 Ref 也非 ptr，真正的 `ParamType=T` 時，傳入的物件會被做 **pass by value**。\n在 pass by value 中，只有 pure class infomation 會被保留下來\n\n1. Remove reference-ness\n2. Remove constness\n3. Remove volatileness (少見)\n\n之所以遵守這個原則是因為，當物件以 Copy (pass by value) 傳進來之後，template function 當中的物件已經跟外面的物件完全脫鉤，對它改變的數值也不該影響到外面 (reference-ness)，而外面的物件能否被改動 (constness) 也不甘 function 內變數的事情。\n因此，這些屬性都會被移除。\n\n但是注意下面這個 case:\n\n```cpp\ntemplate \u003ctypename T\u003e\nvoid f(T param);\n\nconst char* const ptr = 'what is this';\nf(ptr); // arg type: const char* const\n\t\t// T       : const char*\n```\n\nptr 是一個指向 const char 的 pointer (`const char*`)，並且這個 ptr 是不可以被改變的 (`const`)，它必須持續指向被 assigned 的物件。綜合起來就是: ptr 是一個不可被改變的 pointer，它持續指向一個不可被改變的 char 物件。\n\n在它的型態推斷中，由於被 copy 的是 `ptr`，故 ptr 的 constness 會消失。也就是說，ParamType 變成 `const char*`，`parm` 是一個指向「不可被變更的 `char` 物件」的 pointer，但 `parm` **可以更改** 所指的對象，只要對方是一個 `const char` 即可。\n\n\u003e `ptr` 從只喜歡「那一個」短頭髮的女生，變成喜歡短頭髮的女生，哪個都可以。 (渣)\n\n由於被 Copy 的對象是 Pointer，被移除 constness 的也只有 Pointer。Pointer 所指向的對象的 Constness 被保留了下來。\n","lastmodified":"2023-09-05T15:34:45.962894855Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/Pass-by-value-%E7%95%B6%E4%B8%AD%E7%9A%84-Copy-%E8%A1%8C%E7%82%BA":{"title":"Pass by value 當中的 Copy 行為","content":"\n## Simple Pass By Value\n考量下面的程式 `validateStudent(s)` 執行的成本有什麼?\n\n```cpp\nclass Person;\nclass Student: public Person;\nbool validateStudent(Student s); // pass by value = copy\nStudent s = Student();\nvalidateStudent(s); \n```\n\n成本是\n- Student Copy Constructor\n- Person Copy Constructor\n一個 Copy Ctor 就意味著一次全部 member data 的 Copy，所以 data 越多呼叫越多 Copy Ctor!! \n\n## 多型函式\n當 Signature 是 Parent，傳入的是 Child，更糟糕的是會發生 Slicing! 只有 `Person` 部分的資料會被 Copy，`Worker` 的資料都被切割了。\n\n```cpp\nclass Worker: public Person;\nbool showName(Person s);\n\nWorker w = Worker();\nshowName(w);\n```","lastmodified":"2023-09-05T15:34:45.962894855Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/Protected-%E8%88%87-Public-%E9%83%BD%E6%98%AF%E4%BD%8E%E5%B0%81%E8%A3%9D%E5%BA%A6%E7%9A%84-Access-Level":{"title":"Protected 與 Public 都是低封裝度的 Access Level","content":"\n思維誤區: Protected 不比 Public 具有更好的封裝性\n- 取消一個 Public Member Data 的成本: 所有使用他的客戶端\n- 取消一個 Protected Member Data 的成本 : 所有繼承他的 Derived Class\n這兩種 Access Level 的封裝性都不佳，仍該盡可能的使用 Private。","lastmodified":"2023-09-05T15:34:45.962894855Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/Pure-Virtual-Destructor":{"title":"Pure Virtual Destructor","content":"現在的情境是，如果，你想要有一個抽象類 -- 抽象類的好處是自身無法被實例化。然而，抽象類的定義是，至少有一個 function 是 Pure Virtural Function。該選擇 \"誰\" 成為 Pure virtural function 呢? 洽巧手上沒有適合的人選! Destructor 會是個好選擇。因為\n1. Abstract Class 總是被當作 Base Class\n2. Base Class 作為多型用途時，應當帶有 virtural destructor\n3.  [[Pure Virtual Function]] 可使該 Class 形成 Abstract\n三個點串起來--「讓 destructor 變成 Pure Virtural 吧」，這樣不會有不該被 virtural 的 function 遭殃! \n\n\u003e Abstruct Class 是不能被實例化的 Class，但可以持有 Abstruct Class 的 Pointer 去操控 Child instance。\n\n不過須記得一個技巧 -- 依然為這個 Base Class 的 Destructor 提供一個空的實作。\n這是因為 Destructor 的運作規則，在繼承架構中，most derived class (最 child 的) 的 destructor 會最先被呼叫，接著是每一個 Base Class 的 Destructor。即使 `AWOV` 作為抽象類沒有實例化的問題，其 destructor 依然會被呼叫，所以需要提供一個空的實作，Linker (編譯器的一部分?) 會報錯。\n```cpp\nclass AWOV {\npublic:\n\tvirtural ~AWOV() = 0;\n}\n\nAWOV::~AWOV() {}; // 依然為它提供一個實作\n```\n\n ","lastmodified":"2023-09-05T15:34:45.962894855Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/Pure-Virtual-Function":{"title":"Pure Virtual Function","content":"\n\u003e 只繼承 Interface 需自行實做\n\n相當於告訴 Client: 你需要提供一個這樣的函式，但我不干涉你怎麼做它。\n```cpp\nclass Shape {\npublic:\n\tvirtual void draw() const = 0;\n};\n```\n\n不過，我們其實可以為 Pure Virtual Function 提供一份實作碼，只是需要通過 Class Name 呼叫 (以 `Shape::draw` 而非 `shape.draw` 呼叫)，這樣既可以提供一份預設內容，又可以強制 Derived class 要自行實作 (自行 call `Shape::draw`)。\n\n而對於 `Shape` ，它擁有一個 pure virtual function，也就是說它自身永遠不可能被實例化。即使提供實作，也不能直接由 `ps-\u003edraw()` 這樣調用。\n\n```cpp\nShape *ps = new Shape; // error! Shape is abstract\n\nShape *ps1 = new Rectangle; // fine\nps1-\u003edraw(); // calls Rectangle::draw\nps1-\u003eShape::draw(); // calls Shape::draw\n```\n","lastmodified":"2023-09-05T15:34:45.962894855Z","tags":["empty"]},"/notes/Project/Effective-C++-Series/Singleton":{"title":"Singleton","content":"","lastmodified":"2023-09-05T15:34:45.962894855Z","tags":["empty"]},"/notes/Project/Effective-C++-Series/Smart-Pointer":{"title":"Smart Pointer","content":"\n在[[為多型用途的基礎類別宣告 virtual 解構式]]文章中的 `TimeKeeper` 例子，我們提及了工廠函式 (factory function)，在該例子，我們把 delete `new` resource 的責任交給 Client。\n\n然而有很多情況--例如 main flow 中過早的 return，resource 可能沒有成功被銷毀。善用 Pointer-like 物件，並把銷毀資源的操作**確實**的寫在 Destructor 中可以避免這些問題。\n\nSmart Pointer 的原理是利用一個 object 去 own (or manage, 管理) 一個 heap-based 的資源，當 Smart Pointer Object 脫離 Scope，Compiler 試圖去 destructor 時，藉機呼叫手上 Object 的 destructor。\n\n## Smart Pointer 當中的顯式與隱式轉換\n1. Smart Pointer 的 `get` function 是一種顯式轉換 (explicit)，允許 client 取得原始物件的原始型別指標。\n2. Smart Pointer Override 了 `operation*` 和 `operator-\u003e`，因此 client 端可以直接對它做指標操作，有如對待 raw pointer，這隱含的是隱式轉換 (implicit)\n\n## 顯式/隱式轉換介面\n如上述， `get` function 是一種顯式轉換 (explicit)，它的優點是使用時意圖清楚，缺點是很醜。\n其實，亦可以提供個隱式轉換的介面，如此當這個物件被放到 base resource 的類別時，就不用特別透過 `get` 提取 base resource，缺點是會提升發生錯誤的風險。\n\n選擇何種，取決於使用情境，記住 [[讓介面易於被使用，不易誤用]]，不要讓你的介面容易被誤用，即可。","lastmodified":"2023-09-05T15:34:45.962894855Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/Static-Object":{"title":"Static Object","content":"\n\u003e 壽命從被建構出來，持續到程式結束為止。\n\n因此 Stack 和 Heap-based 物件都不是 static object。\n這種物件包含 Global Object，定義在 Namespace Scope 的物件，Class \u0026 Function \u0026 File 內宣告成 `static` 的物件。\n- Function 內的 static object 稱為 local static object (Scope 只在 function 內)\n- 其他被稱為 non-local static object\n它們的 deconstructor 會在 main 結束時被喚起。\n\n當我們有兩個編譯單元 ([[Translation Unit]])，通常表示兩份 Source Code。兩份 Source Code 中都有 non-local static object，且其中一份 static object 的初始化需要使用到另一份 source code 的 static object。\n\n問題在於，有可能要被使用的那個物件尚未被初始化! \n\u003e C++ 對於不同 [[Translation Unit]] 中 non-local Static object 初始化的順序並沒有明確的定義。\n\u003e The relative order of initialization of non-local static objects defined in different translation units is undefined.\n\n這是有原因的，因為決定這個順序非常困難，近乎無解，甚至不值得去找解。\n\n這種問題常見於[[Implicit TemplateInstantiation]] 模板隱式具現化。 (? 不確定翻譯)\n\n## Make Non-local Static Object become Local Static Object\n\n\u003e C++ 保證，函式內的 Local static object 會在該函式被呼叫期間，首次遇到該物件的定義式時初始化。\n\n我們可以利用此原則，解決 dependency of 2 non-local static object in 2 different translated units 的問題。\n\n\u003e 將每個 non-local static object 搬到專屬的 function 內，以 local static object 的方式存在。Design Pattern 中的 [[Singleton]] 就式常見的實作方式。\n\n其原理在於，所以比起直接呼叫 non-local static object，使用 function call 的做法更佳。更棒的是，若你從未呼叫「模擬該 non-local static object 的 function」，則 「那個 object 」根本**不會初始化**，有延遲初始化的功效在! 這是真正的 non-local static object 所不能及的。\n\n`static` 可以確保唯一性，Singleton 本身就常常與 Static 搭配使用。\n\n```cpp\nclass FileSystem { ... };\n\nFileSystem\u0026 tfs()\n{\n    static FileSystem fs;\n    return fs;\n}\n\nclass Directory { ... };\nDirectory::Directory( params )\n{\n    std::size_t disks = tfs().numDisks();\n}  \n\n// The first call function.\nDirectory\u0026 tempDir()\n{\n    static Directory td( params );\n    return td;\n}\n```\n此種手法稱為 reference-returning。\n\n在此例子中，`tmpDir` 創建物件 `td`，在 call `Directory` Constructor 時，會再 call `tfs` ，此時才創建 static object `fs`。透過 function call，確保了物件初始化的順序，先初始化 `fs`，再創建 `td`。\n\n### 優點\n特別在頻繁呼叫的時候，搭配 [[了解 Inline 的裡裡外外]]。\n\n### 缺點\n在 multi-thread 中有不確定性。任何一種 non-const static 物件如果**依賴於其他事件的發生**，都很麻煩。常見的解決方法是，在 single-threaded startup portion 手動喚起所有 reference-returning function，手動解決 race conditions。\n","lastmodified":"2023-09-05T15:34:45.962894855Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/Swap-and-pimpl":{"title":"Swap and pimpl","content":"\n## std::swap\nSTL 的 swap 平凡無奇，涉及了三次的複製。\n```cpp\nnamespace std {\n    template\u003ctypename T\u003e\n    void swap (T\u0026 a, T\u0026 b) {\n        T tmp(a);\n        a = b;\n        b = tmp;\n    }\n}\n```\n\n但對於「某些型別」而言，他們滿足某些資格。因為有這種前提，`std::swap` 的標準做法(三次複製)是多餘的，他們有更快的解法。\n\n「以指標指向一個物件，那個物件含有真正的資料」的型別，就是那些特殊的、滿足資格的傢伙。常見的手法是 [[pimpl idiom (pointer to implementation)]] ，Pattern 如下: \n- `Widget` 的 Copy Assignment 實際上是複製 `rhs.pImpl` 所有內容到自己的 `pImpl` 複製一份過來。\n```cpp\nclass WidgetImpl {\nprivate:\n    int a, b, c; \n    ... // a lot of data\n}\n\nclass Widget {\npublic:\n    Widget(const Widget\u0026 rhs);\n    // copy assignment: 把 WidgetImpl 的每一個內容都複製一份過來\n    Widget\u0026 operator=(const Widget\u0026 rhs) {\n        *pImpl = *(rhs.pImpl); \n    }\n\nprivate:\n    WidgetImpl* pImpl;\n}\n```\n\n當 Widget 在 swap 時 Copy Assigment 會發生足足三次! 實際上卻是 -- 只要把 `lhs.pImpl` 和 `rhs.pImpl` 兩個 Pointer 互換即可。\n\n## 實作 Swap \n首先，需要用到 [[Template Specialization]] 。我們不被允許改變 STD 空間內的東西，但我們被允許用 STD Template 製造特異化版本，當 swap 用於 `Widget` 物件時自動使用特異化版本的 function。\n\n```cpp\nnamespace std {\n\ttemplate\u003c\u003e \n\tvoid swap\u003cWidget\u003e (Widget\u0026 a, Widget\u0026 b) {\n\t// 以上兩行表示 total template specialization: 當用在 Widget 時\n\t// 用這個特異化的 function!\n\t\t\n\t\t// swap(a.pImpl, b.pImpl); // 會失敗，因為 pImpl 是 private.\n\t\ta.swap(b);\n\t}\n}\n\nclass Widget {\npublic:\n\tvoid swap(Widget\u0026 other) {\n\t\tusing std::swap; // necessary.\n\t\tswap(pImpl, other.pImpl);\n\t}\n}\n```\n\n在 `Widget::swap` 裡指定 `using std::swap` 是必要的。\n\n\u003e [!danger]\n\u003e 讀到 P111，我懷疑 C++11 之後有不同的做法，先不細看。\n\n\n## Name Lookup Rules\n","lastmodified":"2023-09-05T15:34:45.962894855Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/Template-%E5%B8%B6%E4%BE%86%E7%9A%84%E7%A8%8B%E5%BC%8F%E7%A2%BC%E8%86%A8%E8%84%B9":{"title":"Template 帶來的程式碼膨脹","content":"Template 可能導致 binary 內有重複的程式碼、資料，儘管 source code 看起來沒有重複的問題，object code 卻異常肥大。\n\n## 避免輸入類別無關的 code 帶來的程式膨脹\n跟共性與變性分析 (commonality and variability analysis)\n把程式碼中與「輸入類別有關」跟「與輸入類別無關」的部分分開。困難的是需要學習「感受」template 被具現化很多次時可能發生的「重複行為」。\n\n下面這段例子，Template 輸入參數有兩個: `T` 跟 `n` (矩陣的 size)，只要這兩個參數的組合不一樣，就會具現化一次物件。\n`sm1` 跟 `sm2` 分別是一個 \"5\\*5 矩陣\" 跟 \"10\\*10矩陣\" 物件，並且 `SquareMatrix::invert` 會被具現化**兩次**!! \n```cpp\ntemplate\u003ctypename T, std::size_t n\u003e\nclass SquareMatrix { \npublic:\n\tvoid invert(); \n};\n\nSquareMatrix\u003cdouble, 5\u003e sm1;\nsm1.invert(); // call SquareMatrix\u003cdouble, 5\u003e::invert\nSquareMatrix\u003cdouble, 10\u003e sm2;\nsm2.invert(); // call SquareMatrix\u003cdouble, 10\u003e::inver\n```\n\n解決辦法: 把 `invert` 核心部份抽出來自成一個 Template，另一個 Template 專處理不同的 size。\n下面的解決辦法有幾個看點\n1. `SquareMatrixBase` 和 `SquareMatrix` 走的是 private 繼承，表示 **不是 is a 關係**。\n2. `using SquareMatrixBase\u003cT\u003e::invert` 是為了避免[[繼承時的名稱遮掩行為]]，`SquareMatrixBase::invert` 與 `SquareMatrix::invert` 雖然 signature 不同，卻有名稱遮掩問題。\n3. `this-\u003einvert(n)`: \n\t1. [[了解如何在 Template 中指涉 Base Class 成員]] 中提到的。\n\t2. 這裡做的是隱晦的inline 呼叫，不會因為呼叫而帶來而外的成本。[[了解 Inline 的裡裡外外]]\n\n這樣一來\n- `SquareMatrixBase\u003cdouble\u003e` 只會有一份\n- `SquareMatrix\u003cdouble, 5\u003e`, `SquareMatrix\u003cdouble, 10\u003e` 各一份，但他們呼叫到的 `SquareMatrixBase\u003cdouble\u003e`  會是同一份。\n```c++\ntemplate\u003ctypename T\u003e // size-independent base class for\nclass SquareMatrixBase { // square matrices\nprotected:\n\tvoid invert(std::size_t matrixSize); // invert matrix of the given size\n};\n\ntemplate\u003ctypename T, std::size_t n\u003e\nclass SquareMatrix: private SquareMatrixBase\u003cT\u003e {\nprivate:\n\tusing SquareMatrixBase\u003cT\u003e::invert; // 因為有同名的 invert (雖然 signature 不同)\npublic:\n\tvoid invert() { this-\u003einvert(n); } // make inline call to base class\n}; // version of invert\n```\n\n## 與輸入類別相關的 code 所帶來的程式膨脹\n像是 `std::vector\u003cint\u003e`, `std::vector\u003cdouble\u003e` 勢必會造成兩個不同的 class。\n同樣的 `std::vector\u003cint*\u003e`, `std::vector\u003cdouble*\u003e` 也會，如果沒有必要生成這麼多的 class，對於 pointer type，讓操作強型別 (Strongly type pointer `T*`) 去呼叫無型別 (`void*`) 是需要的。\n\n\n\n\n\n\n","lastmodified":"2023-09-05T15:34:45.962894855Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/Template-%E7%9A%84%E7%94%A8%E9%80%94":{"title":"Template 的用途","content":"- Container Used: Template 讓 Programmer 得以建立 Type-Safe 的容器，像是 list, map, vector...\n- Generic Programming: 寫出的程式碼跟所處理的類別彼此獨立 (ex. STL 的 `for_each`, `find` 和 `merge`)\n- Template metaprogramming: 在 Compiler 內執行、並在編譯完成時停止執行的 program (the creation of programs that execute inside C++ compilers and that stop running when compilation is complete.)\n","lastmodified":"2023-09-05T15:34:45.962894855Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/Template-%E8%88%87%E9%9A%B1%E5%BC%8F%E4%BB%8B%E9%9D%A2":{"title":"Template 與隱式介面","content":"\n- 物件導向以顯式介面 (explicit interface) 和執行期多型 (runtime polymorphism) 解決問題。\n- Template 與 Generic Programming 而言，隱式介面 (implicit interface) 與編譯期多型 (compile-time) 更重要。\n\n## 多型\n|      | 物件導向  | Generic Programming  |\n|  ----  | ----  | ----  |\n| 多型  | 執行期多型 (runtime polymorphism) | 編譯期多型 (compile-time) |\n| 概念(打比方)  | 執行期間決定哪一個 virtual function 要被呼叫 | 編譯期間做 template 具象化、與函式重載決議 (function overloading resolving)| \n\n\n## 介面\n|      | 物件導向  | Generic Programming  |\n|  ----  | ----  | ----  |\n| 介面  | 顯式介面 (explicit interface) | 隱式介面 (implicit interface)    |\n| 說明  | Signature 由函式名稱、參數型別、反回型態構成，class 明確定義有哪些 function| 沒有定義明確的 signature，只要有對應的 overloading function 被呼叫即可。|\n\n### 顯式介面\n- Function Signature 由函式名稱、參數型別、反回型態構成。\n\t- 對 overloading 而言，函式名稱相同、參數型別相同、return type 不同，無法成功 overload。他們會被視為 duplicate。\n\t- 但對一個 function 而言，function name, parameter type, return type 是必須的，而 effective C++ 的作者習慣將這三組一起稱為 signature。\n- Class 會明確的定義有哪些 function，下例 `Widget` 就有 constructor, destructor, `size`, `normalize`, `swap`。並且 `Widget` 具有 virtual function，表示它有可能有 Derived class 而得以做 runtime polymorphism。\n\n```cpp\nclass Widget {\npublic:\n\tWidget();\n\tvirtual ~Widget();\n\tvirtual std::size_t size() const;\n\tvirtual void normalize();\n\tvoid swap(Widget\u0026 other);\n};\n```\n\n### 隱式介面\n再看下例的 Template function: \n```cpp\ntemplate\u003ctypename T\u003e\nvoid doProcessing(T\u0026 w)\n{\n\tif (w.size() \u003e 10 \u0026\u0026 w != someNastyWidget) { ... }\n}\n```\n乍看下，此 function 對 T 似乎有兩個要求\n1. 具有 member function `size`，且回傳一個 int type。\n2. 支援 `operator!= `，得以比較 `someNastyWidget` \n\n實際上 [[operator overloading]] 讓這兩個約束不需要\"完全\"滿足\n- 第一點\n\t- 確實，T 需要有 `size` 函式，它也可以是從 `T` 的 base class 繼承來的，都可。\n\t- 但是 return type **不一定** 需要為 int，假設 `T::size` 回傳 type `X`，只要 `(X, int)` 這樣的參數式得以呼喚起一個 `operator\u003e` 即可!\n\t- 這並非表示要有一個 `operator\u003e(X, int)`，如果 `X` 有能力透過隱式轉換成 `Y`，並且存在 `operator\u003e(Y, int)`，就足以讓此條件滿足了! \n- 第二點\n\t- 同理，只要有 `operator!=` 支援比較 T 與 type of `someNastyWidget` 就足夠了。\n\t\t- 同第一點的邏輯，最低條件需要有一個 `operator!=(X, Y)` 的函式，且 `T` 具有轉換成 `X` 的能力，type of `someNastyWidget` 具有轉換成 `Y` 的能力。\n\n現在，展開 doProcessing 的全貌\n```c++\ntemplate\u003ctypename T\u003e\nvoid doProcessing(T\u0026 w)\n{\n\tif (w.size() \u003e 10 \u0026\u0026 w != someNastyWidget) {\n\t\tT temp(w);\n\t\ttemp.normalize();\n\t\ttemp.swap(w);\n\t}\n}\n```\n\n此 template function 同樣對於 member function `normalize`, `swap`, `size`，copy constructor 有要求 -- 總之要讓那些 function 在 `T` 上有效，做甚麼轉換都行!\n\n這些加諸在 `T` 上的「隱晦的要求」，就像是一種隱式介面 -- 能執行成功就代表這個 T 具有這些介面。而被傳入的 `T` 是否具有這些介面，在編譯期間就會檢查。\n\n就像我們無法對顯示介面的 class 呼叫一些不存在的 function 一樣，呼叫了不存在於顯式介面上的函式將無法通過編譯，無法滿足隱式介面的程式也同樣無法通過編譯。\n\n\n","lastmodified":"2023-09-05T15:34:45.962894855Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/Template-Method":{"title":"Template Method","content":"","lastmodified":"2023-09-05T15:34:45.962894855Z","tags":["empty"]},"/notes/Project/Effective-C++-Series/Template-ParamType-deduction":{"title":"Template ParamType deduction","content":"\n\u003e `T` is a part of ParamType when it declared in template.\n\n- Case1. [[ParamType 是 Pointer 或 Reference 但不是 Universal Reference]]\n- Case2. [[ParamType 是 Universal Reference]]\n- Case3. [[ParamType 非 Reference 或 Pointer]]\n- Case4. [[Array As an Argument]]\n- Case5. [[Function As an Argument]]\n\n## Conclusion\n\n1. 當 Argument 是有 Reference 時，其 Reference-ness (`\u0026`) 會被忽略\n2. Universal Reference 在收到 lvalue argument 走的程序是特別的。\n3. 做 Pass by value (Copy) 時，常數性(constness) 會消失\n4. Function name \u0026 array name Argument 會 decay 成 Pointer 進行 template deduction，除非該 template 的 parameter type 是宣告成 Reference。\n\n","lastmodified":"2023-09-05T15:34:45.962894855Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/Template-Specialization":{"title":"Template Specialization","content":"\nTemplate 可以針對特定的 Type 特化，寫法如下\n1. `template\u003c\u003e` 裡面不放任何參數，表示這不是 template 也不是標準的 class，是一個特化的 `MsgSender`。\n2. `class MsgSender\u003cCompanyZ\u003e` 表示  template `MsgSender` 在遇到 input type 是 `CompanyZ` 的時候，要用以下定義的內容。\n以下這段範例就是 `MsgSender` 針對 `CompanyZ` 特別訂製的內容，這就是模板全特化 (Total Template Specialization)。\n\n```c++\ntemplate\u003c\u003e // a total specialization of\nclass MsgSender\u003cCompanyZ\u003e { // MsgSender; the same as the\npublic: // general template, except sendClear is omitted\nvoid sendSecret(const MsgInfo\u0026 info)\n{ ... }\n};\n```\n此例呼應 [[了解如何在 Template 中指涉 Base Class 成員]] 的範例，`MsgSender` 對於一般輸入類別都有 `sendSecret` 跟 `sendClear` 兩個 function。但在這裡，`CompanyZ` 的特化版將不存在 `sendClear`! \n\n## Template Specialiaztion 與 Declaration\n雖然 Template 多習慣把實作寫在 hpp，若將 Template Specialiaztion 實作寫在 hpp 卻可能發生問題。\n假設有三個檔案，`temp.hpp` 寫著 template 與 Template Specialiaztion 的實作，兩個 cpp: `a.cpp` 與 `b.cpp` 分別 include  temp.hpp，基於 [[One Definition Rule]]，這會引發 multiple definition (見 [multiple definition of template specialization when using different objects](https://stackoverflow.com/questions/4445654/multiple-definition-of-template-specialization-when-using-different-objects))。\n\n解決方法有兩種\n1. 宣告 Template Specialiaztion 於 hpp，實作放在 cpp\n2. 一樣把實作放在 hpp，但是多宣告 inline 於 Template Specialiaztion 的實作上。\n\n### 分離 Template Specialiaztion 實作\n\ntemp.hpp: \n```cpp\ntemplate\u003ctypename T\u003e void func(T\u0026 val);\ntemplate\u003c\u003e void func\u003cint\u003e(int\u0026 val); // Specialiaztion\n```\n\ntemp.cpp\n```cpp\ntemplate\u003c\u003e void func\u003cint\u003e(int\u0026 ) {}\n```\n\n### 對 Template Specialiaztion 的實作宣告 inline \n\n這其實相當有趣，因為 function 是否 inline 取決於 compiler，即使宣告 inline 也不一定代表 compiler 會真的對 function inline  ([[了解 Inline 的裡裡外外]])。\n那麼為何在 hpp 內對  Template Specialiaztion definition 宣告 inline 能解決問題?  [Stackoverflow 的回答](https://stackoverflow.com/a/48403514) 給出了解答。\n\n根據  C++ standard 條目 3.2:4 ([file](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3690.pdf) P49 One definition rule)，可以拆成兩段來看: \n\u003e (1) Every program shall contain exactly one definition of every non-inline function or variable that is odr-used in that program; no diagnostic required. The definition can appear explicitly in the program, it can be found in the standard or a user-defined library, or (when appropriate) it is implicitly defined (see 12.1, 12.4 and 12.8). \n\u003e (2) An inline function shall be defined in every translation unit in which it is [[ODR use]].\n\n\n\n當 Specialiaztion 不是 inline 的時候，它被當作 non inline function 對待，而對於 non inline function/variable，在 program 中只應該擁有一份 definition。因此兩次 include 同一份 header 造成了問題: 多個 definition (include 的本質就是把 hpp 貼到 cpp 裡面)。\n\n當 Specialiaztion 是 inline 的時候，Specialiaztion 滿足了條目的第二部分: inline function 必須被定義於每一個使用到的 translation unit，也就是該則回答裡面提到的 : \n\n\u003e an inline function must be defined in each module using the function.\n\n這或許也可以反向說明，在 [[了解 Inline 的裡裡外外]] 環節中提到的，只有 hpp 中含有實作的 function 可以有隱性 inline 申請，因為想要 inline 一個 function，在編譯期間，每一個使用到這個 function 的 translate unit 都需要有這個 function。當實作抽離，這個條件就沒辦法達成。\n\n\n There can be more than one definition of a template specialization for which *some template parameters are not specified (14.7, 14.5.5) in a program* provided that each definition appears in a different translation unit\n\nWhen the parameterized function is not specialized it is covered by clause 3.2:6:\n\n\u003e There can be more than one definition of a class type (Clause 9), enumeration type (7.2), inline function with external linkage (7.1.2), class template (Clause 14), non-static function template (14.5.6), static data member of a class template (14.5.1.3), member function of a class template (14.5.1.1), or template specialization for which some template parameters are not specified (14.7, 14.5.5) in a program provided that each definition appears in a different translation unit\n\nThis clause states that it is OK for multiple definitions of the same template function as long as at least one of the template parameters is not specified in the code. This is to allow the decision on whether the parameterized function should be instantiated in a module to be made on local information only.\n\n[Example ORD](https://wiki.sei.cmu.edu/confluence/display/cplusplus/DCL60-CPP.+Obey+the+one-definition+rule)\nhttps://en.cppreference.com/w/cpp/language/definition","lastmodified":"2023-09-05T15:34:45.962894855Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/Template-and-Generic-Programming":{"title":"Template and Generic Programming","content":"\n本文中要透過 [[Member Function Template]] (成員函式模板) 完成一個泛化的 copy constructor。\n\n---\n\n這段範例的意思是，對於 `SmartPtr\u003cT\u003e` 存在一個由 `SmartPtr\u003cU\u003e` 建構的管道 (透過 Copy Constructor)。\n這邊的型別轉換沒有標示為 `explicit`，一旦標示為 `explicit`，就需要明白寫出轉型 (cast) 動作。\n使用隱式轉換式因為 raw pointer 本來就支援隱式轉換，仿效相同模式，`SmartPtr` 也使用隱式轉換。\n\n```cpp\ntemplate\u003ctypename T\u003e\nclass SmartPtr {\npublic:\n\ttemplate\u003ctypename U\u003e // member template \n\tSmartPtr(const SmartPtr\u003cU\u003e\u0026 other); // for a ”generalized copy constructor”\n}\n```\n\n現在，不同的 `SmartPtr` 具現體 (instantiations, 具現化的類別) 之間可以自由轉換了，但像是 Top -\u003e Bottom 這種違反繼承規則的不合法的轉換，沒有被禁止! \n\n我們可以在 copy constructor 中加一些約束條件，避免這種不合法轉換。參考 share pointer 的作法，首先提供一個 `get` 的 public function 讓 raw pointer (`T*`) 得以被取得，這樣在 copy constructor 處理 rhs 的時候，才有辦法取得 `U*` pointer。\n接著，在 Member initialization list 當中，把 `U* ptr` 傳給內部的 `T* heldPtr`。若繼承關係不合法，則這個 Raw pointer 之間的 copy 行為就會發生問題，而無法通過編譯!!\n\n```cpp\ntemplate\u003ctypename T\u003e\nclass SmartPtr {\n\npublic:\n\ttemplate\u003ctypename U\u003e\n\tSmartPtr(const SmartPtr\u003cU\u003e\u0026 other) // initialize this held ptr\n\t: heldPtr(other.get()) { ... } // with other’s held ptr\n\tT* get() const { return heldPtr; }\n\nprivate: // built-in pointer held\n\tT *heldPtr; // by the SmartPtr\n};\n\n```","lastmodified":"2023-09-05T15:34:45.962894855Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/The-definition-and-declaration-of-static-const":{"title":"The definition and declaration of static const","content":"\u003e [!todo]\n\u003e P14\n\n\n","lastmodified":"2023-09-05T15:34:45.962894855Z","tags":["empty"]},"/notes/Project/Effective-C++-Series/Translation-Unit":{"title":"Translation Unit","content":"\n\u003e A translation unit is the source code giving rise to a single object file. It's basically a single source file, plus all of its `#include` files.\n\n編譯單元指: 產出單一目的檔 (single object file) 的那些 source code，通常是 source code + included header file.","lastmodified":"2023-09-05T15:34:45.962894855Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/Virtual-Base-Class":{"title":"Virtual Base Class","content":"\n\u003e 讓鑽石繼承中，帶有該資料的 Base Class 成為 virtual base class。\n\n此例中就是 `File` 要成為 virtual base class，`InputFile` \u0026 `OutputFile` 在繼承 `File` 時要加上 `virtual`。\n![[Item40_VBC.png]]\nC++ STL 裡面有一個這樣的體系，只是他們是 class template 上的繼承關係 (basic_ios, basic_istream, basic_ostream, basic_iostream)。\n\n## 代價\n\nPublic 繼承應該總是為 virtual public 嗎?  virtual 有代價\n- 存取 virtual base class member data 會比 non-virtual class member data 慢。\n- virtual base class 初始化規則複雜、不直觀的多。\n\n## virtual base class 的初始化\n由最底層 (most derived class ) 負責\n1. most derived class 需要認知到 virtual base class 在哪，它可能很遙遠\n2. 一但有新的 derived class 被加入，責任將拋到它身上。\n\n### 忠告\n1. 不輕易使用 virtual base class \n2. 如果必須使用，避免在裡面放資料，這樣就不需要擔心初始化與賦值帶來的問題了。\n","lastmodified":"2023-09-05T15:34:45.962894855Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/Virtual-Function":{"title":"Virtual Function","content":"\n## 在 Ctor / Dtor 呼叫 virtual function\n![[Itm10_TranscationUML.png]]\n\n在這裡，Transcation 的 Constructor 呼叫的會是 `Transcation::logTranscation`。\n又，該 function 為 Pure virtual function，若它沒被定義，則當編譯器呼叫時會引發錯誤，而若有.... 就會 Link 到該 base class function。\nRelated: [[區分介面繼承(interface)和實作繼承(implement)]]\n\n一個不正式的講法: Base Calss 建構期間，所呼叫的 virtual function 不是 virtual function。  \n\n\u003e [!important] \n\u003e 在 Drived Class Object 執行 Based Class Constructor 期間，物件的型別實際上是 Base Class。\n\n這是根本的原因，由於在 Based Class Constructor 物件是 Base Class，呼叫 Base Class 的 function 也是自然的事。\n不只是 virtual function 會被決議(resolve to) 至 Base Class，如果使用 `dynamic_cast` (Runtime type infomation)，也會把物件視為 Base Class! [[少做轉型動作(Minimize casting)]]\n\n相同的問題也存在於 Destructor，在 Destructor 中 Drived Class 的部分會先被消滅，一旦進入 Base Class Destructor ，C++ 就會看待它為一個 Base Class。\n\n## 以傳遞參數給 non-virtual function，取代使用 Virtual function\n將 virtual function 從 con/desturctor 中移除! 說來容易，卻不易察覺。Constructor 可能 call 別的 function，而 virtual 可能藏身在其中! 並且，很難確保 Child Class 也會服從這項規定。\n\n替代方案是，使用 non-virtual function，把 Log 以 string 的方式傳給 Base Class 的 non-virtual Log function。\n","lastmodified":"2023-09-05T15:34:45.962894855Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/enum-hack":{"title":"enum hack","content":"","lastmodified":"2023-09-05T15:34:45.962894855Z","tags":["empty"]},"/notes/Project/Effective-C++-Series/non-member-non-friend-function":{"title":"non-member \u0026\u0026 non-friend function","content":"[[Non-member \u0026\u0026 Non-friend Function 的封裝度優於 Member Function]]","lastmodified":"2023-09-05T15:34:45.962894855Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/operator-overloading":{"title":"operator overloading","content":"","lastmodified":"2023-09-05T15:34:45.962894855Z","tags":["empty"]},"/notes/Project/Effective-C++-Series/override":{"title":"override","content":"","lastmodified":"2023-09-05T15:34:45.962894855Z","tags":["empty","cpp11"]},"/notes/Project/Effective-C++-Series/pimpl-idiom-pointer-to-implementation":{"title":"pimpl idiom (pointer to implementation)","content":"\u003e 將物件的實作細目隱藏在一個指標背後\n\n## 第一種手法: Handle Class\n\n此手法會把一個類別分成兩個 Class: \n- 一個是暴露給客戶端的接口 Handle Class (ex. `Person`)，它只會擁有一個 pointer 指向實作 class\n- 一個是實作類別 Implementation Class (ex. `Personimpl`) ，所有真正要存的資料都在這裡面。\n\n由於接口 `Person` 只 own 一個 smart pointer ，它不需要知道 `PersonImpl` 有多大，因此可以用 forward declare 解決。它還提供了一些 getter，但提供 getter 也都可以透過 forward declare 解決一切。\n\n客戶端在 `include person.hpp` 時，只會跟著 include 到 string 和 memory 兩個 header file 而已。至此，`PersonImpl` 做了什麼更動，直接跟客戶端脫鉤。\n\n\n```cpp\n#include \u003cstring\u003e // standard library components shouldn’t be forward-declared\n#include \u003cmemory\u003e // for tr1::shared_ptr; see below\nclass PersonImpl; // forward decl of Person impl. class\nclass Date; // forward decls of classes used in\nclass Address; // Person interface\nclass Person {\npublic:\n\tPerson(const std::string\u0026 name, const Date\u0026 birthday,\n\tconst Address\u0026 addr);\n\tstd::string name() const;\n\tstd::string birthDate() const;\n\tstd::string address() const;\n\t...\nprivate: // ptr to implementation;\n\tstd::tr1::shared_ptr\u003cPersonImpl\u003e pImpl; // 這是唯一的 member data\n}; // std::tr1::shared_ptr\n```\n\n[[編譯依存-宣告式、定義式與實作細節]]\n\n### 實作檔案 (CPP)\n實作檔案需要同時 include `Person.hpp` 和 `PersonImpl.hpp`\n-  `Person.hpp` : 為了實作 `Person`的 function\n-  `PersonImpl.hpp`: 才能 Call `PersonImpl` 的 function。\n\n```cpp\n#include \"Person.h\" \n#include \"PersonImpl.h\" \nPerson::Person(const std::string\u0026 name, const Date\u0026 birthday,\nconst Address\u0026 addr)\n: pImpl(new PersonImpl(name, birthday, addr))\n{}\nstd::string Person::name() const\n{\nreturn pImpl-\u003ename();\n}\n```\n\n\n## 第二種手法: Interface Class 的設計方式\n暴露給客戶的是 Interface Class，這個類別本身會設計成一個 abstract base class (interface class)。[[區分介面繼承(interface)和實作繼承(implement)]]\n\n### Interface Class: 暴露給 Client 的接口\nInterface class 的用途是僅有敘述 drived class 的介面，它沒有 member data、也沒有 constructor，只有一個 virtual destructor，跟一堆 [[Pure Virtual Function]] 來敘述介面。而 drived class 就是它的實作 (相當於前面 implement class 的腳色)\n```cpp\nclass Person {\npublic:\n\tvirtual ~Person();\n\tvirtual std::string name() const = 0;\n\tvirtual std::string birthDate() const = 0;\n\tvirtual std::string address() const = 0;\n...\n};\n```\n\n我們暴露給 Client 端的是 Interface class，Interface calss 是 abstract class，然而， **abstract class 不能被具象化**。因此，用此方法設計時，需要在  interface class 裡面提供一個「讓 client 端獲取物件」的特殊方法。\n\n這個特殊方法通常稱為 [[工廠函式 (Factory Function)]]，它們會回傳一個 interface class pointer，卻指向動態配置(被 `new` 出來) 的 derived class 物件。這種函式在 interface class 內往往宣告為 `static`。如下例的 `create`: \n\n```cpp\nclass Person {\npublic:\n...\nstatic std::tr1::shared_ptr\u003cPerson\u003e \ncreate(const std::string\u0026 name, // Person initialized with the\n\t\tconst Date\u0026 birthday, // given params; see Item 18 for\n\t\tconst Address\u0026 addr); // why a tr1::shared_ptr is returned ...\n};\n```\n\n### Concrete Class: 相對於 Interface Class 的對應實作\nInterface Class 所對應的實作類別會是一個具象類 (concrete class)，它必須擁有真正的 constructor。假設這個實作類別是 `RealPerson`: \n\n```cpp\nclass RealPerson: public Person {\npublic:\n\tRealPerson(const std::string\u0026 name, const Date\u0026 birthday,\n\tconst Address\u0026 addr)\n\t: theName(name), theBirthDate(birthday), theAddress(addr)\n\t{}\n\tvirtual ~RealPerson() {}\n\tstd::string name() const; // implementations of these \n\tstd::string birthDate() const; // functions are not shown, but \n\tstd::string address() const; // they are easy to imagine\nprivate:\n\tstd::string theName;\n\tDate theBirthDate;\n\tAddress theAddress;\n};\n```\n\n現在知道 `RealPerson` 的 constructor 長相，回頭 `Person::create` 的實作也是輕而易舉: \n```cpp\nstd::tr1::shared_ptr\u003cPerson\u003e Person::create(const std::string\u0026 name,\nconst Date\u0026 birthday, const Address\u0026 addr)\n{\n\treturn std::tr1::shared_ptr\u003cPerson\u003e( \n\t\t\tnew RealPerson( name, birthday, addr));\n}\n```\n\n## pimpl 手法的成本\n以上說明了兩種花俏的手法，它能降低耦合，減少編譯時間。成本呢?\n\n### Handle Class 的成本\n1. 每次對 Handle class 取值都是間接取值: handle class 需要跟 impl pointer 取得資料。\n2. 與不用 pimpl pattern 手法想比 (不去耦合)，每增加一個 handle class 物件，就會增加一個 impl pointer 的大小 (通常以 smart pointer 存)。\n3. impl object 是以動態記憶體配置 (`new`)，承受動態記憶體配置與釋放的成本，也有可能遇到 `bad_alloc` (記憶體不足)。\n### Interface Class 的成本\n1. Interface Class 每個函式都是 virtual function，每次的函式呼叫都要付出間接跳躍 (indirect jump) 的成本。見: [[為多型用途的基礎類別宣告 virtual 解構式]]\n2. 只要有 virtual function，就會有 vptr (virtual table pointer)，其成本參見:  [[不要為非多型用途的 Base Class 宣告 Virtual Function]]\n\n### 提醒\n不論 handle class 或 interface class，一旦脫離 inline 函式都無法有太大的作為(why? 不過就是都要在 class 定義式中直接把實作寫完的意思)。因為這類 class 是為了隱藏實作細節或函式本體的!! [[了解 Inline 的裡裡外外#向 Compiler 發出申請]]\n\n\n## 該使用 pimpl 嗎?\n- 當以上提及的速度成本或大小問題，使得類別的耦合問題相形之下不怎麼嚴重時，就應該直接用具象類別 (concrete class) 取代 pimpl 手法。\n","lastmodified":"2023-09-05T15:34:45.962894855Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/typedef-and-using":{"title":"typedef and using","content":"","lastmodified":"2023-09-05T15:34:45.962894855Z","tags":["empty","modern"]},"/notes/Resource/Books/The-Second-Brain":{"title":"打造第二大腦","content":"\u003e 成為一個「能傳達資訊、且具有出色詮釋能力」的人! \n\n- Key Feature In this sentence:\n\t- Can construct infomation\n\t- Can express info effectively\n\n## CODE \n\n### C (Capture)\n\u003e 將資訊蒐集在沒有雜訊的地方，你可以心無旁騖地找到它。\n\n- 即使只是看一眼收藏，也要慎選收藏的地方。\n- 不好的地方: 個人信箱、FB 的收藏 (很容易被社群吸走) ...\n- 適合的地方: 屬於自己的聊天室 (Line keep)\n\n### O (Orgnize)\n\u003e 以 Project 分類 ，不要以類別分類。\n\n- 淺台詞: 以目的導向分類。ex. 「專注力協議」的書摘應該放在「成為心無旁鶩的人」而不是「心理學」。\n- 像是歸類在「心理學」、或是「工作生產力」這種圖書館式的分類，你不分看標題也知道它是哪一類，不需要做無意義的分類。\n- 放在「成為心無旁鶩的人」，點進去這個目標，此書摘就會快速地浮現上來，告訴你快使用它! \n- 知識必須用到才有用! \n\n### D (Distill, 萃取)\n\u003e 用 Bullet Point 告訴未來的你，這篇筆記在說什麼?\n\n- 4 個層次的萃取，每一次萃取約保留 10~20% 的訊息量。\n- 萃取的時機很重要，無效的萃取反而遺失重要訊息。\n- How to partice? Distill the note when read it once time.\n\n### E (Express, 表達)\n\u003e Any way. Deliver it, and share! \n\n\n## 釐清目標: 你想解決什麼問題?\n\u003e Which problems do you want to resovle by The Second Brain? \n\n**費曼: 12道難題**\n它應該具有轉移性，核心精神不變，但領域可能改變的特質。記得這些你的目標，當資訊流過你身邊時，驗證他們是否能幫助你解決這些難題? If true, Capture it! \n\nMy current thinking: \n1. How to improve poor english?\n2. How to spend time \u0026 learning effectively?\n3. How to take effective note?\n4. How to debug (gdb) effective?\n\n## Capture: What Info Can put into Your Second Brain?\n\n- 摘要! 通常不應超過原資訊量的 1/10\n- 具有啟發性的，改變你的想法的 (不懂 太抽象)\n- 在未來可以被使用的 (ex. How to own a project? How to leader a team?)\n- 跟你自身相關的: 珍貴的，你想永久記憶的回憶。\n- 相反、不同觀點的: 避免佐證偏差 (confirmation bias)，可以使你跳脫當前認知的。\n\n\u003e 記住，重新消化過的資訊更好吸收! \n\n## Organize: Where Do the Info Put?\n\n不使用圖書館式的分類法，作者提出 PARA 方法，可以看出重要程度依序遞減。人的注意力有限，請第一眼，就看到最可能幫助你的資料。\n\n\u003e 讓最重要的任務、最短期的目標的相關資料上，沒有過多的雜訊\n\nP (Project): 短期任務\n- Working project\n- Personal project (ex. blog), side project, 減重... \n\n\nA (Area): 長期任務，長期想掌握的目標\n- 健康，不同於 project 中的「減重」是明確目標、是達成健康的手段，健康是長期目標。\n\nR (Resource): 未來有用處的\n- 有興趣的東西、嗜好: 精油、咖啡\n- 研究的可提: effective\n- 有用的參考: travel plan\n\nA (Archive): 備而不用\n- 不再有興趣的\n\n\n\n## Distill 萃取\n\n- 不要花相同的時間，處理相同的原始資料\n- 摘要! 用簡短的 bullet point 列出重點。\n- 誤區: 當不能了解其用處時，不應強行消化，否則重點非重點。\n\n\u003e My opinion: 每調閱它、閱讀一次，就萃取一次。\n\n### 參考方法: 4 個層次萃取\n\n每個步驟間應保留約 10~20% 的資料量，否則 brief isn't brief.\n1. 擷取段落\n2. 粗體字\n3. 螢光筆 highlight\n4.  bullet point \n\n### 以會議筆記舉例\n\n1. 列出所有討論出來，需要做的 (need to do)\n2. 劃出重點項目、關鍵字\n3. 簡短列出: 如何執行 (execute)\n\n## Express 表達\n\n### 哲學思辨: 如何騰出專注力，卻不消耗專注力?\n\u003e 使用中間產物\n\nProject 自起點到終點(成品)，有許多中間產物，例如: 草稿、大綱、顧客回覆。收集這些資料，放進第二大腦，達到重複使用! \n\n### 中間產物\n1. Note\n2. 不使用的 Proposal \n\t1. 以及檢討，為何不使用。可能是有重大缺陷，需要避免以後踩到。\n3. 半成品??? \n4. 團隊的文件，這相當於他人的經驗\n\n\n### 切分「一件事」\n一件事有很多碎片，如果你是從零開始，可以把完成這件事需要那些碎片寫下來，並把你花費專注力 build 好的碎片存起來，讓這些碎片可以 Re-use。\n\n同時，你在從零建構碎片時，也可以吸取別人的經驗，Reuse 別人的碎片! \n\n\n\n\n## Resource\n- Author's website: https://www.buildingasecondbrain.com/resources\n- Obsidian As a Second Brain: https://www.youtube.com/watch?v=nz99I7apNLI\u0026list=WL\u0026index=2\n- Should Logseq be Your Second Brain? https://www.youtube.com/watch?v=VJ2reQcpbYA\u0026list=WL\u0026index=3\n- Pick a Notes App: Your Notetaking Style (Part 1) https://www.youtube.com/watch?v=f3dDVtJ2sec\u0026list=WL\u0026index=4\n","lastmodified":"2023-09-05T15:34:45.966894908Z","tags":[]},"/notes/Resource/MOCs/C++-Resources":{"title":"C++ Resources","content":"\n## Notes\n- [[../../Project/Effective C++ Series/Effective C++ Outline |Effective C++ Outline]]\n- [[../../Project/Effective C++ Series/Effective modern C++ Outline|Effective modern C++ Outline]]\n\n## Webs\n- [CppCoreGuidelines](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines)\n- [CppDeveloperRoadmap](https://github.com/salmer/CppDeveloperRoadmap)\n- [整理了一份C++学习路线图](- https://mp.weixin.qq.com/s/poq9aDdEL5kLM5sjSqJ72A)\n- \n\n## Books\n- C++標準庫：學習教本與參考工具（第二版） 作者： Nicolai M. Josuttis 譯者： 侯捷\n\t- 內容涵蓋 C++11 的 STL Lib.\n\t- https://www.books.com.tw/products/0010658042?sloc=main\n\n\n## Online Resource\n- [IT 碼農](https://tanqingbo.cn/CSBook001/#C)\n- [碼農之家](https://www.xz577.com/)\n- [搬書匠](http://www.banshujiang.cn/)\n","lastmodified":"2023-09-05T15:34:45.966894908Z","tags":["cpp","moc"]},"/notes/Resource/MOCs/Design-Pattern":{"title":"Design Pattern","content":"\n[[../../Project/Effective C++ Series/Template Method|Template Method]]\n[[../../Project/Effective C++ Series/Classic Strategy Pattern|Classic Strategy Pattern]]","lastmodified":"2023-09-05T15:34:45.966894908Z","tags":["moc"]},"/notes/Resource/Whisky/%E6%A0%BC%E8%98%AD%E5%82%91-%E5%96%AE%E4%B8%80%E9%BA%A5%E8%8A%BD%E5%A8%81%E5%A3%AB%E5%BF%8C":{"title":"格蘭傑-單一麥芽威士忌","content":"Glenmorangie X Single Malt Scotch Whisky\n\n- 買於好事多，跟 \"知多\" 喝起來差不多，CP 值極佳!! \n- 理想價格: 600-650\n\n","lastmodified":"2023-09-05T15:34:45.966894908Z","tags":[]},"/notes/Resource/Whisky/%E9%A1%98%E6%9C%9B%E6%B8%85%E5%96%AE":{"title":"威士忌的願望清單","content":"\n## 待過濾\n- [五支波本威士忌推薦文](https://medium.com/need-a-drink/%E5%8F%AA%E9%9C%80%E4%BA%94%E7%93%B6-%E6%B3%A2%E6%9C%AC-%E5%A8%81%E5%A3%AB%E5%BF%8C-%E7%BE%8E%E5%8F%B0%E5%8F%8B%E5%A5%BD-%E6%8E%A8%E8%96%A6%E6%B8%85%E5%96%AE-my-only-5-bourbon-whisky-i-need-112ff911ffbe)\n\n","lastmodified":"2023-09-05T15:34:45.966894908Z","tags":[]}}