{"/":{"title":"🪴 Main Page","content":"\n## 近期閱讀\n\n- [[notes/Longtern/Books/The Second Brain]]\n\n\n## 文章引導\n\n- [[notes]]\n- [[tags]]\n- [[notes/Focus/C++/Effective C++ Outline]]\n- [[notes/Focus/C++/C++ Core Guidelines]]\n- [[notes/Focus/C++/The C++ STL Outline]]\n","lastmodified":"2024-02-23T05:15:51.402099014Z","tags":[]},"/notes/Focus/C++/%E4%B8%8D%E8%A6%81%E7%82%BA%E9%9D%9E%E5%A4%9A%E5%9E%8B%E7%94%A8%E9%80%94%E7%9A%84-Base-Class-%E5%AE%A3%E5%91%8A-Virtual-Function":{"title":"不要為非多型用途的 Base Class 宣告 Virtual Function","content":"\n\u003e 無端將不該擁有 `virtual` 的 class 宣告 virtual，與無端將所有的 function 宣告成 virtual，都是有毒的。 \n\n當類別不作為 Base Class，或是不作為多型時的基本 Class 時，不應該使用 virtual。\n原因是，`virtual` 背後是以 vptr (virtual table pointer) 和 vtbl (virtual table) 實作 virtual，需要耗費額外的記憶體。\n1. 將不能把資料結構式傳給其他語言 (C, FORTRAN) 撰寫的 function，因為它們沒有 vptr 的對應內容\n2. 增加物件大小，書中舉例一個 `Point` 物件，其中擁有兩個 int (64bits, in 32 bits system)，增加一個 `virtual` (一個 vptr) 將使 memory 達到 96 bits，相當其物件大小的 50%，在 64bits system 甚至達到增加 100%。\n","lastmodified":"2024-02-23T05:15:51.43809902Z","tags":["cpp"]},"/notes/Focus/C++/%E4%BA%86%E8%A7%A3%E5%A6%82%E4%BD%95%E5%9C%A8-Template-%E4%B8%AD%E6%8C%87%E6%B6%89-Base-Class-%E6%88%90%E5%93%A1":{"title":"了解如何在 Template 中指涉 Base Class 成員","content":"\n考量以下的類別關係，`Company` classes 會作為 template 的輸入參數傳入 MsgSender 體系的 Template。\n`LoggingMsgSender` 在繼承 `MsgSender` 的時候，刻意為新的 function 取 `sendClearMsg` ，不同於 Base class `sendClear`，這是好的做法，避免了 [[繼承時的名稱遮掩行為]] 以及遵守 [[絕不重新定義繼承來的 Non-virtual Function]]。\n![[Item43.png]]\n以下是 `LoggingMsgSender::sendClearMsg` 的 function body，這段 code 卻**無法通過編譯**\n\n```c++\ntemplate\u003ctypename Company\u003e\nclass LoggingMsgSender: public MsgSender\u003cCompany\u003e {\npublic:\n\t... // ctors, dtor, etc.\n\tvoid sendClearMsg(const MsgInfo\u0026 info)\n\t{\n\t\t// do some log...\n\t\tsendClear(info); // 呼叫繼承來的 base class function\n\t\t// do some log...\n\t}\n...\n}\n```\n\n問題是，當 Compiler 讀到 `class LoggingMsgSender` 的時候，並不知道它繼承的 `MsgSender\u003cCompany\u003e` 具象化起來，是怎麼樣的一個 class，Compiler 沒辦法確保這個未知的 Base class 是否有 `sendClear` function。\n\n## Template 繼承規則與物件導向繼承規則不同\n這正是條款1所說的，C++ 是一個聯邦。Template C++ 與 Object Oriented C++ 有些概念是不同的只能透過 Template Specialization 可以對特定的類別訂製特定的內容，Template 的繼承規則並不如物件導向繼承規則，在知道 `MsgSender\u003cCompany\u003e` 所代表的實體 class 之前，沒辦法確定 sendClear 是從哪來的，因為當前的 LoggingMsgSender 不存在這樣的 function。\n\n## 解決辦法\n以下的作法都是權宜之計，都是假設 Base Class 確實擁有 `sendClear` 的情況，但書中有沒有提更好的解法。\n### 在 Base Class function 前加上 `this-\u003e`\n```c++\ntemplate\u003ctypename Company\u003e\nclass LoggingMsgSender: public MsgSender\u003cCompany\u003e {\npublic:\n\tvoid sendClearMsg(const MsgInfo\u0026 info)\n\t{\n\t\tthis-\u003esendClear(info); // pass, 假設 sendClear 會被繼承\n\t}\n}\n```\n\n### 使用 Using 宣告式\n[[使用關鍵字 using 讓特定 function 在 Scope 內可見]]，使用的方法相同。不過在該例中是為了 [[繼承時的名稱遮掩行為]] 問題，本例的肇因卻是 Compiler 不會進入 Base Class Scope 找 function，我們透過 `using` 請 Compiler 這麼做。\n\n```c++\ntemplate\u003ctypename Company\u003e\nclass LoggingMsgSender: public MsgSender\u003cCompany\u003e {\npublic:\n\tusing MsgSender\u003cCompany\u003e::sendClear;\n\tvoid sendClearMsg(const MsgInfo\u0026 info)\n\t{\n\t\tsendClear(info);\n\t}\n}\n```\n\n\n### 以 Base Class 的 Namespace 呼叫該 Function\n```c++\ntemplate\u003ctypename Company\u003e\nclass LoggingMsgSender: public MsgSender\u003cCompany\u003e {\npublic:\n\tvoid sendClearMsg(const MsgInfo\u0026 info)\n\t{\n\t\tMsgSender\u003cCompany\u003e::sendClear(info);\n\t}\n}\n```\n\n這個方法的缺點是如果被呼叫的是 virtual function，這個明確的修飾(explicit qualification) (`MsgSender\u003cCompany\u003e::`) 會關閉 virtual 的綁定行為。\n\n### 結論\n在 invalid reference to base class member 這個問題上，Compiler 有兩種做法\n1. 在檢視 Derived Class Template Definition 時就診斷，此處的缺點是 Template 參數尚未具象化，無法得知 \"真正的 Base Class\" 的長相\n2. 等到 Template 參數具象化時，再檢視這個 reference 是否有效。\n\nC++ 的政策是傾向第一種，及早診斷。因此 Compiler 彷彿完全不知道 Base Class 有哪些東西可以呼叫一樣。\n\n而上述的三個手段，就是讓 Compiler 不要看到黑影就開槍(爆 error)，「先」假設 Base Class 有這個 function，讓編譯往下走。如果後來發現因為 template specialization 等原因，呼叫的 function 不存在，依然不會通過編譯，這依然是一個無效的 reference。","lastmodified":"2024-02-23T05:15:51.43809902Z","tags":["cpp"]},"/notes/Focus/C++/%E4%BA%86%E8%A7%A3-Inline-%E7%9A%84%E8%A3%A1%E8%A3%A1%E5%A4%96%E5%A4%96":{"title":"了解 Inline 的裡裡外外","content":"\n## 原理\n用程式碼取代 function call\n\n## 向 Compiler 發出申請\n\nProgrammer 可以明確的提出請求，或隱喻的提出。但編譯器可以拒絕這個申請，大部分過於複雜的函式都會被拒絕 inline:\n- 有 loop 的\n- 多數的 virtual function (等 Runtime 才確定哪個被喚醒)\n\n顯示與隱式的分別:\n- 顯式: 關鍵字 `inline` 是一種對 Compiler 發出的明確請求，但 Compiler 不一定會聽話。\n- 隱式: 有另一種暗示請求，就是把 function 實作寫在 class 定義裡面。這種通常是 member function，但 friend function 也可直接定義在 class 內，因此也可能被隱式宣告為 inline。\n\n```cpp\nclass Person {\npublic:\n\tint age() const { return theAge; } \n\t// an implicit inline request: age is  defined in a class efinition\nprivate:\n\tint theAge;\n};\n```\n\n\n\n## 優點\n當 inline function 本身很小的時候，把程式碼展開在呼叫者的「函式本體」的成本(object code 大小) ，會比呼叫該 function 所產生的成本來的小! \n\n## 缺點\n1. 當 inline func 函式本體龐大，這些龐大的碼會散布在各個呼叫者的函式本體，導致程式太大。\n2. 由於它的表現相當於直接展開在各個呼叫者身上，一旦 inline function 有更改，caller 也會被更動。而 non-inline 就只會是重新連結的問題，對重新 Compile 的負擔比較小。\n3. Debugger 沒辦法對付 Inline function --- 怎麼對一個不存在的函式設定中斷點呢?\n\n## Guidline \n- 限制 Inline 使用的時機: 它有絕對的理由必須是 inline (template 規定?) [[需要型別轉換時請為模板定義非成員函式]]\n- 十分平淡無奇，像是 `return m_size` 這般無聊。\n\n## Library Provider 必須謹慎評估是否宣告函式為 Inline \n有關 Inline 帶來的壞處，敘述於 [[建構和解構式是 inline 的糟糕人選]]。\n\n要注意，inline 無法隨著函式庫升級而升級，一旦 inline funciton 內容有變更，Client 端所有有用到該 function 的程式都需要重新編譯。\n而若不用 inline，Client 端只需要重新 Link 即可。\n\n## Template and Inline\n\ninline function 通常一定放在 header file 裡面，因為大多數的建置環境會在編譯中做 inlining，為了把 function call 換成「被呼叫函式」本體，必須知道被呼叫函式的內容。\n\nTemplate 也通常放在 header file，因為一旦使用，Compiler 為了具現化，同樣需要知道其內容。\n\n但 inline 具現化與 template 具現化無關，不過，如果 template 的作者**希望** function 為 inline，應該明確以關鍵字 `inline` 宣告。\n\n## 如何決定是否要 Inline? \n善用 [[80-20 Rule]] 找出最關鍵、最常被 Call 的程式碼去判斷是否該用 Inline 優化它!\n\n## 如何知道 Function 是否被 inline?\n[[如何檢驗編譯後的 Function 是否為 inlined function]]","lastmodified":"2024-02-23T05:15:51.43809902Z","tags":["cpp"]},"/notes/Focus/C++/%E4%BB%A5-Const-%E5%8F%96%E4%BB%A3%E4%BD%BF%E7%94%A8-Define":{"title":"以 Const 取代使用 Define","content":"\n## 以編譯器取代前處理器\n\n `#define` 的本質是 word replacement，如: `#define RATIO 1.653`，編譯器可能不認得 `RATIO` 並在錯誤訊息中從頭到尾以 1.653 取代 `RATIO`。\n```cpp\n const double Ratio=1.653; // Prefer\n```\n\n當以 `const` 取代 `#define` 時，有兩個需要注意的點\n1. 定義常數指標 (const pointer): 常數指標用於 「不允許此Pointer更改指向的對象」，因此需要對 pointer 宣告 const\n\n```cpp\nconst std::string = authorName(\"Scott\");\n ```\n\n2. Class 的專屬常數: 目的是限制常數的 Scope，因此要宣告在 class 內部。而為了使這個常數只有一個實體(所有 instance 共享同一個常數)，還需要宣告 `static`。\n\n```cpp\nclass Player {\nprivate:\n\tstatic const int num = 5;\n\tint scores[num];\n}\n ``` \n\n\n## 具有 Access Level\n第二點的用途，設置一個在某特定類別才生效的常數變是 `#define` 做不到的，`#deinfe` 不在乎 scope，不能帶來封裝性，更沒有 `private #deinfe` 這種東西。\n","lastmodified":"2024-02-23T05:15:51.43809902Z","tags":["cpp"]},"/notes/Focus/C++/%E4%BD%BF%E7%94%A8%E9%97%9C%E9%8D%B5%E5%AD%97-using-%E8%AE%93%E7%89%B9%E5%AE%9A-function-%E5%9C%A8-Scope-%E5%85%A7%E5%8F%AF%E8%A6%8B":{"title":"使用關鍵字 using 讓特定 function 在 Scope 內可見","content":"首先了解 [[繼承時的名稱遮掩行為]]。\n\n如果，我們只是想為 Derived Class 增加同名稱、Signature 不同的 function? 我們希望 Base Class 的 function 仍然可以被使用! 則，需要做的是用 `using` 讓 Base Function 變得可見，如下例: \n\n```cpp\nclass Derived: public Base {\npublic:\n\tusing Base::mf1; // make all things in Base named mf1 and mf3\n\tusing Base::mf3; // visible (and public) in Derived’s scope\n\tvirtual void mf1();\n\tvoid mf3(); // override Derived::mf3, even \n\tvoid mf4();\n...\n};\n\nDerived d;\nint x;\n...\nd.mf1(); // still fine, still calls Derived::mf1\nd.mf1(x); // now okay, calls Base::mf1\nd.mf2(); // still fine, still calls Base::mf2\nd.mf3(); // fine, calls Derived::mf3\nd.mf3(x); // now okay, calls Base::mf3 \n// (The int x is implicitly converted to a double so that  the call to Base::mf3 is valid.)\n```\n\n`using` 放在 public 是因為 Public 繼承，function 在 Base class 是 public ，基於正確的 public 繼承前提，Derived Class 在 `using` 暴露 Base Class 的 function name 時，也應該要是 Public 。\n\n- 可以不要繼承所有 Base Class 的所有函式嗎?\n\t- 在 Public 繼承下這不可能發生，這違反了 [[確保 Derived Class 和 Base Class 之間必然保持 Is-a 關係]]。\n\n## Private 繼承: 使用 forwarding function 繼承部分函式\n不繼承所有 Base Class 的所有函式，在 Private 繼承是有意義的。同樣的遇到名稱遮掩問題，該怎麼做?\n\n同樣以下圖為例，如果 Derived Class 只要 `void mf3()`，不要 `void mf3(double)`? \n![[Itm33.png]]\n\n那將無法使用 `using`，因為用下去所有的 `Base::mf3` 都會變得可見。這時候要換個手法: forwarding function。\n\n```cpp\nclass Base {\npublic:\n\tvirtual void mf1() = 0;\n\tvirtual void mf1(int);\n\t... // as before\n};\nclass Derived: private Base {\npublic:\n\tvirtual void mf1() { Base::mf1(); } \n\t// forwarding function; implicitly inline — see Item 30. \n\t// (For info on calling a pure virtual function, see Item 34.)\n}; \n\nDerived d;\nint x;\nd.mf1(); // fine, calls Derived::mf1\nd.mf1(x); // error! Base::mf1() is hidden\n```\n\n\n當繼承結合 Template，繼承名稱遭到遮掩的問題會再度發生，參見 [[了解如何在 Template 中指涉 Base Class 成員]]","lastmodified":"2024-02-23T05:15:51.43809902Z","tags":["cpp"]},"/notes/Focus/C++/%E5%8D%80%E5%88%86%E4%BB%8B%E9%9D%A2%E7%B9%BC%E6%89%BFinterface%E5%92%8C%E5%AF%A6%E4%BD%9C%E7%B9%BC%E6%89%BFimplement":{"title":"區分介面繼承(interface)和實作繼承(implement)","content":"\n## 背景\nBase Class Designer 在設計界面的時候，可能對 Derived Class 實踐者有三種期許\n- 只繼承 Member Function Interface (承襲宣告式)\n- 同時繼承 Member Function Interface 和**預設的**實作，也可以 override。\n- 同時繼承 Member Function Interface 和實作，不允許 override (不要自己改實作!)\n\n## Pure Virtual Function : 只繼承 Interface 需自行實做\n[[Pure Virtual Function]] 相當於告訴 Client: 你需要提供一個這樣的函式，但我不干涉你怎麼做它。\n```cpp\nclass Shape {\npublic:\n\tvirtual void draw() const = 0;\n};\n```\n\n## Impure Virtual Function : 繼承 Interface 和預設實作\n```cpp\nclass Shape {\npublic:\n\tvirtual void error(const std::string\u0026 msg);\n};\n```\n\n相當於告訴 Client: 你需要提供一個這樣的函式，如果不想自己寫，可以用預設的內容! \n\n但是，讓 impure virtual function 同時擔任「要求 client 給一個這樣的函式」又在「實作中放了預設行為」 Client 端可能在不知情下忽略要自己實作，而引發問題 [[Impure Virtual Function]]。\n\n## Non-Virtual Function: 繼承介面與實作，不應重新撰寫實作\n代表不變性(invariant)、凌駕特異性(specialization，因此不該在 Derived Class 中重新被定義。\n[[絕不重新定義繼承來的 Non-virtual Function]]\n\n## Conclustion\n1. 不該將所有的函式宣告成 non-virtual，這會導致 Derived 沒有空間特異化，特別是 non-virtual destructor 會帶來問題: [[為多型用途的基礎類別宣告 virtual 解構式]]\n2. 不該將所有的函式宣告成 virtual，某些時候這是正確的，像是 Interface Class。但多數時候這是 Base Class Designer 沒有堅定立場，某些 Function 就是不該在 Base Class 被重新定義! \n\n","lastmodified":"2024-02-23T05:15:51.43809902Z","tags":["cpp"]},"/notes/Focus/C++/%E5%A4%9A%E9%87%8D%E7%B9%BC%E6%89%BF-Multiple-Inheritance-MI":{"title":"多重繼承","content":"- 單一繼承 (Single Inheritance, SI)\n- 多重繼承 (Multiple Inheritance, MI)\n---\n\n## 了解 C++ 如何解決歧異 (ambiguity)\n\n函式名稱、typedef 都可能發生歧異。C++ 解決歧異的方式與決議(resolving) overloading function 的規則相同\n- 先找最匹配的呼叫函式\n- 如果匹配度相同，才會發生歧異，因為沒有最佳匹配。\n\n面對歧異，在呼叫的時候需要明指呼叫的是哪一個 class 的 function:\n```cpp\nobj.BaseClass::someFunc();\nobj.DerivedClass::someFunc();\n```\n\n## 鑽石繼承\n試想下圖，假設 `File` 裡面有一個 member data `fileName`，而在 `IOFile` 當中，它該有幾個 `fileName` data?\n![[Item40.png]]\n\n1. 來自 `InputFile::fileName`, `OutputFile::fileName`各一份\n2. 只該一份，來自兩個 Parent Class 的 fileName 應該要相同，且只有一份 `fileName` 資料握在 `IOFile`。\n\nC++ 的預設做法是 (1)，各複製一份。但同時也支援 (2)，只是在繼承時需要宣告 virtual: [[Virtual Base Class]]。\n\n## 結論\n- 有單一繼承，就用單一繼承\n- 如果多重繼承能帶來比單一繼承低的維護成本、且合理，別猶豫。\n\t- 其中一種例子 (P195~199) : public 繼承某個 Interface class, private 繼承某個協作實作的 class，就是多重繼承的一個合理展現。\n","lastmodified":"2024-02-23T05:15:51.43809902Z","tags":["cpp"]},"/notes/Focus/C++/%E5%A6%82%E4%BD%95%E6%AA%A2%E9%A9%97%E7%B7%A8%E8%AD%AF%E5%BE%8C%E7%9A%84-Function-%E6%98%AF%E5%90%A6%E7%82%BA-inlined-function":{"title":"如何檢驗編譯後的 Function 是否為 inlined function","content":"\n\n理論上，programmer 不需要知道，這些交給 compiler 決定就好。我根據 [Stackoverflow 的討論](https://stackoverflow.com/questions/10631283/how-will-i-know-whether-inline-function-is-actually-replaced-at-the-place-where)串做了些研究。\n\n但為了釐清某些觀念，我希望知道 function 是否隱性的被 inline、亦或是顯性 inline 是否有被接受。\n## Winline\n對於那些被標示為 inline，編譯結果卻沒有被 inlined 的 function 而言，在 gcc compile 的命令加上 `-Winline` 即可，這些 function 會以 warning 的形式記錄在 compile log 當中。\n\n## nm\n[[nm]] 是 Linux 下一個檢視 object file 內容的指令:\n```cpp\nnm object_file\n```\n\n透過 nm 檢視後面範例的 object file，我得到下面內容 (只擷取與 test_cls 相關的部分): \n```\n00000000000012d8 t _GLOBAL__sub_I__ZN8test_cls2f3Ev\n00000000000012f2 W _ZN8test_cls2f1Ev\n00000000000011ca T _ZN8test_cls2f3Ev\n```\n也就是說，除了 `f2` 被強制 inline，`f1` 跟 `f3` 都不是 inline function? 但討論串中有人說到，nm 看的並不全面，一個 function 是否被 inline 對不同的 instance call 而言可能有不同的解釋，總之就是有可能不準。\n\n## 看組合語言\n使用 `-S` flag 生成組合語言\n```bash\ng++ -S FileName.cpp\n```\n\n\n## Resource \n- [Godblot](https://gcc.godbolt.org/): 線上轉換組合語言，並有區塊對照! \n\n## Example \n### inline.hpp\n```cpp\n#include \u003ciostream\u003e\n#include \u003clist\u003e\n#include \u003cmap\u003e\n\nclass test_cls {\npublic:\n    void f1() {\n        std::cout\u003c\u003c\"f1\"\u003c\u003cstd::endl;\n    }\n\n    __attribute__ ((always_inline))\n    void f2() {\n        std::cout\u003c\u003c\"f2\"\u003c\u003cstd::endl;\n    }\n\n    void f3();\n};\n\n\n```\n\n### inline.cpp\n```cpp\n#include \"inline.hpp\"\nvoid test_cls::f3() {\n    std::cout\u003c\u003c\"f3\"\u003c\u003cstd::endl;\n}\n\nint main() \n{\n    auto t = test_cls();\n    t.f1();\n    t.f2();\n    t.f3();\n}\n```\n\ncmd:\n```\ng++ -o inline inline.cpp\n```","lastmodified":"2024-02-23T05:15:51.43809902Z","tags":["cpp"]},"/notes/Focus/C++/%E5%AF%A9%E6%85%8E%E7%9A%84%E4%BD%BF%E7%94%A8-Private-%E7%B9%BC%E6%89%BF":{"title":"審慎的使用 Private 繼承","content":"- Private 繼承代表 implemented in terms of (根據某物實作出)\n- 當 `class D` 以 Private 繼承 `class B`，目的是「調用 class B 的 API」，通常意味著只有實作要被繼承，介面不需要。所以 private 繼承來的 function 也只應該放在 private 區塊。\n- Private 繼承是實作上的手段，跟 OO design 沒有關係。\n\n## implemented in terms of (根據某物實作出)\n在 [[確定 Composition 塑造的是 'Has-A'關係 或 '根據某物實作'的關係]] 裡面也提及 implemented in terms of (根據某物實作出) 的關係。\n\n在多數的情況下，composition 是優於 private 繼承的，只有當\n- 要調用 protected member \n- virtual function 需要重新定義\n被牽扯進來時才應該考慮 Private 繼承。\n\n即使必須使用 Private 繼承，記住[[讓介面易於被使用，不易誤用]]，我們可以透過一些手段把 Private 繼承的影響「藏起來」\n## Private 繼承的範例\n情境\n1. 有一個 `Widget` 物件，我們想要知道他被呼叫的次數，並且會週期性的檢視它的資料。\n2. 為此，需要一個計時器 `Timer`，在工具箱中發現了它! 只要重新定義 `onTick`，在裡面寫取出 Widget 物件的狀態即可!\n```c++\nclass Timer {\npublic:\n\texplicit Timer(int tickFrequency);\n\tvirtual void onTick() const; // automatically called for each tick\n...\n};\n```\n\n- Question: 應該讓 Widget 繼承 Timer 嗎?\n\t- Public 繼承: Widget 並非 Timer，這違反 [[確保 Derived Class 和 Base Class 之間必然保持 Is-a 關係]]\n\t- Private 繼承: 可以重新定義 `onTick`，客戶端也沒能力呼叫到它，OK。\n\n## Composition + Private 繼承\n比起直接的 Private 繼承，我們有更好的做法。\n![[Item39.png]]\n\n此作法的好處有兩個\n### 為 Base Class 設計做考量\n- 如果 Widget 被設計成 Base Class，卻不希望 Derived Class 重新定義 `onTick`，就不適合直接讓 Widget 以 Private 繼承 Timer。但新的設計讓 `WidgetTimer`繼承 Timer 得以重新定義 virtual function，並把 timer 物件放在 private，現在 derived class 想碰也碰不到 timer 了。\n```c++\nclass Widget {\nprivate:\n\tclass WidgetTimer: public Timer {\n\tpublic:\n\t\tvirtual void onTick() const;\n\t\t...\n\t};\n WidgetTimer timer;\n...\n}\n```\n\n### 降低編譯依存性\n如果 Widget 繼承 Timer ，則 Widget 被編譯時，Timer 的定義也必須可見。也就是說 Widget 需要 `#include Timer.h`。但如果把 `WidgetTimer` 以一個 pointer 存在 `Widget`，則不再需要 include，達到 decoupling。\n[[將檔案的編譯依存關係降到最低]]\n\n```c++\nclass Widget {\nprivate:\n\tWidgetTimer* timer; // better way: use smart pointer\n}\n\n// In another file\nclass WidgetTimer: public Timer {\npublic:\n\tvirtual void onTick() const;\n\t...\n};\n```\n\n## 其他\n[[EBO (Empty Base Optimization)]]","lastmodified":"2024-02-23T05:15:51.43809902Z","tags":["cpp",""]},"/notes/Focus/C++/%E5%B0%87%E6%AA%94%E6%A1%88%E7%9A%84%E7%B7%A8%E8%AD%AF%E4%BE%9D%E5%AD%98%E9%97%9C%E4%BF%82%E9%99%8D%E5%88%B0%E6%9C%80%E4%BD%8E":{"title":"將檔案的編譯依存關係降到最低","content":"\n首先清楚此內容: [[編譯依存-宣告式、定義式與實作細節]]。\n接著，需要分清楚「被 include 的對象」與「被前置宣告的對象」。\n\n## 被 include 的對象\n1. 當需要創建某類別的物件，例如 : 要創建 member data `m_date`，則需要 include Date.hpp。\n2. 有用到 STL 物件，則直接 include STL 函式庫。\n\n對於 STL 函式庫，應該用 `#include`，而不是使用前置宣告。include 標準函式庫的 header file 幾乎不會造成編譯瓶頸。\n\n```c++\n// 正確做法\n#include \u003cstring\u003e\n\n// 錯誤作法\nnamespace std {\n\tclass string;\n}\n```\n\n## 被前置宣告的對象\n只要不是要創建物件，不是 STL 物件，就可以使用前置宣告解決需求!! \nSTL 物件已經經過優化，不用擔心 include 負擔。\n\n## 降低編譯依存的手法: Pimpl Idiom\n\n[[pimpl idiom (pointer to implementation)]]\n","lastmodified":"2024-02-23T05:15:51.43809902Z","tags":["cpp"]},"/notes/Focus/C++/%E5%B0%91%E5%81%9A%E8%BD%89%E5%9E%8B%E5%8B%95%E4%BD%9CMinimize-casting":{"title":"少做轉型 Minimize casting","content":"## 常見的轉型語法\n\n```cpp\n// 舊式轉型\n(T) expr; // C-style\nT(expr);  // func style\n\n// New-style/ C++ Style  casting \nconst_cast\u003cT\u003e(expr);\nstatic_cast\u003cT\u003e(expr);\nreinterpret_cast\u003cT\u003e(expr);\ndynamic_cast\u003cT\u003e(expr);\n```\n\n- `dynamic_cast`: 安全向下轉型 (safe downcasting)，是一個可能耗費重大執行成本的轉型動作\n- `static_cast`: 強迫隱式轉換，像是 non-const to const, int to double...，但不能做 const to non-const.\n- `const_cast`: 唯一可以做到 const to non-const.\n\n即使舊式轉型依然有用，通常建議用新式，好處是\n1. 容易在程式碼中被搜尋\n2. 意圖窄化，像是如果想移除 constness，則必須使用 const_cast，其他都不會通過編譯。\n```cpp\nconst int a = 1;\nint b = static_cast\u003cint\u003e(a); // fail\nint b = const_cast\u003cint\u003e(a); // ok\n```\n\n\n## 不是圖臆測轉型的 Pointer 如何實作\n\n在某些語言中，Drived Class 轉成 Base Class 在 Pointer 上只是一個 Offset。但在 C++ 中，Pointer 是怎麼「算」出來的取決於 Compiler。不要試圖「猜」要抓哪個 Address，相當於 Casting，該用 `static_cast` 就乖乖用。\n\n\n## 常見的轉型誤用: 試圖使用 Casting 以呼叫 Base Class 方法\n有些框架要求 Drived Classes 的 Virtual func 實作時，要先呼叫 Base Class 的對應函式。\n在 Python 中，呼叫 Parent 的方法可以使用 `super()`，在 C++ 中，直接在 Drived Class 當中，使用 Base Class 的名稱空間以呼叫 Base Class 方法! \n\nExample: \n```cpp\nclass Window {\npublic:\n\tvirtual void onResize;\n}\n\nclass SpecicalWindow: public Window {\npublic: \n\tvirtual void onResize() {\n\t\t// 錯誤作法\n\t\tstatic_cast\u003cWindow\u003e(*this).onResize();\n\t\t// 正確做法\n\t\tWindow::onResize();\n}\n```\n\n錯誤方法的呼叫，相當於\n```cpp\nWindow tmp = static_cast\u003cWindow\u003e(*this);\ntmp.onResize();\n```\n\n## Dynamic Cast\n\n### 效率問題\n`dynamic_cast` 有嚴重的效率問題，多重繼承/深度繼承越多，效率成本越大。\n某些時候採用它有必要的原因: 需要支援動態連結。\n\n## 如何避免使用?\n### Dynamic Cast 的使用場合\n手上握有一個 base class pointer/reference，但你認定這個 base class pointer 所指向的對象是某一個 dirved classs。\n\n### Solution1 使用 Type-Safe Container\n同樣接續上例的 `Window`\n\n```cpp\n\nstd::vector\u003cWindow\u003e winPtrs;\n\ntypedef std::shared_ptr\u003cSpecialWindow\u003e SPW;\nSPW sp_ptr;\nsp_ptr = *winPtrs.begin();\n```\n\n\u003e [!question] \n\u003e 1. 這裡本質不還是 static cast?\n\u003e 2. 如何保證 type 正確?? container 有測試?\n\n### Solution2 在 Base Class 撰寫對應的 Virtual Func\n[[區分介面繼承(interface)和實作繼承(implement)]]\n\n```cpp\nclass Window {\npublic:\n\tvirtual void onResize;\n\tvirtual void blink() {};\n}\n\nclass SpecicalWindow: public Window {\npublic: \n\tvirtual void onResize() {...};\n\tvirtual void blink() {\n\t\t// implement!!\n\t};\n}\n```\n\n","lastmodified":"2024-02-23T05:15:51.43809902Z","tags":["cpp"]},"/notes/Focus/C++/%E5%B7%A5%E5%BB%A0%E5%87%BD%E5%BC%8F-Factory-Function":{"title":"工廠函式 (Factory Function)","content":"\u003e Factory method pattern enables us to create an object without exposing the creation logic to the client and refer to the newly-created object using a common interface. It is one of the most widely used creational patterns.\n\u003e This pattern is also known as the Virtual Constructor.\n\n\nhttps://dzone.com/articles/factory-method-design-pattern","lastmodified":"2024-02-23T05:15:51.43809902Z","tags":["cpp"]},"/notes/Focus/C++/%E5%BB%BA%E6%A7%8B%E5%92%8C%E8%A7%A3%E6%A7%8B%E5%BC%8F%E6%98%AF-inline-%E7%9A%84%E7%B3%9F%E7%B3%95%E4%BA%BA%E9%81%B8":{"title":"建構和解構式是 inline 的糟糕人選","content":"\n考量以下例子:\n```cpp\nclass Base {\npublic:\n...\nprivate:\n\tstd::string bm1, bm2; // base members 1 and 2\n};\nclass Derived: public Base {\npublic:\n\tDerived() {} // Derived’s ctor is empty — or is it?\n...\nprivate:\n\tstd::string dm1, dm2, dm3; // derived members 1–3\n};\n```\n建構式 `Derived::Derived` 乍看內容是「空的」很適合 inlining?\n\n別忘了，物件產生的時候，每一個 Base Class、每一個成員變數的 constructor 都會被呼叫，反之，物件被銷毀時，destructor 也會依序呼叫。\n\n這些動作並非憑空發生，Compiler 在編譯期間會代為產生，並安插到程式碼中，彷彿以下內容就是 Compiler 代為成生的 (這並非實際會生成的，編譯器會更精巧的處理 exception)。\n\n```cpp\nDerived::Derived() // conceptual implementation of\n{ // “empty” Derived ctor\n\tBase::Base(); // initialize Base part\n\ttry { dm1.std::string::string(); } // try to construct dm1\n\tcatch (...) { // if it throws,\n\tBase::~Base(); // destroy base class part and\n\tthrow; // propagate the exception\n}\ntry { dm2.std::string::string(); } // try to construct dm2\ncatch(...) { // if it throws,\n\tdm1.std::string::~string(); // destroy dm1,\n\tBase::~Base(); // destroy base class part, and\n\tthrow; // propagate the exception\n}\ntry { dm3.std::string::string(); } // construct dm3\ncatch(...) { // if it throws,\n\tdm2.std::string::~string(); // destroy dm2,\n\tdm1.std::string::~string(); // destroy dm1, \n\tBase::~Base(); // destroy base class part, and\n\tthrow; // propagate the exception\n}\n}\n```\n\n但從本例我們可以看到，`Derived::Derived` 會去呼叫 `Base::Base` ，如果試圖對 `Derived::Derived` 做 `inline`，Compiler 會檢視 `Derived::Derived` 所呼叫的 funciton，決定 `Derived::Derived` 是否有被 `inline` 的資格。\n\n如果每一個在 `Derived::Derived` 當中被呼叫的都是 inlined function .... 讓我們一一檢視這件事\n\n- 假設 std::string constructor 是 inline function。\n- `Base::Base` 被宣告 inline ，它要呼叫 `bm1`, `bm2` 兩次 std::string constructor。\n- `Derived::Derived`: 被宣告 inline ，光是自己的 member data (不含 base) 要呼叫 `dm1`, `dm2`, `dm3` 三次 std::string constructor。\n\n`Derived::Derived` 總共要呼叫 5次 std::string constructor，一旦宣告成 inline，std::string constructor code 會插入**5份**在 `Derived::Derived` !!\n\n\n\n","lastmodified":"2024-02-23T05:15:51.43809902Z","tags":["cpp"]},"/notes/Focus/C++/%E6%80%9D%E7%B6%AD%E8%AA%A4%E5%8D%80-%E7%89%A9%E4%BB%B6%E5%BE%88%E5%B0%8F%E5%B0%B1%E5%8F%AF%E4%BB%A5-Pass-By-Value":{"title":"思維誤區-物件很小就可以 Pass By Value","content":"有三個主因: \n1. 並非「該物件/container」**看起來**很小，用 Pass by value 就沒有問題。許多  STL Container 在實作上的大小也就一個 Pointer 大一點，但 Copy Container 卻有「複製每一個 Pointer 所指向的物件」的風險在。\n2. 視 Compiler 而定，有些 Compiler 對待 Custom class 跟 built-in class 的態度大不相同，即使底層表述(underlying representation) 相同，仍可能以不同的操作對待，導致 Copy 在 Custom Class 就是比較慢。\n3. Type 實作可能發生改變，現在 Copy 的代價不昂貴，不代表以後不會。\n\n## Pass By Value 的代價\n[[Pass by value 當中的 Copy 行為]]\n","lastmodified":"2024-02-23T05:15:51.43809902Z","tags":["cpp"]},"/notes/Focus/C++/%E6%89%93%E7%A0%B4-Constness-%E9%99%90%E5%88%B6":{"title":"打破 Constness 限制","content":"\n### Physical Constness\n\u003e 編譯器堅守的觀點: Physical Constness，又稱 Bitwise constness。Const member function 不可以修改任何 non-static member data。\n\n然而，請看下例: `operator[]` 確實不會更動到 member data，可以通過 Bitwise Testing，卻把「改動權」暴露給 Client 端，造成不應該的賦值行為。\n- [[避免傳回 Handles 指向物件的 Private \u0026 Protected Member Data]]\n\n```cpp\nclass CTextBlock {\n\npublic:\n    // inappropriate (but bitwise const) declaration of operator[]\n    char\u0026 operator[](std::size_t position) const\n    { return pText[position]; }\n    \nprivate:\n    char *pText;\n}\n\nconst CTextBlock ctb(\"World\");\nctb[0]='F'; // Become \"Forld\"\n```\n此例應該將回傳型態修改為 `const char\u0026`。\n\n編譯器堅守的 Bitwise constness 觀念，造成 Const Function 作用過於綁手綁腳，甚至在 Const \u0026 Non-Const function 之間我們可能需要 Own 兩份相似的 Code! \n接下來將說明 `mutable` 與 const cast，他們將幫助我們破除 const 的限制，使程式設計更加靈活。\n\n### Logical Constness\n\u003e 概念上的常數性 (Conceptual Constness)\n\n我對這個論點的解讀是，某些 data 是藏於封裝底下，沒有暴露給 User 修改的。這種 member data 在 logical constness 的觀念下是可被修改的。\n書中舉例，若我們在 `CTextBlock` 當中有一個快取 (cache) 的 member data ，用來記當前字串的長度。當字串沒有修改長度的行為(增加/減少)時，此快取都是有效的。但若有修改行為，則在 `length()` 被 Query 時，我們會需要更新這個快取。\n\n在 Bitwise Constness 的觀念下，修改這個快取用途的 member data 是不合法的，且這也是 Compiler 的觀點。\n解決辦法是，使用關鍵字 `mutable` 宣告這些有資格在 const function 內被改動的 data，`mutable` 使得 const function 在實踐上有討價還價的空間。\n\n\u003e `mutable` 釋放 non-static member data 的 bitwise constness 約束 (釋放 member data 的不可變動性)。\n\n\n### Avoiding Duplication in const and Non-const Member Functions\n\u003e 當 const 和 non-const member function 有等價的實作時，讓 non-const 呼叫 const 可以避免 duplicated code。\n\n若我們在 const \u0026 non-const function 當中，都有相同的程序要做: 邊界檢查、write log、verty data...，即使子步驟都可以抽出來，還是造成「走 flow 的流程」會重複在兩個 function 當中。\n\n```cpp\nclass TextBlock \n{\n\tconst char\u0026 operator[](std::size_t position) const;\n\tchar\u0026 operator[](std::size_t position);\n}\n```\n\n我們該做的是，把所有的東西寫在其中一個，而另一個去呼叫寫著 flow 的 function。這說明了我們的一個需求: 去除 Constness!\n\n我懷疑這個手法在 C++11 \u0026 14 可能有其他解，這裡先跳過細究。簡單來說就是透過 `const_cast` 將 const function 的結果再轉成非 const。\n\n```cpp\nclass TextBlock {\npublic:  \n\t// same as before\n    const char\u0026 operator[](std::size_t position) const {\n        return text[position];\n    }\n\t// now just calls const op[]\n    char\u0026 operator[](std::size_t position) \n    {\n        // cast away const on op[]’s return type\n        // add const to *this's type, call const version of op[]\n        return const_cast\u003cchar\u0026\u003e(\\\n\t        static_cast\u003cconst TextBlock\u0026\u003e(*this)[position]\n\t\t);\n    }\n};\n```\n ","lastmodified":"2024-02-23T05:15:51.43809902Z","tags":["cpp"]},"/notes/Focus/C++/%E6%B0%B8%E9%81%A0%E4%B8%8D%E8%A9%B2%E6%89%94%E4%BE%8B%E5%A4%96%E7%9A%84-function":{"title":"永遠不該扔例外的 function","content":"The following types of functions should never throw: destructors (see the section Failing Destructor in Chapter 5), swap functions, move operations, and default constructors.","lastmodified":"2024-02-23T05:15:51.43809902Z","tags":["cpp"]},"/notes/Focus/C++/%E6%B8%85%E9%85%92%E5%A4%A7%E9%9B%86%E5%90%88":{"title":"清酒大集合","content":"## 京姬 純米大吟釀 匠\n味道：入口有香甜果香，帶有微辛口的餘韻(建議凍飲)\n\n配搭：海鮮、刺身、壽司\n\n酒造採用山田錦，精米步合精磨至45%釀造，酒款散發出優雅的吟釀香氣，入口後會有感覺舒適的餘韻。雖然此[清酒](https://academy.sakewa.hk/%E6%B8%85%E9%85%92-sake)採用了酒米之王山田錦來釀造，但價格卻非常親民，絕對是入門級的純米大吟釀！\n\n## 京姬 大吟釀 匠\n\n\n\n## 北秋田大吟釀\n\n酒精度：15 ~ 16%  \n口　感：甜味和清爽之間的完美平衡。  \n味道　：精彩而豐富的口感  \n酸　度：1.3  \n精米步合：50%  \n  \n坐落於日本北部，北鹿酒造在冬天時大多被大雪深埋其中，雖然身處秋田縣，但是卻採用的是兵庫縣的「山田錦」這種製酒用米，造就了迥異於兩者的獨特風味，再從「山田錦」米中精米步合50來製成此北秋田大吟釀清酒。  \n稻米秋收時開始釀造，冬至時就剛好進行至熟成階段，此時北鹿酒造會利用冬天的降雪堆砌酒窖，藉此確保儲藏過程保持穩定的低溫環境，同時造成非常獨特的熟成過程。\n\n### 酒米 山田錦  \n「山田錦」具備了優質酒米所應有之三大條件，粒大，芯白（米粒中心部份富含澱粉），蛋白質含量低。酒米有五百萬石，美山錦等100多個品種 但「山田錦」自命名以來，雄踞「酒米之王」寶座已近80年。  \n\n「山田錦」1923年誕生於兵庫縣農事試驗場（現在的兵庫縣立農林水產技術綜合中心）是由山田穗和短稈渡船這兩個品種相互培育獲得，並在1936年命名為「山田錦」，現在雖然在福岡、德島、岡山等全國33個府、縣都有生產，但是全國新酒品鑑會的金獎之中，幾乎都由以兵庫縣產「山田錦」為原料的酒所獨占，由此可見兵庫縣的「山田錦」在釀酒師心中不可動搖的地位。","lastmodified":"2024-02-23T05:15:51.43809902Z","tags":[]},"/notes/Focus/C++/%E7%82%BA%E4%BB%80%E9%BA%BC%E8%A6%81%E7%94%A8%E7%8D%A8%E7%AB%8B%E5%8F%A5%E5%B0%87%E7%89%A9%E4%BB%B6%E6%94%BE%E5%85%A5-Smart-Pointer":{"title":"為什麼要用獨立句將物件放入 Smart Pointer","content":"\u003e 盡可能確保 `new` 出來的物件，可以立即被放入 smart pointer 裡面，避免任何額外的步驟。只要有多餘的步驟，就可能因為意外而使得 smart pointer 沒有真正掌控到資源。\n\n以獨立一句話將 newed 物件加入 smart pointer，格式如下\n\n```cpp\nstd::shared_ptr\u003cWidget\u003e pw(new Widget);\nprocessWidget(pw, priority());\n```\n\n---\n\n其原因是，如果像以下寫法\n```cpp\nprocessWidget(std::shared_ptr\u003cWidget\u003e pw(new Widget), priority());\n```\n\n編譯器要做的有三件事\n1. 呼叫 `priority`\n2. 執行 `new` \n3. 呼叫 smart pointer constructor\n\n而我們無法確保這三件事的最終順序為何，必然的關係只有 「會先 `new` ，再執行 smart pointer constructor」。而 `priority` 是**可能**安插於 new 之後的。\n\n1. `new` \n2. `priority` (發生錯誤)\n3. smart pointer constructor\n\n如果不幸的，編譯器選擇這種順序，並且在把物件放入 smart pointer 之前發生了錯誤，這塊記憶體將沒有 smart pointer 協助銷毀! \n","lastmodified":"2024-02-23T05:15:51.43809902Z","tags":["cpp"]},"/notes/Focus/C++/%E7%82%BA%E5%A4%9A%E5%9E%8B%E7%94%A8%E9%80%94%E7%9A%84%E5%9F%BA%E7%A4%8E%E9%A1%9E%E5%88%A5%E5%AE%A3%E5%91%8A-virtual-%E8%A7%A3%E6%A7%8B%E5%BC%8F":{"title":"為多型用途的基礎類別宣告 virtual 解構式","content":"\n## 多型\n多型有個特點: Base Class 的存在是為了「經由 Base Class Interface 處置 Drived Class Object」，以下例來說， `TimeKeeper` 是一個 Polymorphic Base Class，所以持有一個 `TimeKeeper` Pointer 就可以處理 `WaterClock`, `WristWatch` 物件，這就是上面那句話的意思。\n\n```cpp\nclass TimeKeeper {\npublic:\n\tTimeKeeper();\n\tvirtural ~TimeKeeper();\n};\nclass AtomicClock: public TimeKeeper { ... };\nclass WaterClock: public TimeKeeper { ... };\nclass WristWatch: public TimeKeeper { ... };\n\nTimeKeeper* getTimeKeeper(); \n// Returned pointer may be AtomicClock, WaterClock, WristWatch\n// But they can be owned by base class \"TimeKeeper\"\n// This is polymorphy.\n```\n\n繼承與多型之間並非充分必要條件，**非所有的 Base Class 都是作為多型使用**。\n像是 [[Item47 Use traits classes for information about types]] 的 `input_iterator_tag`，繼承更像是 \"enable 某種特性\" 的用途。 \n\n\n## 多型的 Base Class 沒有 Virtural Destructor 又如何\n多型 (polymorphic) 的手法使我們可以持有 base class 的 Pointer 指向各種 child class 的實作。[[工廠函式 (Factory Function)]]  就是典型的實作。\n\n\u003e [!question]\n\u003e 為了遵守 factory function 的規矩，哪來的規矩?\n\n為了遵守 factory function 的規矩，factory function 回傳的物件必須位於 heap (在 function 中被 `new` 出來的)，被 `new` 出來的物件必須手動刪除它。\n```cpp\nTimeKeeper* ptk = getTimeKeeper();\ndelete ptk;\n```\n\n儘管 [[Smart Pointer|條款13 使用資源管理器]] 和 [[讓介面易於被使用，不易誤用]] 說明了依賴 client 做 `delete` 有潛在的危險跟不確定，這裡要說明的是更嚴重、更根本性的問題。\n- 我們宣告的是 **Base class pointer**，指向的是 **child class 物件**。\n- Base class 擁有一個 non-virtural 的 destructor\n- C++ 明白的告訴我們，當 child 物件經由擁有 non-virtural destructor 的 Base class pointer 持有，而這個 pointer 被刪除時，屬於 **Undefined behavior**\n\n此 Undefined Behavior **通常**會發生的是，屬於 Base class 部分成功銷毀，只屬於 Child Class 的 member data **沒有被銷毀**，造成**部分銷毀**的詭異狀況。\n\n要消除這種作法的解答就是，給 Base class 的 destructor 設置 `virtural`。\n\n\u003e 一個 Class 若有帶有 `virtural` 的函式，幾乎可以確定**該有**會帶有 `virtural` 的 destructor。如果一個 class 不帶有 `virtural` function，通常代表它不意圖被當作 base class。\n\n (實作都寫完在 base 了，還特意搞繼承 override 幹嘛?)。然而，`virtural` 也不應該亂用: [[不要為非多型用途的 Base Class 宣告 Virtual Function]]。\n\n## 企圖以多型設計架構前，檢查 Base Class 的 Destructor 是否為 Virtual\n\n如果不是 virtural destructor，請想別的辦法!! \n接續前面章節，**並非** class 中沒有 `virtural` function，**就不需要** 考慮 non-virtural destructor 的問題。\n\n以例子來說，若有個 `SpecialString` 繼承 `std::string` (non-virtural destructor)，在 `new` 一個 `SpecialString` 之後指給 `std::string` pointer 之後就會遇到 Undefined Behavior 的問題! \n\n```cpp\nSpecialString *pss = new SpecialString(\"Impending Doom\");\nstd::string *ps;\n\nps = pss;\ndelete ps; // undefined behavior\n```\n\n同樣需要注意的如 `std::vector`, `std::list`, `tr1::unordered_map` ([[Item55 Familiarize yourself with Boost]]) 等。如果你想繼承一個 STL container，但它沒有 virtural destructor，請千萬不要嘗試繼承它! 這只會帶來災難。\n\n## 想要一個抽象類嗎\n想要一個抽象類，卻苦於沒有人選(function)「被 virtural」? 考慮 Destructor 吧: [[Pure Virtual Destructor]]\n\n\n","lastmodified":"2024-02-23T05:15:51.43809902Z","tags":["cpp"]},"/notes/Focus/C++/%E7%82%BA%E7%95%B0%E5%B8%B8%E5%AE%89%E5%85%A8-Exception-safe-%E8%80%8C%E5%8A%AA%E5%8A%9B%E6%98%AF%E5%80%BC%E5%BE%97%E7%9A%84":{"title":"為異常安全 (Exception-safe) 而努力是值得的","content":"\n## 異常安全的條件\n1. 不洩漏任何資源\n2. 不允許資料敗壞\n\n## Bad Case\n\n先看一個很糟糕的例子: \n```cpp\nclass PrettyMenu {\npublic:\n...\nvoid changeBackground(std::istream\u0026 imgSrc); // change background\n... // image\nprivate:\n Mutex mutex; // mutex for this object \nImage *bgImage; // current background image\nint imageChanges; // # of times image has been changed\n};\n\nvoid PrettyMenu::changeBackground(std::istream\u0026 imgSrc)\n{\nlock(\u0026mutex); // acquire mutex (as in Item 14)\ndelete bgImage; // get rid of old background\n++imageChanges; // update image change count\nbgImage = new Image(imgSrc); // install new background\nunlock(\u0026mutex); // release mutex\n}\n```\n\n1. 不洩漏任何資源: 第 17 行，一旦 `new` 過程中拋出 exception，第 18 行就不會執行，mutex 永遠不會 unlock。\n\t- 可透過 smart pointer 管理 heap-based 資源 (created by `new` ) 洩漏問題。\n\t- 使用 [[Mutex]] 的 `Lock` 確保離開 `changeBackground` 之後，mutex 就會自動解鎖。\n```cpp\nvoid PrettyMenu::changeBackground(std::istream\u0026 imgSrc)\n{\nLock ml(\u0026mutex); // from Item 14: acquire mutex and ensure its later release\ndelete bgImage;\n++imageChanges;\nbgImage = new Image(imgSrc);\n}\n```\n\n2. 不允許資料敗壞: 一旦 `new Image(imgSrc)` 的過程拋出 exception\n\t1. `bgImage` 會指向一個已經刪除的物件\n\t2. image 沒有創建成功，`imageChanges` 記數卻已經加上去。\n在解決資料敗壞問題之前，先導入 exception safe 的保證\n\n## Exception-Safe Functions\n必須提供三者之一\n1. 基本承諾: \n\t- 如果異常被拋出，程式的任何資料都處於有效的狀態 (只要有效即可，不保證是哪一個 status)。\n\t- 程式內任何的資料、狀態仍處於前後一致的狀態 -- 但現實中有些不可能，舉例上面的程式，當 `changeBackground` 拋出 exception 時，`PrettyMenu` 物件要使用哪一種背景? 預設背景? 原背景? Client 端需要 query 才知道。\n2. 強烈保證: 如果異常被拋出，呼叫者的程式狀態不改變。呼叫異常安全函式者會知道: 函式成功則完全成功，失敗則程式回到「呼叫函式」之前。\n\t- 這種保證比基本承諾好，Client 不用猜測「合法狀態」是哪一種狀態。\n3. 不拋擲 (nothrow) 保證: 承諾決不拋出異常，內建型別 (int, pointer) 身上的所有操作都屬於此類。\n\t- 要注意，Empty exception specification 不是 nothrow 函式，而是如果此函式拋出異常，將是嚴重的錯誤，會有意想不到的函式 (搜尋 C++ 文件 `set_unexpected`) 被喚起。\n\t- [[Modern C++ noexcept]]\n```cpp\nint doSomething() thorw(); // empty exception specification\n```\n\n\u003e [!todo]\n\u003e P132\n\n\n\n\n\n\n\n\n\n\n","lastmodified":"2024-02-23T05:15:51.43809902Z","tags":["cpp"]},"/notes/Focus/C++/%E7%95%B6%E6%89%80%E6%9C%89%E7%9A%84%E5%8F%83%E6%95%B8%E9%83%BD%E9%9C%80%E8%A6%81%E5%9E%8B%E5%88%A5%E8%BD%89%E6%8F%9B%E6%8E%A1%E7%94%A8-Non-member-Function":{"title":"當所有的參數都需要型別轉換，採用 Non-member Function","content":"\n讓 Class 支援隱式轉換通常不是好事 -- 但也有例外，最常見的就是數值型別。書中以有理數 `Rational` 為例，他設計了一個允許 Int 隱式轉換成 Rational 的 Constructor。\n```cpp\nclass Rational {\n    public:\n        Rational(int numerator=0, int denominator=1); \n        // 允許 int-to-Rational 的隱式轉換\n\n        int numerator(); // 分子\n        int denominator(); // 分母\n        const Rational operator*(const Rational rhs) const;\n}\n```\n\n當實作乘法運算時，若兩個數字都是有理數沒有問題。與 Int 相乘，Int 在前項卻出了問題。\n```cpp\nRational oneEight(1, 8);\nRational oneHalf(1, 2);\n\nRational res = oneEight*oneHalf; // OK\nres = res*oneEight; // OK\n\n# eq3\nres = oneHalf*2; // OK: oneHalf.operator*(2)\n# eq4\nres = 2*oneHalf; // Error: 2.operator*(oneHalf)\n```\n在 eq4 會錯誤是因為，乘法隱含的是\n1. 尋找 `2` 的 `operator*`，但這不存在 (2 沒有對應的 class)\n2. Compiler 嘗試尋找 Namespace 下或 global scrope 下， Signature 能相配合的 `operator*`，也就是嘗試 `res = operator*(2, oneHalf)` 能否成立。但這也找不到而\n3. 沒招了，引發 error。\n\n而 eq3 能成功是因為 Compiler 嘗試先呼叫 `oneHalf.operator*`，2 在傳進去時會因為 Rational 接受隱式轉換 (implicit type conversion)，而若 constructor 限定要 explicit type conversion，甚至會連 eq3 都不過! \n\n## 原因: 只有列於參數列 (Parameter List) 才能參與隱式轉換\n\n綜合 eq3, eq4 所述，只有當 `int` 列在 `Rational` 物件後面，也就是成為 `Rational::operator*`  的 Parameter List，才是隱式轉換的合格參與者。\n\n## 解法:以 Non-member Function 定義 operator*\n只要將 `operator*` 拆離 class `Rational`，讓 operator 的兩個參數 `lhs` \u0026 `rhs` 都有參與隱式轉換的資格，那麼 eq3 和 eq4 就都可以通過了!\n甚至，這個 non-member function 也不需要定義為 friend，因為光透過 Rational 的 Public interface 就可滿足一切需求了! \n[[operator overloading]]\n\n```cpp\n\nclass Rational {\n    ...\n};\n\nconst Rational operator*(const Rational\u0026 lhs, const Rational\u0026 rhs) {\n    return Rational(lhs.numerator()*rhs.numerator(), \\\n\t\t\t\t\tlhs.denominator()*rhs.denominator());\n}\n```\n\t\n","lastmodified":"2024-02-23T05:15:51.43809902Z","tags":["cpp"]},"/notes/Focus/C++/%E7%9B%A1%E5%8F%AF%E8%83%BD%E5%BB%B6%E5%BE%8C%E8%AE%8A%E6%95%B8%E5%AE%9A%E7%BE%A9%E5%BC%8F%E7%9A%84%E5%87%BA%E7%8F%BE%E6%99%82%E9%96%93":{"title":"盡可能延後變數定義式的出現時間","content":"\n\u003e 不只延後變數的定義式的出現，甚至該嘗試延後這份定義直到能夠給它初始值引數為止。\n\n- 盡可能延後參數的定義，直到它被使用的前一刻再定義。\n\t- 過早的定義它，有可能根本沒用到就先 return 了，無謂的承受了該變數的 construct \u0026 destruct 成本。\n- 「前一刻」甚至是指: 得到初始值了再一口氣「建構並指定初始值」\n\n```cpp\nstd::string worstCase(const std::string\u0026 password) {\n\tstd::string encrypted;  // 過早宣告: 承受建構成本\n\tif (password.length() \u003c 8 ) {\n\t\treturn;  // 沒用到卻承受解構成本\n\t}\n\treturn encrypted(password); \n}\n\n// worse: 先定義、再給值\nstd::string encrypted;  // default constructor\nencrypted = password;   // copy assignment.\n\n// better: 最好在定義時就給值，只要呼叫一次 constructor\nstd::string encrypted(password); \n\n\n```\n\n## 迴圈怎麼辦\n\n採取方法 A 或 B 取決於\n1. 知道賦值成本 \u003c (建構+解構)\n2. 程式碼 Performance-sensitive\n否則，通常選 B 比較好。\n\n- 方法A: 先宣告，在迴圈中賦值\n\t- 1 ctor + 1 dtor + n 個賦值\n\t- 優點: 當 Class 賦值成本低於建構+解構，A方法比較高效，特別是 n 很大時。\n\t- 缺點: Variable Name Scope 比較大\n\n- 方法B: 在迴圈中創建\n\t- n ctor + n dtor\n\t- 除非滿足上述的兩個條件，否則通常此方法比較好，變數名稱影響的範圍只在 For Loop 當中。\n\n```cpp\n// Method A\nWidget w;\nfor (int i=0; i \u003c n; ++i) {\n\tw = ...;\n}\n\n// Method B\nfor (int i=0; i \u003c n; ++i) {\n\tWidget w(...);\n}\n```","lastmodified":"2024-02-23T05:15:51.43809902Z","tags":["cpp"]},"/notes/Focus/C++/%E7%A2%BA%E4%BF%9D-Derived-Class-%E5%92%8C-Base-Class-%E4%B9%8B%E9%96%93%E5%BF%85%E7%84%B6%E4%BF%9D%E6%8C%81-Is-a-%E9%97%9C%E4%BF%82":{"title":"確保 Derived Class 和 Base Class 之間必然保持 Is-a 關係","content":"\n\"Is A\" 關係，代表是用於 Base Class 的每一件事，**必定**也是用在 Derived Class，因為每一個 Derived Class 都 \"Is A\" Base Class。\n\n物件導向上的關係可能跟真實世界的理解有所不同，\n例如: 企鵝是一種鳥，若 \n- Base Class 為 Bird、Bird 裡面有個 function `fly`。\n- Derived Class 為 Penguin，Penguin 繼承 Bird，但企鵝不會飛!! \n這就不是一個適當的繼承， `fly` 並不能適用在 Derived Class Penguin。\n\n又比如，Rectangle 與 Square，Square 繼承 Rectangle，Square 有長寬必定相等的強烈保證。但在以下 function 中，傳入 `Square` 物件時，Assert 一定會發生!\n```cpp\nvoid makeBigger(Rectangle\u0026 r) // function to increase r’s area\n{\n\tint oldHeight = r.height();\n\tr.setWidth(r.width() + 10); // add 10 to r’s width\n\tassert(r.height() == oldHeight); // assert that r’s\n}\n```\n\n這就代表，在物件導向的視角，Rectangle 的每一件事並不能完全套用在 Square 上，這個繼承關係是有問題的。\n\n查覺到不適合以 Is A 關係塑模，可以考慮 [[Has A]] 跟 [[Is Implemented in Terms of]]，這些將在 [[確定 Composition 塑造的是 'Has-A'關係 或 '根據某物實作'的關係]]、 [[審慎的使用 Private 繼承]]\n","lastmodified":"2024-02-23T05:15:51.43809902Z","tags":["cpp"]},"/notes/Focus/C++/%E7%A2%BA%E5%AE%9A-Composition-%E5%A1%91%E9%80%A0%E7%9A%84%E6%98%AF-Has-A%E9%97%9C%E4%BF%82-%E6%88%96-%E6%A0%B9%E6%93%9A%E6%9F%90%E7%89%A9%E5%AF%A6%E4%BD%9C%E7%9A%84%E9%97%9C%E4%BF%82":{"title":"確定 Composition 塑造的是 'Has-A'關係 或 '根據某物實作'的關係","content":"\n## Has A 關係\n\"Has-A\" 指的是擁有一個 應用域 (application domain) 的物件，像是 \n- Person 'has a' name.\n- Person 'has a' address\n- ...\n這沒什麼爭議。\n\n## 根據某物實作出的關係\n這是指 實作域 (implementation domain)，表示 is-implemented-in-terms-of 關係。像是\n- buffer\n- mutex\n- search tree\n\n這麼說還是很抽象，舉例: \nstd::set 是一個以平衡樹實作的資料結構，每一個元素需要耗費三個 pointer，它重視速度大於空間用量。若我們有一個「空間用量比速度更重要」的需求，則無法使用 std::set，有需求自己撰寫 Template。\n現在，我們經歷了這一串掙扎: \n\n1. 實作 set 有很多種方法，想採用 linked list 的作法。\n2. 想到了 std::list 就是這樣的資料結構，我該繼承它嗎?\n3. 一旦繼承就代表 IS-A 關係，適用於 std::list 的每件事，這個新的 set 都可以接受\n4. 但是 std::list 允許重複的元素出現在容器中，set 不允許，在插入新元素 (insert) 時會做處置。這違反了 IS-A 規則。\n5. 不適合使用繼承。\n\n### 以一個 Private member data 擁有 (has a) 一個 std::list container\n正確的做法是，讓 Set 物件是根據一個 std::list 物件實作出來。我們會以一個 private member data 去 own (has a) 一個 std::list 物件，藉此達到 reuse linked list 的需求。\n\n```c++\ntemplate\u003cclass T\u003e // the right way to use list for Set\nclass Set {\npublic:\n\tbool member(const T\u0026 item) const;\n\tvoid insert(const T\u0026 item);\n\tvoid remove(const T\u0026 item);\n\tstd::size_t size() const;\nprivate:\n\tstd::list\u003cT\u003e rep; // representation for Set data \n};\n\n// 取一個函式實作舉例\ntemplate\u003ctypename T\u003e\nstd::size_t Set\u003cT\u003e::size() const\n{\nreturn rep.size();\n}\n...\n```\n\n對於每個 member function 的實作，在 own 了一個 `std::list` container 之後，可以很輕易的呼叫 std::list API 達到我們的需求，達到 reuse 的目的。甚至相當適合把這些 function 寫成 inline function! \n\n不過在做 inline 之前，先檢視 [[了解 Inline 的裡裡外外]]。\n","lastmodified":"2024-02-23T05:15:51.43809902Z","tags":["cpp"]},"/notes/Focus/C++/%E7%B5%95%E4%B8%8D%E9%87%8D%E6%96%B0%E5%AE%9A%E7%BE%A9%E7%B9%BC%E6%89%BF%E4%BE%86%E7%9A%84-Non-virtual-Function":{"title":"絕不重新定義繼承來的 Non-virtual Function","content":"![[Item36.png]]\n試想圖中這個繼承關係，`D` 繼承 `B`。而下面這段 code 分別以 `B` pointer 和 `D` pointer 持有 `x` 物件後呼叫 `mf` 方法。你會預期，這兩者的結果會相同，因為他們指向同一個物件。\n```cpp\nD x; // x is an object of type D\n\nB *pB = \u0026x; // get pointer to x\npB-\u003emf(); // call mf through pointer\n\nD *pD = \u0026x; // get pointer to x\npD-\u003emf(); // call mf through pointer\n```\n\n事實卻是，當 `D` 繼承 `B` 後如果自行實作了 `mf`，在以上這段例子中，`x` 會因為被 `B*` 或 `D*` 持有，而有不同的表現!! 當 `D` 有如此實作時，相當於藏住了 `B::mf`。參見 [[繼承時的名稱遮掩行為]]\n```cpp\nclass D: public B {\npublic:\n\tvoid mf();\n...\n};\n```\n\n造成這個現象的原因，參見 [[靜態綁定 (statically bound) 與動態綁定 (dynamically bound)]]\n\n## 絕對遵守 Is-A 關係\n本條款其實是 [[確保 Derived Class 和 Base Class 之間必然保持 Is-a 關係]] 的延伸，在\n[[區分介面繼承(interface)和實作繼承(implement)]] 說到 non-virtual 代表不變性，綜合此二條規定檢視這個繼承關係\n1. 適用 Base Class 的每件事都適用於 Derived Class。\n2. 對於 Non-virtual function，Derived Class 應該繼承**介面與實作**\n\n一旦 `D::mf` 重新定義，就違反了 Is-A 關係，特異性凌駕了不變性。","lastmodified":"2024-02-23T05:15:51.43809902Z","tags":["cpp"]},"/notes/Focus/C++/%E7%B7%A8%E8%AD%AF%E4%BE%9D%E5%AD%98-%E5%AE%A3%E5%91%8A%E5%BC%8F%E5%AE%9A%E7%BE%A9%E5%BC%8F%E8%88%87%E5%AF%A6%E4%BD%9C%E7%B4%B0%E7%AF%80":{"title":"編譯依存-宣告式、定義式與實作細節","content":"\n分辨以下三個名詞\n- 宣告式: 僅僅宣告某個類別名稱(?)\n- 定義式: 定義物件的 member data、function，透過定義式可以得知物件的大小\n- 實踐細節: 演算法細節。\n\n```cpp\nclass Date; // 宣告式\nclass Person {\npublic:\n\tPerson(const std::string\u0026 name, const Date\u0026 birthday,\n\tconst Address\u0026 addr);\n\nprivate: // ptr to implementation;\n\tstd::tr1::shared_ptr\u003cPersonImpl\u003e pImpl; // see Item 13 for info on\n};\n```\n\nCompiler 在編譯期間需要知道物件的大小，如下例。Compiler 可以輕鬆知道 built in type `int`的大小，但 `Person` 呢? 這得向它的定義式詢問要配多少空間。因此，會需要 `include person.hpp` \n```cpp\n#include \u003cperson.hpp\u003e\n\nint main()\n{\n\tint x; // 定義一個 int object\n\tPerson p(params) // 定義一個 Person object\n}\n```\n\n### 能用 object reference/pointer 就不要 own 一個 object。\nReference \u0026 Pointer 都可以 forward declare，宣告一個 object 卻必須 include header file (取得物件的定義式)。\n\n### 以宣告式取代定義式\n\n宣告一個 Function。而它要用到某個 Class的時候，都不需要該 Class 的定義。即使 Pass by value 也是!!! \n\n```cpp\nclass Date; // forward declare\n\nDate today(); // declare a function which return Date object. OK!!\nvoid clearAppointments(Date d); // Pass by value. OK!!\n```\n\n#### 即使回傳一個 object 也不需要定義式?\n在上例中，`today()` 函式回傳一個 `Date` 物件，卻不需要 include Date 的 header file? 聽起來很奇怪，但原理也極簡單。\n\n一旦有人試圖呼叫 `today()`，`Date` 的定義式需要先被曝光: 呼叫者需要先創建一個 Date 物件來接住 `today()` 的回傳值! 這個 include 的責任交給呼叫者就好。\n\n試想，這份 header file 並非每個人都要用到 `today()` 函式，導入 `Date.hpp` 就會增加依賴性。但，要呼叫 `today()` 的人**必須**導入 `Date` 的定義式 (hpp)，所以 include 可以交給 Client 端就好! \n\n### 為宣告式與定義式提供不同的 header file\n程式庫的提供者應該把宣告式和定義式分開，讓客戶端導入要用到的 header file 即可。\n接續前面的例子，當 Client 端想宣告 `today` 時，應該 `include  \"datefwd.h\"`，而非手動作 forward declaration，這是 Provider 必須提供的。而 `datefwd.h` 這個命名方式，則是跟 STL 的 [`iosfwd`](https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/std/iosfwd) 相同。\n\n```cpp\n#include \"datefwd.h\"\n\nDate today(); // declare a function which return Date object. OK!!\nvoid clearAppointments(Date d); // Pass by value. OK!\n```\n\nSTL 所提供的 `iosfwd` 包含了來自 `sstream, iostream, fstream ...` 多個 header file 的 forward declaration，也就是說，他們的定義式實際散在多個 header file ，但  forward declaration 集中放在同一個 header file。\n\n\n\n\n\n\n","lastmodified":"2024-02-23T05:15:51.43809902Z","tags":["cpp"]},"/notes/Focus/C++/%E7%B9%BC%E6%89%BF%E6%99%82%E7%9A%84%E5%90%8D%E7%A8%B1%E9%81%AE%E6%8E%A9%E8%A1%8C%E7%82%BA":{"title":"繼承時的名稱遮掩行為","content":"\n當 Derived 和 Base Class 有相同名稱的 function 時，Derived 的 function 會直接**遮住** Base Class 的同名稱 function (讓 Compiler 不會去找 Base Class 的該同名 function)，即使 signature 不同、不是做 override，也會找不到該 Base Class Function。\n\n![[Itm33.png]]\n如圖中撰寫，其結果: \n```cpp\nDerived d;\nint x;\n...\nd.mf1(); // fine, calls Derived::mf1\nd.mf1(x); // error! Derived::mf1 hides Base::mf1\nd.mf2(); // fine, calls Base::mf2\nd.mf3(); // fine, calls Derived::mf3\nd.mf3(x); // error! Derived::mf3 hides Base::mf3\n```\n","lastmodified":"2024-02-23T05:15:51.43809902Z","tags":["cpp"]},"/notes/Focus/C++/%E8%97%89%E7%94%B1-Function-Pointer-%E5%92%8C-tr1-function-%E6%89%8B%E6%B3%95%E5%AF%A6%E7%8F%BE-Strategy-Pattern":{"title":"藉由 Function Pointer 手法實現 Strategy Pattern","content":"\nNVI 方法為 Public Virtual Function 提供了替代方案，但仍沒有脫離 virtual。\n新的做法是，把 Function 用 Function Pointer 傳入，這實際上是  [[Classic Strategy Pattern|Strategy Pattern]] 的一種實作。\n\n```cpp\nclass GameCharacter; // forward declaration\n// function for the default health calculation algorithm\nint defaultHealthCalc(const GameCharacter\u0026 gc);\nclass GameCharacter {\npublic:\n\ttypedef int (*HealthCalcFunc)(const GameCharacter\u0026);\n\n\texplicit GameCharacter(HealthCalcFunc hcf = defaultHealthCalc)\n\t: healthFunc(hcf) {}\n\t\n\tint healthValue() const { return healthFunc(*this); }\n\nprivate:\n\tHealthCalcFunc healthFunc;\n}\n```\n\n更進一步的，使用 `tr1::function`，使得任何像是 function 一般 callable 且 signature 符合的 callable 物件 (`std::tr1::function\u003cint (const GameCharacter\u0026)\u003e`)，都可以是被傳入的物件。\n[[C++11 std function]]\n\n```cpp\nclass GameCharacter; // as before\nint defaultHealthCalc(const GameCharacter\u0026 gc); // as before\nclass GameCharacter {\npublic:\n// HealthCalcFunc is any callable entity that can be called with\n// anything compatible with a GameCharacter and that returns anything\n// compatible with an int; see below for details\ntypedef std::tr1::function\u003cint (const GameCharacter\u0026)\u003e HealthCalcFunc;\nexplicit GameCharacter(HealthCalcFunc hcf = defaultHealthCalc)\n: healthFunc(hcf )\n{}\nint healthValue() const \n{ return healthFunc(*this); }\n...\nprivate:\nHealthCalcFunc healthFunc;\n}\n```\n\n## 優點\n- 可以在 RT 期間決定傳入的函式\n\n## 缺點\n當我們想計算的內容都可以用 Public Interface 取得相關資訊，沒有問題。但如果需要取得 non-public data (內部資訊)，就有疑慮了。\n- 讓 class 的某個**內部**機能依賴於外部的某個 [[non-member \u0026\u0026 non-friend function]] 是個爭議。\n- 解決作法是弱化 class 的封裝，宣告該 function 為 friend function 就是一種弱化的作法，或是提供一個 public getter。\n\n","lastmodified":"2024-02-23T05:15:51.43809902Z","tags":["cpp"]},"/notes/Focus/C++/%E8%97%89%E7%94%B1-Non-Virtual-Interface-%E6%89%8B%E6%B3%95%E5%AF%A6%E7%8F%BE-Template-Method-Pattern":{"title":"藉由 Non-Virtual Interface 手法實現 Template Method Pattern","content":"\u003e The Template Method Pattern via the Non-Virtual Interface Idiom\n\n這個方法是 Design Pattern [[Template Method]] 的表現形式，而跟 C++ Template 無關。\n\n## Non-Virtual Interface (NVI)\nNVI 主張 Virtual 應為 Private，如果有暴露的需求，則應該以一個 Public non-virtual function (as a *wrapper*) 呼叫 Private virtual function。\n\n## wrapper function\nWrapper 的優點可以把一些呼叫 virtual 前後需要處理的事情藏起來，確保這些事情必定會執行: \n例如\n- 在呼叫 virtual function 前: 為 Mutex 上鎖, Log entry, 驗證事前條件...\n- 在呼叫 virtual function 之後: 為 Mutex 解鎖, 驗證事後條件...\n\n如果把 Virtual 設成 Public (相當允許客戶端自行重新定義它)，這些事件將無處置放，也無法確保事前事後條件絕對會被執行 (Client 端實作時可能會忽略)。\n\n## 保留何時呼叫 virtual function 的權利\nNVI 手法把「如何實現機能 (重新定義函式)」的權利交給了客戶端，「何時呼叫函式 (when to call non-virtual function)」的權利留在手上。\n\n## NVI 允許 Protected\n某些時候，Derived Class 會需要呼叫 Base Class 的 function，當這個 function 正是前面所說 NVI 的主角 -- 是一個 virtual function 的時候，它必須得宣告成 protected，這在 NVI 中也是被允許的。\n\n某些時候，virtual function 必須是 Public (ex. 多型用途的 Base Class 解構式, [[不要為非多型用途的 Base Class 宣告 Virtual Function]]) 他們則不是用於 NVI 手法。\n","lastmodified":"2024-02-23T05:15:51.43809902Z","tags":["cpp"]},"/notes/Focus/C++/%E8%A7%A3%E6%A7%8B%E5%BC%8F%E8%88%87%E7%95%B0%E5%B8%B8":{"title":"解構式與異常","content":"\u003e 在 C++11 中，Destructor and `delete` 被自動宣告為  `noexcept`。\n\n\n\n[[Modern C++ noexcept]]\n\n## 情境: 當Destructor 必須執行某項會丟Exception 的程序\n舉例，我們有一個資料庫連線的 class `DBConnection`，這類資源管理的 Class 在 [[Chapter3]] 中會有更詳細的探討。\n```cpp\nclass DBConnection {\npublic:\n...\nstatic DBConnection create();   // function to return DBConnection objects; params omitted for simplicity\nvoid close(); \n// close connection; throw an exception if closing fails\n};  \n```\n\n\n### 直接 Catch Exception\n為了防止 client 沒有 close connection 就直接刪除物件，我們需要在 destructor 呼叫 `close`，然而這個 function 有丟出 exception 的風險。\n有兩種做法可以簡單的解決\n1. 使用 `std::abort` 提前中止程式，它可以搶在 Exception 傳出去之前，也就是 Undefined Behavior 傳出去之前，強迫程式結束。\n\t```cpp\nDBConn::~DBConn() {\n\ttry { db.close(); }\n\tcatch (...) {\n\t\t// make log entry that the call to close failed;\n\t\tstd::abort();\n\t}\n}\n\t```\n2. 吞下異常。一般來說，這是個壞主意，它抑制了錯誤被知道的機會。\n\t```cpp\nDBConn::~DBConn() {\n\ttry { db.close(); }\n\tcatch (...) {\n\t\t// make log entry that the call to close failed;\n\t}\n}\n\t```\n\n哪種方法好，端看情境如何取捨。不過此兩者做法都不是根本解決之道。\n\n## 解決方法: 讓 Cilent 自己接住 Exception\n更好的做法是重新設計 Interface，讓 client 端自己 `close`，對 Exception 做反應。並在 destructor 當中再設一道確保關閉的雙重保障 -- 如果客戶還是忘了關，再讓 destructor 動手吧! \n\n\n## 質疑\n- 轉移責任到 Client 身上的嫌疑? 並沒有，因為 destructor 中也是有一道 Check。\n- 違反[[讓介面易於被使用，不易誤用]]? \n\n如果某個操作有 raise exception 的風險，又必須處理該 exception，這個異常必須來自 destructor 之外的某個 function (此例: 來自 `close`)，而這有讓 client 端接手的必要性，將它轉移出 destructor 能避免 undefined behavior 的發生有更大的價值。\n","lastmodified":"2024-02-23T05:15:51.43809902Z","tags":["cpp"]},"/notes/Focus/C++/%E8%A8%AD%E8%A8%88%E6%96%B0-Class-%E7%9A%84%E6%BA%96%E5%89%87":{"title":"設計新 Class 的準則","content":"在設計 class 之前，思考以下問題\n- 記憶體如何產生跟銷毀? (參見第八章)\n- 物件初始化與賦值的差別? Constructor \u0026 Assignment\n\t-  [[Effective C++ Outline#條款4 確定物件在使用前已經初始化 |條款4 確定物件在使用前已經初始化]]\n- Pass by value 對它代表甚麼? Copy constructor\n- Member data 的合法值?\n\t- 在不管是 constructor, assignment, setter function 在設 data 時，都需要進行錯誤檢查。\n\t- 這意味著你需要考量函式拋出的意外。\n- 它需要配合某個繼承圖系(inheritance graph) 嗎?\n\t- 會受到父輩們的約束，特別是函式是 virtural or non-virtual [[區分介面繼承(interface)和實作繼承(implement)]]、[[Item36 Never redefine an inherited non-virtual function]]。\n\t- 如果允許其他類別繼承此 class，請將必要的函式宣告為 virtual，特別是 destructor。\n\t\t- [[Effective C++ Outline#條款7 為多型用途的基礎類別宣告 virtual 解構式|條款7 為多型用途的基礎類別宣告 virtual 解構式]]\n- 需要考量轉換嗎? 隱性轉換與顯性轉換?\n- 甚麼運算子與函式對此新類別式合理的?\n\t- [[Non-member \u0026\u0026 Non-friend Function 的封裝度優於 Member Function]]\n\t- [[當所有的參數都需要型別轉換，採用 Non-member Function]]\n\t- [[盡可能延後變數定義式的出現時間]]\n- 什麼標準宣告式是需要駁回的? 請用 `delete` 明確刪除它。\n- 哪些 member 需要暴露出來? (public/private/protected)\n- 什麼是它的未宣告介面(undeclared interface)?\n\t- 這我看不懂。\n- 這個新的 class 有多一般化? 若要定義的是 type family (一堆 type) ，是否該採用 class template?\n- ","lastmodified":"2024-02-23T05:15:51.43809902Z","tags":["cpp"]},"/notes/Focus/C++/%E8%AE%93%E4%BB%8B%E9%9D%A2%E6%98%93%E6%96%BC%E8%A2%AB%E4%BD%BF%E7%94%A8%E4%B8%8D%E6%98%93%E8%AA%A4%E7%94%A8":{"title":"讓介面易於被使用，不易誤用","content":"\n## 用 `struct` 包覆簡單的資料結構可以帶來可讀性\n\n考量下面的例子: \n\n```cpp\nclass Date {\npublic:\n\tDate(int month, int day, int year);\n}\nDate(3, 31, 1999); // 正確\nDate(30, 3, 1999); // 可能會誤打\nDate(3, 40, 1999); // 可能有無效值\n```\n\n如果我們改以 `struct`如下，你幾乎不會犯下寫錯格的錯，Compiler 會自動提醒! 甚至可以在 Struct 內簡單的做數值檢驗。\n\n```cpp\nstruct Month;\nstruct Day;\nstruct Year;\n\nclass Date {\npublic:\n\tDate(Month m, Day d, Year y);\n}\n\nDate(Month(3), Day(31), Year(1999)); // 正確\nDate(Day(3), Month(31), Year(1999)); // 型別錯誤\n```\n\n\n## 以函式取代物件\n\n像是月份這樣有一定的範圍，甚至可以直接列舉 12 月份，Client 端透過介面得到月份物件，幾乎沒有錯誤數值的問題!!\n\n類似用法可以參見 [[Static Object]] 當中的 non-local static object 初始化問題。\n\n```cpp\nclass Month {\npublic:\n\tstatic Month Jan() {return Month(1)};\n\tstatic Month Feb() {return Month(2)};\n\t...\nprivate:\n\texplicit Month(int m);\n}\nDate(Month::Jan(), Day(30), Year(1999));\n```\n\n## 和內建型別的行為一致，不要搞怪\n\n當有和 STL lib 相似的屬性時，盡量用一樣的形式。\n\n## 任何介面如果有要求客戶「記得做」某件事，就有「不正確使用」的傾向，因為客戶可能會忘記。\n\n例如: 比起回傳一個 raw pointer 並期許客戶端記得刪除記憶體，回傳 smart pointer 能解決問題。\n\n防範客戶端可能發生的錯誤是有代價的，像是 Shared pointer，它比原本的體積更大、且更慢。但在許多程式中這些成本的影響並不顯著，防範客戶端愚蠢行為帶來的益處卻極為顯著。\n\n\n## Return Const Value\n避免回傳值被修改，如此例中，類別 `Rational` (有理數) 的乘積符號禁止其回傳值被賦予值 (assignment)。\n\n```cpp\nclass Rational { ... }; \nconst Rational operator*(const Rational\u0026 lhs, const Rational\u0026 rhs);\n```\n\n聽起來有點怪，但它可以預防 client 端寫出這種 code: \n```cpp\nRational a, b, c;\n(a*b) = c;\n\nif (a*b = c) { ... };\n```\n\n我想，作者的舉這個例子有 Defensive programming 的概念在。如若這些變數是內建型別 (ex. int)，這種寫法直接就會被擋掉。但像此例，它們是 User-defined 的型別，對於設計 class 的 designer 而言，最好將這種無意義的行為擋掉。","lastmodified":"2024-02-23T05:15:51.43809902Z","tags":["cpp"]},"/notes/Focus/C++/%E9%81%8B%E7%94%A8%E6%88%90%E5%93%A1%E5%87%BD%E5%BC%8F%E6%A8%A1%E6%9D%BF%E6%8E%A5%E5%8F%97%E6%89%80%E6%9C%89%E7%9B%B8%E5%AE%B9%E7%9A%84%E5%9E%8B%E5%88%A5":{"title":"運用成員函式模板，接受所有相容的型別","content":"\n參考以下繼承體系的範例: 在原生的 Pointer 系統當中，在合理的繼承關係之下，這些不同類別在 Raw Pointer 很容易互相轉換。\n\n```cpp\nclass Top { ... };\nclass Middle: public Top { ... };\nclass Bottom: public Middle { ... };\nTop *pt1 = new Middle; // convert Middle* ⇒ Top*\nTop *pt2 = new Bottom; // convert Bottom* ⇒ Top*\nconst Top *pct2 = pt1; // convert Top* ⇒ const Top*\n```\n\n然而思考以下範例: 我們使用 template 完成一個 `SmartPtr`，它能像 RAW pointer 一般互相轉換嗎? 沒辦法，以下這段程式不會通過編譯。\n\n```cpp\ntemplate\u003ctypename T\u003e\nclass SmartPtr {\npublic: // smart pointers are typically\nexplicit SmartPtr(T *realPtr); // initialized by built-in pointers \n...\n};\n// convert SmartPtr\u003cMiddle\u003e ⇒ SmartPtr\u003cTop\u003e\nSmartPtr\u003cTop\u003e pt1 = SmartPtr\u003cMiddle\u003e(new Middle); \n// convert SmartPtr\u003cBottom\u003e ⇒ SmartPtr\u003cTop\u003e\nSmartPtr\u003cTop\u003e pt2 = SmartPtr\u003cBottom\u003e(new Bottom);\n// convert SmartPtr\u003cTop\u003e ⇒ SmartPtr\u003cconst Top\u003e\nSmartPtr\u003cconst Top\u003e pct2 = pt1; \n```\n\n即使 Middle 繼承自 Top，透過**模板具現化的類別** `SmartPtr\u003cTop\u003e` 跟 `SmartPtr\u003cMiddle\u003e` 之間，卻**沒有任何關係**.... 他們的關係大概跟 `vector\u003cdouble\u003e` 和 `Widget` 這般疏遠 -- 牛馬不相干! \n若希望這個客製化的 `SmartPtr` 可以有如 Raw Pointer 一般能夠輕易地轉換，需要費點功夫。\n\n要讓上面的範例通過編譯，必須要有對應的、合法的 Copy Constructor。難道要如此逐一列舉....?\n\n\u003e[!todo]\n\u003e確定是 ctor?? copy assignment??\n\n```cpp\ntemplate\u003c\u003e\nclass SmartPtr\u003cTop\u003e {\npublic:\n    explicit SmartPtr(Top *realPtr) { heldPtr = realPtr; }\n    Top* get() const { return heldPtr; }\n\n\tSmartPtr(const SmartPtr\u003cMiddle\u003e\u0026 other) { heldPtr = other.get(); }\n\tSmartPtr(const SmartPtr\u003cBottom\u003e\u0026 other) { heldPtr = other.get(); }\n    void print() { heldPtr-\u003eprint(); }\nprivate:\n    Top *heldPtr;\n};\n\n```\n但我們不可能把所有的組合列舉出來，這樣一旦繼承體系中有新增/更動類別，就需要再重寫。\n\n[[Template and Generic Programming]]\n\n\n","lastmodified":"2024-02-23T05:15:51.43809902Z","tags":["cpp"]},"/notes/Focus/C++/%E9%81%BF%E5%85%8D%E5%82%B3%E5%9B%9E-Handles-%E6%8C%87%E5%90%91%E7%89%A9%E4%BB%B6%E7%9A%84-Private-Protected-Member-Data":{"title":"避免傳回 Handles 指向物件的 Private \u0026 Protected Member Data","content":"\n\u003e 消滅 handles 的暴露可能\n\n\n## 大忌: 回傳一個 Non-Const handles \n在 [[打破 Constness 限制#Physical Constness]] 當中，我們探討過 Physical (bitwise) Constness 的問題。\n讓 Getter 回傳一個 non-const reference 指向 member data，會出現讓 private data 暴露在外 (等同於 public) 的詭異現象。\n此問題不限於 ref，pointer、iterator 這些 handles (用以取得某個物件)，都有相同的風險。\n\n## 回傳一個 Const Handles 就沒問題了嗎?\n\n```cpp\nstruct RecData {\n\tPoint ulhc;\n\tPoint lrhc;\n}\n\nclass Rectangle {\npublic:\n\tconst Point\u0026 upperLeft() const {return pData-\u003eulhc;}\n}\n\nclass GUIObj;\nconst Rectangle bbox (cosnt GUIObj\u0026 obj);\n\nGUIObj* pgo;\nconst Point* pUpperLeft = \u0026(bbox(*pgo).upperLeft()); // dangling\n```\n\n此例的第 15 行，\n1. 相當於先創建了 `tmp = bbox(*pgo*)`\n2. 對 `tmp.upperLeft()`取得一個 `const Point\u0026` 內部資料 ``\n3. 對此內部資料取 address，傳給 `pUpperLeft`\n4. 15 行執行完畢，`pUpperLeft` 直接變成 dangling pointer\n\n最大的問題是，**handles 比其所屬的物件更長壽**!! 最簡單的就是消滅 handles 的暴露可能。\n\n但並不意味不能回傳 handles，有時是必須的，像是 `operator[]` 就必須回傳 reference 指向 container 內部元素。\n\n\n\n\n\n[[Effective C++ Outline#條款3 盡可能使用 const]]\n","lastmodified":"2024-02-23T05:15:51.43809902Z","tags":["cpp"]},"/notes/Focus/C++/%E9%97%9C%E9%8D%B5%E5%AD%97-typename-%E5%9C%A8-Template-%E4%B8%AD%E7%9A%84%E6%84%8F%E6%B6%B5":{"title":"關鍵字 typename 在 Template 中的意涵","content":"試想，下例中使用 `class` 跟 `typname` 之間有甚麼區別?\n```c++\ntemplate\u003cclass T\u003e class Widget; // uses “class”\ntemplate\u003ctypename T\u003e class Widget; // uses “typename”\n```\n答案是意義完全相同，在宣告 template 參數時，這兩個 keywords 並沒有差別，但 `class` 與 `typename` 並不是總是等價。\n\n\n## 指涉 (refer to)\n\n- 從屬名稱 (dependent names): 在 template 當中的某個**名稱**相依於 template 參數。\n- 巢狀從屬名稱 (nested dependent names): 當從屬名稱在 template 內並且是 nested 的。(ex. `T::member_data`)\n- 巢狀從屬型別名稱 (nested dependent type names): 是巢狀從屬名稱，且這個名稱代表一個**型別** (Type)。(ex. `T::`)\n- 非從屬名稱 (non-dependent names): 類別與 template 參數沒有相依性。\n\n## 區分「巢狀從屬型別名稱」與「巢狀從屬名稱」\n巢狀從屬型別名稱會造成 parsing 困難，以下例來說，在不知道 `C` 是什麼之前，要如何解讀 `C::const_iterator * x;`?\n1. `C::const_iterator` 可能是一個 member data? 而 `x` 可能是一個 global int variable !\n2. `C` 是一個 STL container，則 `const_iterator` 是一個 nested type name.\n隨著解讀的方式不同，`*` 符號也有不同的意思。\n1. 表示乘法\n2. 表示 Type Pointer\n\n這就是 Compiler 遇到的的困境。\n\n```c++\ntemplate\u003ctypename C\u003e\nvoid print2nd(const C\u0026 container)\n{ \n\tC::const_iterator * x;\n\tC::const_iterator y;\n}\n```\n\n## Typename 必須做為 Nested Dependent Type Name 的前導詞\n在上述的困境 (nested dependent name OR nested dependent *type* name ) 裡，Compiler 預設行為是 **假設 C 並非一個型別**，除非以 `typename` 明確告訴它這是型別。\n按照這個規則再看一次上例，由於沒有 typename 明確指涉 C::const_iterator 是 type name，compiler 認為這代表一個 member data，那 `y` 是什麼? 以空白相隔? 這違反語法，會直接引發錯誤。\n\n作法如下，直接在想要指涉的 nested dependent type name 前面加上關鍵字 `typename` 即可，在 signature 或是直接寫在 function body 內都可以使用這個 keyword。甚至與 `typedef` 結合也沒問題，[[typedef and using]]\n\n```c++\ntemplate\u003ctypename C\u003e\nvoid f(const C\u0026 container, typename C::const_iterator* x);\n\n\ntemplate\u003ctypename C\u003e\nvoid print2nd(const C\u0026 container)\n{ \n\ttypename C::const_iterator y = container.begin();\n\ttypedef typename C::const_iterator citor;\n}\n```\n\n`typename` 除了用在 template 參數，就只允許被使用於**指涉 nested dependent type name**，非 nested 的不能加。\n```c++\ntemplate\u003ctypename C\u003e // OK, 等價於 `class`\nvoid f( const C\u0026 container, // non-nested name 不能以 typename 指涉\n\t\ttypename C::iterator iter); // nested name 必須以 typename 明確指涉，否則編譯會有問題\n```\n\n## Typename 不得用在 Base Classes List 與 Member Initializer List \n\n- Base Class List: 繼承時候冒號後面那一串，不能、也不需要用 `typename` 標示 (能放在這裡就已經是 type 了)\n- Member Initializer List 也不需要\n除了上述的兩個例外，其他地方照樣能用 `typedef`\n\n```c++\ntemplate\u003ctypename T\u003e\nclass Derived: public Base\u003cT\u003e::Nested { // base class list: typename not allowed\npublic:\nexplicit Derived(int x): \n\tBase\u003cT\u003e::Nested(x)  // base class identifier: \n\t\t\t\t\t\t// in member initializer list typename not allowed\n{\n\ttypename Base\u003cT\u003e::Nested temp;  // use of nested dependent type\n\t\t\t\t\t\t\t\t\t// name not in a base class list or\n} // as a base class identifier in a mem. init. list: typename required\n};\n```\n\n\u003e [!todo]\n\u003e 實驗 mem init list 為何不用?\n\n\n\n","lastmodified":"2024-02-23T05:15:51.43809902Z","tags":["cpp"]},"/notes/Focus/C++/%E9%9C%80%E8%A6%81%E5%9E%8B%E5%88%A5%E8%BD%89%E6%8F%9B%E6%99%82%E8%AB%8B%E7%82%BA%E6%A8%A1%E6%9D%BF%E5%AE%9A%E7%BE%A9%E9%9D%9E%E6%88%90%E5%93%A1%E5%87%BD%E5%BC%8F":{"title":"需要型別轉換時請為模板定義非成員函式","content":"文章 [[當所有的參數都需要型別轉換，採用 Non-member Function]] 中提到，能被隱式轉換的只有位於參數列的對象，因此針對 `operator*` 採用了 Non-member function。\n\n現在，將這個 `operator*` 改成 Template function。\n\n```cpp\ntemplate\u003ctypename T\u003e\nclass Rational {\npublic:\n\tRational(const T\u0026 numerator = 0, // see Item 20 for why params\n\tconst T\u0026 denominator = 1); // are now passed by reference\n\tconst T numerator() const; // see Item 28 for why return\n\tconst T denominator() const; // values are still passed by value,\n};\n\ntemplate\u003ctypename T\u003e\nconst Rational\u003cT\u003e operator*(const Rational\u003cT\u003e\u0026 lhs, const Rational\u003cT\u003e\u0026 rhs) \n{  \n\t\n}\n```","lastmodified":"2024-02-23T05:15:51.43809902Z","tags":["empty"]},"/notes/Focus/C++/%E9%9D%9C%E6%85%8B%E7%B6%81%E5%AE%9A-statically-bound-%E8%88%87%E5%8B%95%E6%85%8B%E7%B6%81%E5%AE%9A-dynamically-bound":{"title":"靜態綁定 (statically bound) 與動態綁定 (dynamically bound)","content":"## 靜態綁定 (statically bound, early binding) \n- Non-virtual function\n- Default Parameter\nNon-virtual function 是 statically bound，也就是說，由 Base Class Pointer 喚起的物件在呼叫 non-virtual function 時，就只會呼叫 Base Class 的版本，即使 Base Class Pointer 指向的物件是 Derived Class Instance 亦然。\n這會形成 [[絕不重新定義繼承來的 Non-virtual Function]] 當中敘述的，由 Base Class Pointer 和 Derived Class Pointer 指向同一個物件，卻導致不同的行為結果這種，非預期中的奇怪狀態。不只是 Pointer 有此問題，Reference 也相同。\n\n## 動態綁定 (dynamically bound, late binding)\n- virtual function\nvirtual function 走的卻是動態綁定 (dynamically bound)，它不受此困擾，不管由 `B*` 或 `D*` 指向物件 `x` (`D` 的 instance)，都會喚起 `D::func`。\n\n## 物件的動態型別與靜態型別\n\n物件分成動態與靜態型別\n- 靜態型別 (static type): 宣告時的型別\n- 動態型別 (dynamic type): 執行期間所指的物件的型別\n![[Item37.png]]\n\n```cpp\nShape *ps; // static type = Shape*\nShape *pc = new Circle; // static type = Shape*\nShape *pr = new Rectangle; // static type = Shape*\n\nps = pc; // ps’s dynamic type is now Circle*\nps = pr; // ps’s dynamic type is now Rectangle*\n```\n\nVirtual function 透過動態綁定而來，因此呼叫 virtual function 時是叫到哪一個 function，是看當下動態型別。\n```cpp\npc-\u003edraw(Shape::Red); // calls Circle::draw(Shape::Red)\npr-\u003edraw(Shape::Red); // calls Rectangle::draw(Shape::Red)\n```\n然而，參數是靜態綁定的，假設 `Shape::draw` 的預設參數為 `Red`，`Rectangle` 預設參數為 `Green`，而使用 Shape pointer `pr` 不給輸入參數的呼叫 `draw` 時，卻會呼叫 `Rectangle::draw` 但傳入 `Shape::draw` 的預設參數! \n\n```cpp\n// a class for geometric shapes\nclass Shape {\npublic:\n\tenum ShapeColor { Red, Green, Blue };\n\t// all shapes must offer a function to draw themselves\n\tvirtual void draw(ShapeColor color = Red) const = 0;\n};\n\nclass Rectangle: public Shape {\npublic:\n\t// notice the different default parameter value — bad!\n\tvirtual void draw(ShapeColor color = Green) const;\n};\n\nclass Circle: public Shape {\npublic:\n\tvirtual void draw(ShapeColor color) const;\n};\n\npr-\u003edraw(); // calls Rectangle::draw(Shape::Red)!\n```\n\n預設參數由靜態綁定，是 C++ 為了執行效率的考量，在編譯時就已經決定好。\n## 以 NVI 手法解決預設參數是靜態綁定帶來的問題\n透過 [[藉由 Non-Virtual Interface 手法實現 Template Method Pattern|NVI]] 手法: 以一個 public non-virtual function 呼叫 private virtual function，是給予 virtual funciton 預設參數的好方法。\n\n1. 宣告一個 public non-virtual function，給予預設的輸入參數。基於繼承的 Is-A 關係，這個 function 不會被 override。\n2. 定義一個 pure virtual function，讓 Derived Class 繼承介面，自行實作。\n3. 在 public non-virtual function 當中呼叫該 pure virtual function，並把預設的參數傳入。\n\n如此一來，將不會有 Derived Class 擅自改寫預設參數的問題。\n\n","lastmodified":"2024-02-23T05:15:51.43809902Z","tags":["cpp"]},"/notes/Focus/C++/80-20-Rule":{"title":"80-20 Rule","content":"## Effective C++ 的 80/20 Rule\n程式往往把 80% 的時間花費在 20% 的程式碼上，你應該針對這 20% 的程式碼做優化，才能有效增進程式的效率。\n\n\n## 網路資源\n「80/20法則」又被稱為「帕雷托法則（Pareto principle）」，維基百科上對這個條目的解釋是：「在眾多現象中，80％的結果取決於20％的原因」\n\n\u003e 80％的收穫源自於20％的努力，其餘20％的結果卻必須付出80％的力氣才能獲得。\n\n善用這種因與果之間不平衡的自然現象，就可以發揮以少博多的槓桿效應。  \n  \n在設計上所面臨的許多限制條件，彼此之間往往是相衝突的。好比，我一再提到的彈性和複雜度的取捨──想增加彈性，就得付出提高複雜度做為代價，到底我們需要多少彈性？又得付出多少複雜度做為代價，才能換取到這些彈性呢？我們在購買各種商品的時候，常常會談到C/P（Cost/Performance）比的概念，事實上，設計上的取捨也可以套用相同的觀念。究竟我們以多少的A去換取多少的B是最划算的呢？而80/20法則就是在告訴你，要適當運用、操作20與80這種不平衡的因果關係，而且就因為這種情況，使得槓桿效應得以發揮作用。  \n  \n就好比，在許多系統的開發中，付出20％的複雜度，多半可以換取到80％的彈性，但想要得到100％的彈性，又得付出其餘的80％的複雜度。對我們來說，用20％的複雜度去換80％的彈性，是C/P比最高的。\n\n摘錄自: https://www.ithome.com.tw/article/47319","lastmodified":"2024-02-23T05:15:51.402099014Z","tags":["cpp"]},"/notes/Focus/C++/Array-As-an-Argument":{"title":"Array As an Argument","content":"\u003e- 當 Template 定義成 Pass by value 形式時，傳入的 array name 會轉換成 point to array (the first item)。\n\u003e - 當 Template 定義成 Pass by ref 形式時，傳入的 array name 是 **真的傳入整個 Object**。\n\n在進入正文之前須釐清一個觀念，array type 和 pointer type 是不同的，儘管有時候他們「看起來」可以互換。\n```cpp\nconst char name [] = \"AAA\";   // Type of name is: const char[13]\nconst char* ptrToName = name; // array decays to pointer\n```\n\n`const char[13]` 和 `const char*` 是不同的!! 但是由於有 array-to-pointer decay(退化) rule的規則在，因此上面範例中的 code 是可 compiled 的。\n\n```cpp\ntemplate \u003ctypename T\u003e\nvoid f(T param);\n```\n\n在進入 template deduction 前，先看 array 作為 function parameter 宣告時的兩種形式，這兩種宣告在執行上是等價的。\n```cpp\nvoid myFunc(int param[]); // Is treated as a pointer declaration\nvoid myFunc(int* param);  // Like this.\n```\n\nArray Parameter 和 Pointer Parameter 之間的等價性源自於 C 語言，並且在 C++ 中保留，這使人誤解 Array Type 和 Pointer Type 是相同的。\n\n根據在 Function Parameter 當中，Array Parameter 被當作 Pointer Parameter 對待，當 Array 被傳入 Template 時會被推斷成 Pointer Type。\n```cpp\nf(name); // T: const char*\n```\n\n但是!! 雖然在 Function Declaration 中，以 Array Parameter 的形式宣告會被以 Pointer 的方式對待，而非以整個 Array 的形式對待，卻可以宣告 **Array Reference** ，就可以傳整個 array 進去。\n\n```cpp\ntemplate \u003ctypename T\u003e\nvoid f(T\u0026 param);\n\nf(name); // pass array to f\n\t\t // T is const char[13]\n\t\t // ParamType is const char(\u0026)[13]\n```\n\n有趣的是，不只 `T` 可以被推斷，甚至連 number of elements in array `N` 也可以作為推斷的項目之一。\n```cpp\ntemplate \u003ctypename T, std::size_t N\u003e\nconstexpr std::size_t arraySize(T (\u0026)[N]) no except\n{\n\treturn N;\n}\n```\n- About `constexpr`: [[Item15 constexpr]]\n- About `noexcept`: [[Modern C++ noexcept]]","lastmodified":"2024-02-23T05:15:51.402099014Z","tags":["cpp"]},"/notes/Focus/C++/Associative-Containers":{"title":"Associative Containers","content":"Chapter5\n## Associative Containers\n- Unordered containers have better performance.\n\n| | Unordered Container | Ordered Container |\n| --- | --- | --- |\n| Access Time | Constant | Logarithmic |\n\t\n## Ordered Container \n\n### map \u0026 multimap \n\n對 key 與 value 有一些規定\n1. Key: sortable \n2. Value: default Constructible \n3. 兩者皆須  copyable, movable \n\n\u003e 懷疑這邊 default constructible 是否為硬性規定，還是在試圖呼叫 operator[] 的時候 compile 不會過? \n\n比較準則 (comparison criterion) 預設是 `std::less`，如果是 User-defined type 則預設使用 operator `\u003c` 排序。也就是說，如果 key 是 User-defined type 則必須 overload `operator\u003c`。\n\n比較準則可以替換，但必須遵守 strict weak ordering。比起重新定義一個 criterion，直接使用 STL 寫好的 comparison criterion 更快，像是 `std::greater` (template)。\n\n### std::map 有如 associative array \nstd::map 與 std::vector 一樣支援 `operator[]`，std::map 像是一個接受 index 為任意 type 的 vector。\n此外，std::map 還支援 member function `at`，與 `operator[]` 的差別大概在於\n- `operator[key]`: 當找不到 key 的時候，會自動 insert key \u0026 創建 value\n- `at(key)`: 當找不到 key 的時候，會引發 exception。\n## Unordered Container\n比起 Ordered Container，Unordered Container 擁有比較豐富的 API、並且 key 是未經排序的。\n### Performance \n由於使用 hash function，unordered container 在 access 上的複雜度是 conostant，ordered 則是 `O(logn)`。\n### Hash Function \nUnordered_map 把 indexes 儲存於 bucket 當中，\n\nHash function 決定兩件事\n1. Index 應該存在哪一個 bucket\n2. 把 key map 給對應的 index (hash code, hash value)\n\n![[Simple Unordered association container.png]]\n如果不同 key 對應到同一個 index，就稱為 collision，這應該避免。\n\nIndexes 在 Bucket 當中通常以 linked list 的形式儲存，從 Key 取得 Value 時，access 到 bucket 的複雜度是 constant，但如果一個 bucket 中有兩個以上的 index，要拿到對應的 index 的複雜度是線性的。\n\n- Capacity: bucket 的數量\n- Load factor: 每個 bucket 中的元素平均數量\n\n一個好的 hash function 應該盡量避免 collision，並且在放 index 於 bucket 時要均勻分布。\n\n![[Hash Function-load factor.png]]\n#### Rehash \n通常 C++ Runtime 中發現 load factor 超過 1 的時候就會新增 bucket (使得 access 的複雜度永遠是 constant)，這個過程就是 rehashing.\n\n### API \n- `max_load_factor()`: 可以得到當前 container 所允許的 load_factor 最大值，透過設定這個數值得以影響 rehashing 跟 collision 的機率。\n- `load_factor()`: 得到 bucket 當中元素數量的平均值。\n- \nExample:https://en.cppreference.com/w/cpp/container/unordered_map\n\n\n","lastmodified":"2024-02-23T05:15:51.402099014Z","tags":["cpp","stl"]},"/notes/Focus/C++/C++-Compilation-Model":{"title":"The C++ Compilation Model","content":"https://subscription.packtpub.com/book/programming/9781789801491/1/ch01lvl1sec03/the-c-compilation-model\n\n\n![[Pasted image 20230918000719.png]]\n\n[[Experiment Compile stage by stage]]\n\n\n![](https://www.cs.nmsu.edu/~jcook/images/compiling.png)\n","lastmodified":"2024-02-23T05:15:51.402099014Z","tags":["cpp"]},"/notes/Focus/C++/C++-Core-Guidelines":{"title":"C++ Core Guidelines","content":"\n\n\u003e This is a quick note \n\n## Ch2 Philosophy\n### 幾乎沒有理由應該遵守的\nP.1 Express ideas directly in code \n\nP.2 Write in ISO Standard C++ \n- 為了兼容，不要寫出依賴於特定架構、特定 Compiler 才可行的 code。\n- 小心 [[Undeined behavior and Implementation defined behavior]]\n\nP.3 Express intent \n- 善用 STL [Algorithms library](https://en.cppreference.com/w/cpp/algorithm) ，比起單純的 for loop 改用 std::find 去找值，也表達意圖。\nP.4 Ideally, a program should be statically type safe \nP.5 Prefer compile-time checking to run-time checking\n- C++14 起添加了 [[Item15 constexpr]] 之類的，可以在編譯期間優化的內容，也新增的編譯期間可用的 assert。如果有編譯期間檢查的，就該在編譯期間確定。\nP.6 What cannot be checked at compile-time should be checkable at run-time \nP.7 Catch run-time errors early \nP.8 Don’t leak any resources \nP.9 Don’t waste time or space \nP.10 Prefer immutable data to mutable data \nP.11 Encapsulate (封裝) messy constructs, rather than spreading through the code \nP.12 Use supporting tools as appropriate \nP.13 Use support libraries as appropriate\n\n## Interface\nI.2 Avoid non-const global variables \n- 會導致 global variable 在哪裡改動不易察覺。\n- [[Drawback of non const global variable]]\nI.3 Avoid singletons \n- [[Singleton]]\nI.13 [[Do not pass an array as a single pointer ]]\n- 優先考慮 std::vector，如果在設計 function 時必須兼容 C-array，則可以考慮 `std::span\u003cT\u003e` (C++20) 作為 signatrue \nI.27 For stable library ABI, consider the Pimpl idiom \n- ABI: application binary interface \n- 對於一個 ABI 開發者，由於對外的 API 會影響 Client 端，盡量用 Pimpl 把實作和 Interface 切分開來。\n## Functions (Ch4)\nF.4 If a function may have to be evaluated at compile-time, declare it constexpr\n- 被宣告成 `constexpr` 的內容會存在 ROM (read only memory)，不會在執行期間 (runtime) 求值、運算，就有如 const 一般，也因此是 thread safe。\nF.6 If your function may not throw, declare it noexcept \n- 如果 Function 不應該 thorw exception，則宣告成 noexcept.\n1. 這可以減少 client 端所需考慮的情況組合\n2. 對於 Optimizer 來說，noexcept 是一個有價值的資訊\n3. 即使 function 還是內可能拋出 exception，依然可以宣告 noexcept。這種情況表示: 該 function 並沒有對 exception 做任何控制，程式沒有能力應對 exception。因此會直接呼叫 `std::terminate`。\n4. 最後，這可以增加可讀性，使 reader 明白 implemter 的意圖。\n[[永遠不該扔例外的 function]]\nF.8 Prefer pure functions \n- 給予相同的輸入，必然得到相同的輸出。\n- 如果結果 depends on `time`, `random`, 就會是 non pure function \nF.15 Prefer simple and conventional ways of passing information \n- [[Prefer simple and conventional ways of passing information ]]\n- 這是一條很大的 rule，後面有很多小條的逐一說明每一種情況。\nF.16 For “in” parameters, pass cheaply-copied types by value and others by reference to const \nF.19 For “forward” parameters, pass by TP\u0026\u0026 and only std::forward the parameter \nF.17 For “in-out” parameters, pass by reference to non-const \nF.20 For “out” output values, prefer return values to output parameters \nF.21 To return multiple “out” values, prefer returning a struct or tuple \nF.42 Return a T* to indicate a position (only) \nF.44 Return a T\u0026 when copy is undesirable and “returning no object” isn’t needed \nF.45 Don’t return a T\u0026\u0026 \nF.48 Don’t return std::move(local) \nF.46 int is the return type for main() \n\nF.50 Use a lambda when a function won’t do (to capture local variables, or to write a local function) \n- [[Lambda]]\nF.52 Prefer capturing by reference in lambdas that will be used locally, including passed to algorithms \nF.53 Avoid capturing by reference in lambdas that will be used nonlocally, including returned, stored on the heap, or passed to another thread \nF.51 Where there is a choice, prefer default arguments over overloading \nF.55 Don’t use va_arg arguments\n\n\n\n\n\n\n\n----\n\n## 直接在程式碼解釋要做什麼\n舉例而言，比起寫一個 for loop 在一個 list 中找到指定的數值，不如使用 `std::find`。\n有句諺語是 「如果你使用 explicit loops，代表 你不知道 STL 的 [Algorithms library](https://en.cppreference.com/w/cpp/algorithm)\n\n\u003e A professional C++ developer should know the algorithms of the STL. By using them, you avoid the usage of explicit loops, and your code becomes easier to understand, easier to maintain, and therefore, less error prone. There is a proverb in modern C++: “When you use explicit loops, you don’t know the algorithms of the STL\n\n## 撰寫 ISO 標準 C++ 小心 undefined behavior 和 implementation-defined behavior\n\n[[Undeined behavior and Implementation defined behavior]]\n\n\n## 確保 Type safe \n\n原則上，C++ 是靜態定型。但要小心 union, cast, array decay, range error, narrowing conversion 帶來的型態變換。\n- union 的問題: C++17 之後可用 `std::variant` 取代\n- templated based 的 generic code 可以降低 casting 的需求，進而減少 type error。\n- Array decay 通常發生於，呼叫一個 function 並傳入 c array。對 function 而言拿到的是第一個 item 的 pointer (???)。可使用 GSL 避免此類問題。\n- narrowing conversion 指有資料損失的隱性轉換。\n\n\n\n\n\n## What I can do \n- [Algorithms library](https://en.cppreference.com/w/cpp/algorithm)\n- \n","lastmodified":"2024-02-23T05:15:51.402099014Z","tags":["cpp","moc"]},"/notes/Focus/C++/C++11-std-function":{"title":"C++11 std function","content":"","lastmodified":"2024-02-23T05:15:51.402099014Z","tags":["empty","cpp11"]},"/notes/Focus/C++/Classic-Strategy-Pattern":{"title":"Classic Strategy Pattern","content":"#DesignPattern \n\n![[Item35_Classic_Strategy_Pattern.png]]\n","lastmodified":"2024-02-23T05:15:51.402099014Z","tags":["cpp"]},"/notes/Focus/C++/Const-in-C++":{"title":"Const in C++","content":"\n#### Const Iterator\n同理上述，宣告一個 iterator 為 `const` 表示這個 iterator 不能改變指向的對象，但是指向的對象之內容本身可以變。 \n```cpp\nconst std::vector\u003cint\u003e::iterator iter = vec.bgein();\n```\n如果想要指向一個不可被改變內容的物件，需要使用 `const_iterator`\n```cpp\nstd::vector\u003cint\u003e::const_iterator citer = vec.bgein();\n```\n\n#### Return Const Value\n[[讓介面易於被使用，不易誤用#Return Const Value]]\n\n#### Const member function\n[[Const member function]]\n\n#### Const Argument\n在真實的程式設計中，比較多用於 function argument 是 const pointer / const referecne。\n如下例: `print` function 定義了一個 const reference 的 argument，當它在調用 operator `[]` 的時候，就會用到上面的 API。且定義 const return value 可以避免錯誤的寫入值，達成 const object 的目的。\n```cpp\nvoid print(const TextBlock\u0026 ctb) // in this function, ctb is const \n{ \n\tstd::cout \u003c\u003c ctb[0]; // calls const TextBlock::operator[] \n\tctb[1] = 'x';        // raise error!!!\n}\n```\n\n#### 打破 Constness 限制\n前面說的是對於 Client 端，我們須保持資料的不可變動性。\n\n然而在類別內部的設計中，基於維護性、或某些理念，我們希望它不要那麼死板，比起 Compiler 所堅持的 Constness，或許邏輯上的 Constness 更加重要。接下來，將說明 Compiler 認知 Constness 為何 ，與如何「部分的」打破 Const 限制。\n[[打破 Constness 限制]]\n","lastmodified":"2024-02-23T05:15:51.402099014Z","tags":["cpp"]},"/notes/Focus/C++/Const-member-function":{"title":"Const member function","content":"\n\u003e The purpose of const on member functions is to identify which member functions may be invoked on const object.\n\n使 Interface 意圖更加清楚，有兩個重要的優點\n1. 可知道哪個 function 會更動到物件\n2. 改善 C++ 程式效率與 \"pass by reference to const\" 息息相關，使 function 可操作 Const Object 。\n\n直接看例子: 我們定義了如下的 Interface。\n\n```cpp\nclass TextBlock\n{\npublic:\n\t// operator[] for const objects\n\tconst char\u0026 operator[](std::size_t position) const\n\t{ return text[position]; }\n\t\n\t// operator[] for non-const objects\n\tchar\u0026 operator[](std::size_t position) \n\t{ return text[position]; }\nprivate:\n\tstd::string text;\n};\n```\n\n在 Client 端，`const TextBlock` 與 `TextBlock` 物件會 call 到的  `TextBlock::operator[]` **是不同的**!! 有宣告 Interface 的第一條 (const function)，才有辦法操作 `const TextBlock` 的物件。\n```cpp\nconst TextBlock ctb(\"World\");\nstd::cout \u003c\u003c ctb[0]; // calls const TextBlock::operator[]\n\nTextBlock tb(\"Hello\");\nstd::cout \u003c\u003c tb[0]; // calls non-const TextBlock::operator[]\n```\n\n## Experiment\n實驗以下這份 code，\n1. 當 const 與 non-const function 都寫時\n```cpp\ncall non-const func A\ncall const func B\n```\n2. 當只寫 const 時\n```cpp\ncall const func A\ncall const func B\n```\n3. 當只寫 non-const 時 (宣告 const object, 但不宣告 `const operator[]` )，Compile 的時候就會出問題 \n```cpp\nItem3.cpp:32:20: error: passing ‘const TextBlock’ as ‘this’ argument discards qualifiers [-fpermissive]\n   32 |     std::cout\u003c\u003ct2[0] \u003c\u003cstd::endl;\n      |                    ^\nItem3.cpp:17:15: note:   in call to ‘char\u0026 TextBlock::operator[](std::size_t)’\n   17 |         char\u0026 operator[](std::size_t position)\n      |               ^~~~~~~~\n```\n\n程式本體:\n```cpp\n#include \u003cstring\u003e\n#include \u003ciostream\u003e\n// g++ -o main Item3.cpp\nclass TextBlock\n{\npublic:\n    TextBlock(std::string text):m_text(text) { }\n\t// operator[] for const objects\n\tconst char\u0026 operator[](std::size_t position) const\n\t{ \n        std::cout\u003c\u003c\"call const func \";\n        return m_text[position]; \n    }\n\t\n\t// operator[] for non-const objects\n\tchar\u0026 operator[](std::size_t position) \n\t{ \n        std::cout\u003c\u003c\"call non-const func \";\n        return m_text[position]; \n    }\n\nprivate:\n\tstd::string m_text;\n};\n\nint main() {\n    TextBlock t1 = TextBlock(\"AAAA\");\n    const TextBlock t2 = TextBlock(\"BBB\");\n    std::cout\u003c\u003ct1[0] \u003c\u003c std::endl; \n    std::cout\u003c\u003ct2[0] \u003c\u003cstd::endl;\n}\n```\n","lastmodified":"2024-02-23T05:15:51.402099014Z","tags":["cpp"]},"/notes/Focus/C++/Copying-Function":{"title":"Copying Function","content":"\n\u003e Effective C++ 中，Copying Function 指的是 Copy construcot \u0026 Copy Assignment\n\n1. 當 Programmer 自己定義 Copying function 時，Compiler 不會警告你出錯!\n2. 在繼承的架構中\n\t1. 不只屬於 Child Class 的 member data 要全部 copy\n\t2. 還要記得 call Parent Class 的 copying function。\n\n    ```cpp\n    // Copy Construcotr \n    PriorityCustomer::PriorityCustomer(const PriorityCustomer\u0026 rhs)\n    : Customer(rhs), // invoke base class copy ctor\n    priority(rhs.priority)\n    {\n\t    logCall(\"PriorityCustomer copy constructor\");\n    }\n   \n    // Copy Assignment\n    PriorityCustomer\u0026\n    PriorityCustomer::operator=(const PriorityCustomer\u0026 rhs)\n    {\n        logCall(\"PriorityCustomer copy assignment operator\");\n        Customer::operator=(rhs); // assign base class parts\n        priority = rhs.priority;\n        return *this;\n    }\n\t\n\t ```\n\n3. Copy Constructor 與 Copy Assignment 不應該 Call 彼此，如果有 Reusable Code，應該另外抽一個 private function 去共用。","lastmodified":"2024-02-23T05:15:51.402099014Z","tags":["cpp"]},"/notes/Focus/C++/Default-Generated-Functions":{"title":"Default Generated Functions","content":"\n```cpp\nclass Empty; // you declare, but implement nothing. \n\n// Compiler silently create.\nclass Empty {\npublic:\n\n    Empty() { ... } // default constructor\n    Empty(const Empty\u0026 rhs) { ... } // copy constructor\n    ~Empty() { ... } // destructor — see below for whether it's virtual\n    Empty\u0026 operator=(const Empty\u0026 rhs) { ... } // copy assignment operator\n}\n\nEmpty e1;      // default constructor\n\t\t\t   // destructor\nEmpty e2(e1);  // copy constructor\ne2 = e1;       // copy assignment\n```\n\n\n- Default constructor (without parameter) \u0026 destructor\n\t- 給編譯器放一些喚起 base class, non-static member data constructor \u0026 destructor 的地方。\n\t- Compiler 生成的 destructor 是一個 non-virtural\n\t  [[為多型用途的基礎類別宣告 virtual 解構式]]\n\t- 只要有宣告 Constructor，編譯器就不會幫我們多掛 default constructor 上去。\n- Copy Constructor \u0026 Copy Assignment: 將 source 物件的每一個 non-static member data copy 過去。[[Copying Function]]\n\n## Default Copy Assignment\n儘管 Copy Assignment `operator=` 也可以自動生成，卻是有條件的自動生成，只有當自動生成的代碼合法時才會生成。\n\n但 default copy assignment 常很有機會變得幾乎無用武之地。\n1. 當 User-defined Class 有 member data 是 Reference 或 `const`，自動生成的 code 會不合法。\n2. 當 base class 把 copy assignment 宣告成 private，compiler 無法喚起 parent 的 private function，直接裝死。\n\n在 C++ 當中，一旦 Reference 被宣告，是不允許改指向不同物件的，而 Compiler 更不會自動去修改 \"被 Reference 物件\" 的內容。這種情況，Compiler 會直接拒絕生成 Copy assignment。\n如果想讓一個有 reference member data 的 class 有 Copy assignment，需要自行實作。相似的，更改 `const` 成員是不合法的，需自行實作。","lastmodified":"2024-02-23T05:15:51.402099014Z","tags":["cpp"]},"/notes/Focus/C++/Deleted-Function":{"title":"Deleted Function","content":"\n\n```cpp\nclass A{    \npublic:\n  A(int x) : m(x) {}\n  A\u0026 operator = (const A \u0026) = delete;  // Declare the copy assignment operator\n                                       // as a deleted function.\n  A(const A\u0026) = delete;                // Declare the copy constructor\n                                       // as a deleted function.\n\nprivate:\n  int m;\n};\n\nint main(){\n  A a1(1), a2(2), a3(3);\n  a1 = a2;     // Error, the usage of the copy assignment operator is disabled.\n  a3 = A(a2);  // Error, the usage of the copy constructor is disabled.\n}\n```\n\n\n## 舊的做法\n以 C++11 為分水嶺，C++98 只能透過宣告 private 藏住不要 Compiler 生成的 function。\n確實 client code 會無法呼叫。但這並不絕對安全，因為 member function 跟 frient function 還是可以呼叫 private function。更安全的做法是，宣告 private 後故意不實作。\n","lastmodified":"2024-02-23T05:15:51.402099014Z","tags":["cpp"]},"/notes/Focus/C++/Dependency-Injection":{"title":"Dependency Injection","content":"相依注入(Dependency Injection, DI)\n[Types of dependency injection](https://en.wikipedia.org/wiki/Dependency_injection#Types_of_dependency_injection) 有多種，\n- Constructor injection\n- Setter injection\n- Interface injection\n總之就是: 如果我需要 \"A\"，呼叫取得 A 的 function (或產生 A ) 會有某些巨大的代價，像是必須被迫呼叫 singleton 之類的。相依注入就是在外面取得這個結果，然後透過 constructor 或 setter 把這個相依 \"注入\" 到 Client 的 Argument 當中。\n\n因為沒在 Client 中 hard-coded 呼叫到那個有巨大代價的東西，不直接相依於它，重構上會變得容易。\n\n上網查 Interface injection 比較容易得到 design pattern 的結果，但 DI 應該不限於 Interface Injection。\n\n```cpp\n//  Without dependency injection\npublic class Client {\n\n    Client() {\n\t\tint val = Singleton::instance().get_val(); //dependency is hard-coded, inside Client.\n\t\tstd::cout\u003c\u003c val \u003c\u003c std::endl;\n    }\n}\n\npublic class Client {\n    Client(int val) { // dependency is in the constructor argument. singleton can be called in outer.\n\t\tstd::cout\u003c\u003c val \u003c\u003c std::endl;\n    }\n}\n\n//  With dependency injection\n\n\n```\n\n\n\n\n## Interface Injection\n透過介面把 Client 與 Service 之間的依賴性鬆綁，Client 變得依賴於介面，而 Service 則是繼承介面之後的實作。\n\nDependency injection is used to make a class independent of its dependencies or to create a loosely coupled program. Dependency injection is useful for improving the reusability of code. Likewise, by [decoupling](https://www.techtarget.com/whatis/definition/decoupled-architecture) the usage of an object, more dependencies can be replaced without needing to change class.","lastmodified":"2024-02-23T05:15:51.402099014Z","tags":["cpp"]},"/notes/Focus/C++/Do-not-pass-an-array-as-a-single-pointer":{"title":"Do not pass an array as a single pointer","content":"不要直接把 C-array 以 Pointer 的方式到處傳遞，這很容易導致 Undefined Behavior。\n\n例如: Copy 的時候忘記幫末位留一個空位，導致差一錯誤 (off-by-one error, 計數時由於邊界條件判斷失誤導致結果多了一或少了一的錯誤)。\n\n迴避的方式很簡單，直接使用 STL container。像是 std::vector，\n- 同樣可以用 `operator[]`\n- 直接以 member function `size` \n\n甚至 C++20 提供 `std::span` 可以更優雅的解決此問題: \n\nspan 像是一個 wrapper，用來 refer to  \"sequential contiguous container\" (ex.  C-array, std::vector) ，然而它不是 owner，不應該有物件的 memory 放在 span 身上。\n\n透過 std::span 的 API，可以直接對 C-array 做 `begin`, `front`, `at` ... 等 STL 的常見 member function。\n\n","lastmodified":"2024-02-23T05:15:51.402099014Z","tags":["cpp"]},"/notes/Focus/C++/Drawback-of-non-const-global-variable":{"title":"Drawback of non const global variable","content":"1. 單元測試: 當每個 function 都用到同一個 global variable ，根本抽不出單元，只能做整體測試。\n2. 重構: Code 之間不是獨立的，很難抽出來。\n3. Performance Optimization: 難以用 multiple thread 之類的手段，因為各個部份之間對同一個 global variable 有 dependency。\n4. Concurrency: 可能會有競速 (data race) 問題。\n","lastmodified":"2024-02-23T05:15:51.402099014Z","tags":["cpp"]},"/notes/Focus/C++/EBO-Empty-Base-Optimization":{"title":"EBO (Empty Base Optimization)","content":"空白基本類別最佳化\neffective c++ 191","lastmodified":"2024-02-23T05:15:51.402099014Z","tags":["empty"]},"/notes/Focus/C++/Effective-C++-Outline":{"title":"Effective C++ Outline","content":"## Chapter 1\n\n### 條款1 C++ 是一個語言聯邦\nC++ 融合了多種形式的 programming 手法，物件導向、procedural、generic、metaprogramming、functional...。\n\n### 條款2 盡量以 `const` , `enum`, `inline` 取代 `#define`\n- 以 const, enum, inline 取代 `#define`， 寧可以編譯器 (compiler) 取代前處理器 (pre-processor)。 \n- 對於單純的常數，以 `const` 或 `enum` 取代\n- 對於形似 function 的巨集(macro)，用 `inline` 取代。\n#### Const\n- [[以 Const 取代使用 Define]]\n- [[The definition and declaration of static const]]\n#### Enum\n- [[enum hack]]\n#### Inline\n\n\n### 條款3 盡可能使用 const\n盡可能的使用 `const`，它可以確保物件不被改變。特別是 custom class designer 更加需要注意 operator 的 constness。\n\n- `const` 在星號左邊: 被 point 的物件是常數\n- `const` 在星號右邊: pointer 自身是常數\n```c++\nchar greeting[] = \"Hello\";\nchar* p greeting;\n\nconst char* p = gretting; // non-const ptr, const data\nchar const* p = gretting; // same \n\nchar* const p = greeting; // const ptr, non-const data\nconst char* const p = greeting; // const ptr, const data\n```\n\n當 `const` 在 `*` 前，不管是先寫 const 修飾的類、或是先寫 const 都是一樣的，就是在修飾 `char` 物件具有常數性。\n\n[[Const in C++]]\n\n### 條款4 確定物件在使用前已經初始化\n不是所有的物件宣告時自帶初始化，它的規則過於複雜，只需要謹記: 宣告時就要初始化!\n(通常是 C-style 的，像是 array 不保證會發生初始化)，而 non-C part 的 (like `std::vector`) 有其他規則，就自帶初始化)\n\n對於內建型別 (int, char, double)，初始化就是手動給值。對於內建型別之外的，則要寫 constructor。\n\n為了避免沒有初始化帶來的不確定性，確保三件事\n1. 對於不是 member data 的 built-in type object，手動初始化。C++ 並不保證會初始化所有的 Built-in type Object (ex. array)。\n2. 對於 Custom Class，使用 [[Member Initialization List]] 初始化 member data。原因參見 [[Identify Initialization and Assignment]]\n3. 若初始化順序具有不確定性，想辦法加強 design，確保不會發生 circle (兩個變數相互依賴) 或競速問題。\n4. 當 static object 之間有依賴關係時，local static objects 勝過 non-local static objects。參見 [[Static Object]]\n\n## Chapter2 建構、解構、賦值運算\n\n### 條款5 了解 C++默默編寫並呼叫哪些函式\n\n當我們宣告了一個 Class，而不去實踐任何細節，Compiler 會偷偷地幫我們生成一些 function，他們分別是\n- default constructor, destructor\n```cpp\nEmpty() { ... } // default constructor\n~Empty() { ... }\n```\n- copy constructor, copy assignment\n```cpp\nEmpty(const Empty\u0026 rhs) { ... } // copy constructor\nEmpty\u0026 operator=(const Empty\u0026 rhs) { ... } // copy assignment \n```\n\n並且，都是 public inline function!! 關於這些 function 被 inline 會帶來什麼危害，見 [[建構和解構式是 inline 的糟糕人選]]。\n\n更確切來說，是當這些 function 被需要 (被呼叫) 時產生: [[Default Generated Functions]]\n\n### 條款6 明確拒絕不要編譯器自動生成的函式\n在 C++11 引入了新的概念 [Deleted functions](https://www.ibm.com/docs/en/zos/2.4.0?topic=definitions-deleted-functions-c11)，書中教的方法依然有其壞處。直接在 declaration 後面接著 `=delete` 就可以阻止 copmiler 生成它。\n\n```cpp\nA(const A\u0026) = delete;\n```\n\n[[Deleted Function]]\n\n### 條款7 為多型用途的基礎類別宣告 virtual 解構式\n申明，這條規則**只針對**多型的 Base Class\n- 首先就先說明多型的用意: [[為多型用途的基礎類別宣告 virtual 解構式]]\n\n### 條款8 不讓異常逃離解構式\nC++ 不會禁止 Exception 發生於 Destructor，但這麼做具有相當的風險。一旦 Exception 發生而跳出了 Destructor，會中止銷毀物件的程序。\n特別是 STL Container 或 Array 這種資料結構中，若前面有某個 element 在銷毀過程中 thorw Exception 使得 Container 的 Destructor 被中斷，則後面的 elements 有可能不被銷毀，而導致記憶體洩漏! \n\n[[解構式與異常]]\n\n### 條款9 不在建構與解構中呼叫 virtual 函式\n\n不要在 Constructor 與 Destructor 中呼叫 virtural 函式。這和 Java 與 C# 不同!!!\n\n[[Virtual Function]]\n\n\n### 條款10 讓 operator= 回傳自身的 reference\n讓 `operator=`, `operator+=` 等 assignment 符號回傳自身的 Reference。\n這是一項協議，並非強制規定。但在 STL 提供的型別，或是即將 support 的 type ([[Item54 Familiarize yourself with the standard library including TR1]])，都會遵守這個協定，請從眾。\n\n### 條款11 在 operator= 處理自我賦值\n\n在撰寫 `operator=` 時，需要考量當 `rhs==this` 的狀況。\n即使不是如下面的方式 handle 自我賦值，記住，不要讓這個函式 raise exception (exception safety) 就對了。\n\n```cpp\nWidget\u0026 Widget::operator=(const Widget\u0026 rhs)\n{\n\tif (this == \u0026rhs) return *this; // assignment to self\n\tdelete pb;\n\tpb = new Bitmap(*rhs.pb);\n\treturn *this;\n}\n```\n\n### 條款12 複製物件時記得每一個部分\n\n當 Programmer 自己定義 [[Copying Function]] 時，Compiler 不會警告你出錯! 你需要自己注意!!\n\n## Chapter3 資源管理\n\n### 條款13 使用資源管理器\n\n- 資源取得的時機就是初始化的時機 (Resource Acquisition Is Initialization, [RAII](https://zh.wikipedia.org/zh-tw/RAII))\n- [[Smart Pointer]] 是個好選擇\n\n### 條款14 仔細考慮資源管理類別的 Copy 行為\n- Smart Pointer 那類的資源管理器，適合用來掌握 heap-based resource 的生命週期。\n- 並非所有的資源物件，都適合用 Smart Pointer 管理。\n- 書中以 [[Mutex]] (互斥鎖) 舉例。\n\n\u003e [!Todo]\n\u003e 1. 查一查 RAII，這整個章節我看不太懂。\n\u003e 2. 看到 P67，面對複製的問題還沒看。\n\n\n\u003e [!question]\n\u003e (此處是舊版，新版有對應的東西嗎?\n\n### 條款15 在資源管理類中提供對原始資源的存取\n\n儘管使用 [[Smart Pointer]] 管理資源很方便，我們仍有機會需要取得原始的 Pointer。Smart Pointer 同時有提供顯示介面 (explicit) 與隱式介面: \n- explicit : 以 `get` 取得 Raw Pointer。\n- implicit : `operator*`, `operator-\u003e`。\n\n### 條款16 成對的使用 `new` 和 `delete` 並採用相同型式\n1. 盡可能不要用 C-style Array\n2. STL所提供的 vector, string 等 templates 可以降低對 Array 的需求，減少錯誤的發生。\n\n\n### 條款17 以獨立的語句將物件放入 Smart Pointer\n\n```c++\nstd::shared_ptr\u003cWidget\u003e pw(new Widget);\nprocessWidget(pw, priority());\n```\n\n[[為什麼要用獨立句將物件放入 Smart Pointer]]\n\n## Chapter 4 設計與宣告\n### 條款18 讓介面容易被使用、防範誤用\n\n[[讓介面易於被使用，不易誤用]]\n\n### 條款19 設計 Class 猶如設計 Type\n設計 Class 請遵守準則想過一遍: [[設計新 Class 的準則]]\n\n### 條款20 以 Pass by Const Ref 取代 Pass by Value \n\n合理的 Pass by value 幾乎只有下面三種選擇\n1. 內建型態\n2. STL Iterator \n3. Function Object\n\n除此之外，包含 STL Container 應盡可能用 Pass by const reference !\n- [[思維誤區-物件很小就可以 Pass By Value]]\n\n### 條款21 當必須回傳物件時，不要考慮回傳 Reference \n\n絕對不要\n 1. 將 Pointer 或 Reference 指向一個 local 物件回傳。\n 2. 讓 Reference 指向 heap-based object (`new`)\n 3. 當設計出「回傳 ptr/ref 指向 local static」，並且有很多個物件都採用這種形式時提高警覺，很有可能走入了 Bad design。對於怎麼樣是「合理」使用 Local static object : 參見 [[Static Object]]。\n\n\n### 條款22 將成員變數宣告成 Private\n\n- 只提供必要的 Getter 給客戶端，隱藏你的實作有絕佳的好處。\n- [[Protected 與 Public 都是低封裝度的 Access Level]]\n\n\n### 條款23 寧以non-member, non-friend替換 member函數\n\n這條是針對 Object-Oriented C++ 的法則，[[Non-member \u0026\u0026 Non-friend Function 的封裝度優於 Member Function]]。\n站在 Template C++ 又有其他需要考慮的地方，形成了 [[需要型別轉換時請為模板定義非成員函式]]。\n\n\n### 條款24 如果所有的參數都需要型別轉換，請為此採用 non-member 函式\n[[當所有的參數都需要型別轉換，採用 Non-member Function]]\n\n\n### 條款25 考慮寫出一個不拋異常的 Swap 函式\n[[Swap and pimpl]]\n\n\u003e [!danger]\n\u003e 讀到 P111，我懷疑 C++11 之後有不同的做法，先不細看。\n\n\n---\n\n## Ch5 Implementation\n### 條款26 盡可能延後變數定義式的出現時間\n盡可能等到已經擁有初始值了，再一口氣定義+賦予初始值。如此不必調用多餘的 constructor ! \n- [[盡可能延後變數定義式的出現時間]]\n\n\n### 條款27 少做轉型動作 (Minimize Casting)\n- 如果轉型是必要的，試圖把它隱藏在函式之後，不讓 User 在他們的程式中轉型。\n- 作為 Client，如果需要轉型，考慮使用新式的轉型，即使用舊式看起來也合情合理。\n[[少做轉型動作(Minimize casting)]]\n\n### 條款28 避免傳回 Handles 指向物件內部成分\n[[避免傳回 Handles 指向物件的 Private \u0026 Protected Member Data]]，目的是盡可能消滅 dangling handles 出現的可能。\n\n\n### 條款29 為異常安全 (Exception-safe) 而努力是值得的\n\n[[為異常安全 (Exception-safe) 而努力是值得的]]\n\n\u003e [!Todo]\n\u003e Read to P132\n \n### 條款30 透徹了解 Inline\n\n宣告 inline 前，先透徹讀完: [[了解 Inline 的裡裡外外]]\n\n### 條款31 將檔案間的編譯依存降到最低\n[[將檔案的編譯依存關係降到最低]]\n\n\n---\n\n## Ch6 繼承與物件導向\n\n### 條款32 確定 Public 繼承塑造出 is-a 關係\n[[確保 Derived Class 和 Base Class 之間必然保持 Is-a 關係]]\n\nPublic inheritance 意味著 Is-A 關係，Private inheritance 的意義則完全不同 [[審慎的使用 Private 繼承]]。\n\n\n\n\n### 條款33 避免遮掩繼承而來的名稱\n當 Base Class 和 Drived Class 有相同名稱的 function 但不同 signature 時，override 不會發生，而是直接覆蓋掉 Base Class 的 function，等同於 Drived Class 的 function 脫離了 Base Class 的掌控，這就是本條款想強調的: 這個行為遮掩了繼承來的名字。\n\n[[使用關鍵字 using 讓特定 function 在 Scope 內可見]]\n[[override]]\n\n### 條款34 區分介面繼承與實作繼承\n透過 Pure virtual function, Impure virtual, non-virtual function 三種 function 區分 Base Class Designer 的意圖。\n\n[[區分介面繼承(interface)和實作繼承(implement)]]\n\n### 條款35 考慮 Virtual 函式以外的其他選擇\n除了 Virtual function，我們還有其他手法可以達到「讓 Derived Class 提供相同的介面、不同實作的手法」\n- [[藉由 Non-Virtual Interface 手法實現 Template Method Pattern]]\n- [[藉由 Function Pointer 和 tr1 function 手法實現 Strategy Pattern]]\n\n### 條款36 絕不重新定義繼承來的 Non-virtual Function\n[[絕不重新定義繼承來的 Non-virtual Function]]\n\n### 條款37 絕不重新定義繼承來的預設參數值\n[[靜態綁定 (statically bound) 與動態綁定 (dynamically bound)]]\n\n### 條款38 確定 Composition 塑造的是 Has-A 關係或根據某物實作的關係\n\nModel \"has-a\" or \"is-implemented in terms of \" through composition.\n[[確定 Composition 塑造的是 'Has-A'關係 或 '根據某物實作'的關係]]\n\n### 條款39 明智審慎的使用 Private 繼承\n[[審慎的使用 Private 繼承]]\n\n### 條款40 明智審慎的使用多重繼承\n[[多重繼承 (Multiple Inheritance, MI)]]\n\n\n## Ch7 Template and Generic Programming\n[[Template 的用途]]\n\n\n### 條款41 了解隱式介面和編譯多型\n[[Template 與隱式介面]]\n\n### 條款42 了解 typename 的雙重意義\n[[關鍵字 typename 在 Template 中的意涵]]\n\n### 條款43 學習處理模板化基礎類別內的名稱\nknow how to access names in templatized base classes.\n[[了解如何在 Template 中指涉 Base Class 成員]]\n\n### 條款44 將與參數無關的程式碼抽離 Templates\n[[Template 帶來的程式碼膨脹]]\n\n### 條款45 運用成員函式模板接受所有相容型別\n[[運用成員函式模板，接受所有相容的型別]]\n\n\n### 條款46 需要型別轉換時請為模板定義非成員函式\n\n\n- [[需要型別轉換時請為模板定義非成員函式]]\n\n### 條款47 請使用 Traits Classes 表現型別資訊\n\n### 條款48 認識 Template 超編程\n\n## Ch8 自訂 new 和 delete\n\n### 條款49 了解 new-handler 的行為\n\n### 條款50 了解 new 和 delete 的合理替換時機\n\n### 條款51 編寫 new 和 delete 時需固守常規\n\n### 條款52 寫了 placement new 也要寫 placement delete\n\n\n\n## Ch9 雜項討論\n### 條款53 不要輕忽邊義器的警告\n\n### 條款54 讓自己熟悉包刮 TR1 在內的標準函式庫\n[[Item54 Familiarize yourself with the standard library including TR1]]\n\n### 條款55 讓自己熟悉 Boost\n\n[[Item55 Familiarize yourself with Boost]]\n\n\n簡體目錄: https://blog.csdn.net/weixin_45926547/article/details/121276226\n","lastmodified":"2024-02-23T05:15:51.430099019Z","tags":["cpp","moc"]},"/notes/Focus/C++/Effective-modern-C++-Outline":{"title":"Effective modern C++ Outline","content":"## 外部資源\n- [網友中譯版](https://github.com/CnTransGroup/EffectiveModernCppChinese)\n\n## Deducing Types\n\n### 條款1 了解 Template 的型別推斷規則\n[[Template ParamType deduction]]\n\n### 條款2 了解 auto 的型別推斷規則\n\n\n### 條款3 了解 decltype\n\n\n### 條款4 了解如何檢視型別推斷\n\n## auto\nItem 5: Prefer auto to explicit type declarations\nItem 6: Use the explicitly typed initializer idiom when auto deduces\nundesired types\n\n## Moving to Modern C++\nItem 7: Distinguish between () and {} when creating objects: [[Initializer List]]\nItem 8: Prefer nullptr to 0 and NULL\n### Item 9: Prefer alias declarations to typedefs\n[[typedef and using]]\n\nItem 10: Prefer scoped enums to unscoped enums\nItem 11: Prefer deleted functions to private undefined ones\nItem 12: Declare overriding functions override\n## 條款12 對要 override 的 function 以關鍵字 override 明確宣告 \n[[override]]\nItem 13: Prefer const_iterators to iterators\nItem 14: Declare functions noexcept if they won’t emit exceptions\n[[Modern C++ noexcept]]\n\nItem 15: Use constexpr whenever possible\n[[Item15 constexpr]]\nItem 16: Make const member functions thread safe\nItem 17: Understand special member function generation\n\n## Smart Pointers\nItem 18: Use std::unique_ptr for exclusive-ownership resource management\nItem 19: Use std::shared_ptr for shared-ownership resource management\nItem 20: Use std::weak_ptr for std::shared_ptr-like pointers that can dangle\nItem 21: Prefer std::make_unique and std::make_shared to direct use of new\nItem 22: When using the Pimpl Idiom, define special member functions in the implementation file\n\n## Rvalue References, Move Semantics, and Perfect Forwarding\nItem 23: Understand std::move and std::forward\nItem 24: Distinguish universal references from rvalue references\nItem 25: Use std::move on rvalue references, std::forward on universal references\nItem 26: Avoid overloading on universal references\nItem 27: Familiarize yourself with alternatives to overloading on universal references\nItem 28: Understand reference collapsing\nItem 29: Assume that move operations are not present, not cheap, and not used\nItem 30: Familiarize yourself with perfect forwarding failure cases\n\n## Lambda Expressions\nItem 31: Avoid default capture modes\nItem 32: Use init capture to move objects into closures\nItem 33: Use decltype on auto\u0026\u0026 parameters to std::forward them\nItem 34: Prefer lambdas to std::bind\n\n## The Concurrency API\nItem 35: Prefer task-based programming to thread-based\nItem 36: Specify std::launch::async if asynchronicity is essential\nItem 37: Make std::threads unjoinable on all paths\nItem 38: Be aware of varying thread handle destructor behavior\nItem 39: Consider void futures for one-shot event communication\nItem 40: Use std::atomic for concurrency, volatile for special memory\n\n## Tweaks\nItem 41: Consider pass by value for copyable parameters that are cheap to move and always copied\nItem 42: Consider emplacement instead of insertion\n\n## Item1 Template ParamType deduction\n\n\n\n## 參考中文\n###   推斷型別\n\n項目1：理解模板型別推斷 項目2：理解自動型別推斷 項目3：理解decltype 項目4：了解如何查看推斷的型別\n\n## auto\n\n項目5：優先使用auto而非顯式型別聲明 項目6：在auto推斷出不希望的型別時使用顯式型別初始化惯用法\n\n## 遷移到現代C++\n\n項目7：在創建對象時區分()和{} \n項目8：優先使用nullptr而非0和NULL \n項目9：優先使用別名宣告而非typedef 項目10：優先使用有作用域的枚舉而非無作用域的枚舉 項目11：優先使用已刪除的函數而非私有的未定義函數 項目12：聲明覆蓋的函數使用override 項目13：優先使用const_iterators而非iterators 項目14：如果函數不會引發異常，聲明函數為noexcept 項目15：盡可能使用constexpr 項目16：使const成員函數線程安全 項目17：理解特殊成員函數的生成\n\n## 智能指針\n\n項目18：使用std::unique_ptr進行獨占性資源管理 項目19：使用std::shared_ptr進行共享性資源管理 項目20：使用std::weak_ptr表示可以懸空的std::shared_ptr指針 項目21：優先使用std::make_unique和std::make_shared，而非直接使用new 項目22：在實現文件中定義特殊成員函數時使用Pimpl技法\n\n## Rvalue引用、移動語義和完美轉發\n\n項目23：理解std::move和std::forward 項目24：區分萬能引用和右值引用 項目25：對右值引用使用std::move，對萬能引用使用std::forward 項目26：避免對萬能引用進行重載 項目27：熟悉在萬能引用上進行重載的替代方案 項目28：理解引用折疊 項目29：假設移動操作不存在、不廉價且不被使用 項目30：熟悉完美轉發失敗的情況\n\n\n### Item5\n[[C++11 std function]]\n\n\n","lastmodified":"2024-02-23T05:15:51.430099019Z","tags":["cpp"]},"/notes/Focus/C++/Experiment-Compile-stage-by-stage":{"title":"Experiment Compile stage by stage","content":"\nhttps://www.cs.nmsu.edu/~jcook/posts/c-compiling-linking/\n\n\nGenerate object file only \n```bash\ng++ -c *.cpp\n```\n\nGenerate binary by object file\n```cpp\ng++ -o prog *.o\n```\n\n## Include Guard\n\n\u003e Avoid function redefinition and circling including (?)\n\nInclude guard 可以避免相同的 header 被重複 include，以 \"add.hpp\" 和 \"add.cpp\" 為例，在沒有 include guard 的情況下，如果 \n- add.hpp: `include print_np.cpp`\n- add.cpp: `include add.hpp`\n\n則光是編譯 add.cpp 就會出現問題 (`g++ -c add.cpp`)，這種 redefinition 是在單一 translate unit 內就會發生的。\n![[Pasted image 20230919231828.png]]\n\n而如果改用有 include guard 的 header，則 add.cpp 的編譯會通過。這是因為 Include Guard 可以確保該 header file 只被 include 一次，這樣 hpp 裡面有被定義的 function 就不會有 redefine 的問題。\n- add.hpp: `include print.cpp`\n\n## Multiple Definition\n加上 include guard 後，`g++ -c` 可以成功產出 `*.o` 檔案，每一個 object file 相當於一個 translation unit。表示單一 translation unit 已經沒問題了，下一步是把 object file 綁在一起，變成一個可執行的 program。\n\n```bash\ng++ *.o\n```\n\n這時候遇到新的問題: multiple definition，也就是違反了 [[One Definition Rule]]，main.cpp, minus.cpp. print.cpp 各自都有一個 `print`，linker 不知道怎麼辦。\n\n![[Pasted image 20230923114619.png]]\n\n## Inline \n[[Inline and Translation Unit]]\n\n\n\n\n\n```cpp\ninline void print() { std::cout\u003c\u003c\"It causes problem.\"\u003c\u003cstd::endl; }\n```","lastmodified":"2024-02-23T05:15:51.430099019Z","tags":["cpp"]},"/notes/Focus/C++/External-Linkage":{"title":"External Linkage","content":"\nhttps://en.cppreference.com/w/cpp/language/storage_duration#external_linkage\n\n\u003e The name can be referred to from the scopes in the other translation units","lastmodified":"2024-02-23T05:15:51.430099019Z","tags":["cpp","empty"]},"/notes/Focus/C++/Friend-Function":{"title":"Friend Function","content":"\n\u003e 提供私用成員給某些外部函式來存取，這個有權調用某類別私有成員的函式就稱為 Friend Function \n\nFriend Function 實質上定義在外面，但是在 Class 內部需要用 keyword `friend` 再提及一次該 function。因此，Friend Function 是 Non-member function !\n\n```cpp\nclass Ball;\n\nint compare(Ball \u0026b1, Ball \u0026b2) {\n    // 可直接存取私用成員\n    if(b1._radius == b2._radius)\n        return 0;\n    else if(b1._radius \u003e b2._radius)\n        return 1;\n    else\n        return -1;\n}\n\nclass Ball { \npublic: \n    Ball(double, char*); \n    void radius(double radius) {\n        _radius = radius;\n    } \n    // 宣告朋友函式 \n    friend int compare(Ball\u0026, Ball\u0026);\n \nprivate:\n    double _radius; // 半徑\n};\n```\n\n\n\n\n\n\n\n## Resource\n\n[friend 函式、friend 類別](https://openhome.cc/Gossip/CppGossip/friendFunctionClass.html)\n","lastmodified":"2024-02-23T05:15:51.430099019Z","tags":["cpp"]},"/notes/Focus/C++/Function-As-an-Argument":{"title":"Function As an Argument","content":"\n\u003e Array 並不是 C++ 中唯一可以 decay 成 pointer 的東西。function type 也同樣的可以 decay 成 function pointer。\n\nFunction Argument 在 Template Type Deduction 的原則跟 Array Argumnet 是一樣的。\n```cpp\nvoid func(int double); // function Type: void(int, double)\n\ntemplate \u003ctypename T\u003e\nvoid f1(T param);\n\ntemplate \u003ctypename T\u003e\nvoid f2(T\u0026 param);\n```\n\n把 `func` 放入 `f1` 與 `f2` 後，型態推斷如下: \n|  Code   | ParamType  | `T`|\n|  ----  | ----  | ---|\n| `f1(func)`  | `void (*) (int, double)` |`void (*) (int, double)`|\n|  `f2(func)` | `void (\u0026) (int, double)` | `void (int, double)`|\n","lastmodified":"2024-02-23T05:15:51.430099019Z","tags":["cpp"]},"/notes/Focus/C++/How-to-Pass-Output-Value":{"title":"How to Pass Output Value","content":"\n\u003e 多數情況下，請 Return Value (by Copy)。\n\n## Single value\n直接 return value ，不要以 const value 回傳，因為特地以 const value 回傳並沒有特別的意義。\n(Since C++17) 雖然 copy 「看似」昂貴，但 compiler 有 RVO (return value optimization) 或 NRVO (Named returned value optimization)，經過 optimize 後 copy 得以被省略\n\n## Multiple output value : return struct or tuple \n\nC++ STL 中 `std::set::insert` 的回傳就是一個 `std::pair`，內容存了 iterator 與 bool (是否插入新值)。\n\n至於如何優雅的接收這類(多個)回傳值，建議用 C++11 的 `std::tie` 或 C++17 的 [Structured binding](https://en.cppreference.com/w/cpp/language/structured_binding) 。\n\n### std::tie \n透過 `std::tie`，直接把 `std::pair` 的第一位與第二位分別指派給 `iter` 與 `is_inserted`。\n```cpp\nstd::tie(iter, is_inserted) = mySet.insert(2020); \n```\n\n### Structured Binding\n\n更直覺的用法 unpack 回傳值\n\n```cpp\nauto [iter, is_inserted] = mySet.insert(2021);\n```\n\n## 例外: Return with pointer 或 lvalue reference \n\n像後面會提到的，pass by pointer/reference 都**不應**具有轉移所有權的情況發生 (不應，不是辦不到。一旦做了很容易發生所有權混亂，導致 memory leak)。\n\n下列的情況都應該 follow 這個準則: 雖然 return by pointer/reference，但不具有轉移所有權的問題。\n\n### Pointer 只代表 Position: return `T*`\n\n當回傳的內容只代表一個記憶體位置 (tree node, an address in std::list ... )，該資源本身在 function 之外，則可以回傳 pointer。\n\n### 不想要 Copy 發生，且不需要回傳物件的時候 return `T\u0026`\n\n當不需要複製並且不需要「不回傳物件」時傳回 T\u0026\n\n當 \"Return no object\" 不是選項，則 return by reference，而非 return by pointer。\n\n為了避免一些暫時變數的 copying, destruction，有時會選擇 chain operation。\n通常發生在 assignment operator。\n\n```cpp\nA\u0026 operator = (const A\u0026 rhs) { ... };\nA operator = (const A\u0026 rhs) { ... };\n\nA  a1, a2, a3;\na1 = a2 = a3;\n```\n\n兩個 copy assignment 分別多創建了兩個 temporary object。\n\n## 危險動作: return a reference to a local variable\n\n回傳一個 reference/pointer 到 local variable 都會造成 undefined variable，結果無法預期，也不一定總會 crash。\n\n這兩個動作也同樣危險\n1. Return `T\u0026\u0026`\n2. Return `std::move(local)`\n\n### Return `T\u0026\u0026`\n下面這段範例，就意義上 rvalue 在 `auto myInt` 接收完，該行執行完，就已經結束 lifetime 了。GCC Compiler 甚至不會讓這種 code 通過。\n\n```cpp\nint\u0026\u0026 returnRvalueReference() {\n   return int{};\n}\n\nint main() {\n\n   auto myInt = returnRvalueReference();\n   // lifetime for myInt (rvalue) is END!!!\n}\n\n```\n\n### Return `std::move(local)`\n\n由於 Compiler Optimization 在 return value (by copy) 已經推出 RVO, NRVO -- 在優化時直接省略 Copy，`std::move(local)` 反而不是優化的手段，甚至可能更慢。\n","lastmodified":"2024-02-23T05:15:51.430099019Z","tags":["cpp"]},"/notes/Focus/C++/Identify-Initialization-and-Assignment":{"title":"Identify Initialization and Assignment","content":"\n\u003e C++ 規定，member data initialization 發生在**進入 Constructor 之前**。在 Constructor 賦值屬於 assignment。 正確的 initialization 是使用 member initialization list (成員初值列)，取代賦值 (assignment)。\n\n此例中，第一種的做法效率好: \n- 第一種作法使用  member initialization list 是對 member data 做 Copy Construct。\n- 第二種作法 `m_name`會隱含的 call 一次 `std::string` 的 default constructor，再以 Copy assignment 被賦予值\n\n```cpp\nclass Book {\n    private:\n        std::string m_name;\n    public:\n        // good way\n        Book(const std::string\u0026 name): m_name { // copy construct\n        }\n        // bad way\n        Book(const std::string\u0026 name) {\n            m_name = name;  // copy assignment\n        }\n}\n```\n","lastmodified":"2024-02-23T05:15:51.430099019Z","tags":["cpp"]},"/notes/Focus/C++/Implementation-defined":{"title":"Implementation defined","content":"行為取決於(Compiler?) 如何實作，但是實作們必須明確的撰寫 (document) 行為應當如何，並遵守他們定義的行為。\n\n\n\u003e This term means that the implementation is free to do what it likes, but must document its choice and stick to it.\n\u003e \n\nhttps://gcc.gnu.org/onlinedocs/cpp/Implementation-defined-behavior.html\n","lastmodified":"2024-02-23T05:15:51.430099019Z","tags":["empty"]},"/notes/Focus/C++/Implicit-TemplateInstantiation":{"title":"Implicit TemplateInstantiation","content":"\u003e Occurs when a template is used to declare a pointer variable or a variable with the provided arguments","lastmodified":"2024-02-23T05:15:51.430099019Z","tags":["cpp"]},"/notes/Focus/C++/Impure-Virtual-Function":{"title":"Impure Virtual Function","content":"\n```cpp\nclass Airport { ... }; // represents airports\nclass Airplane {\npublic:\n\tvirtual void fly(const Airport\u0026 destination);\n...\n};\nvoid Airplane::fly(const Airport\u0026 destination)\n{\n\t// default code for flying an airplane to the given destination\n}\nclass ModelA: public Airplane { ... };\nclass ModelB: public Airplane { ... };\n```\n\n相當於告訴 Client: 你需要提供一個這樣的函式，如果不想自己寫，可以用預設的內容! \n\n但是，讓 impure virtual function 同時擔任「要求 client 給一個這樣的函式」又在「實作中放了預設行為，相當於假設所有的 Derived Class 都可以接受這個預設行為」可能導致其他問題: Client 端沒有主動說明「我要這個預設行為」。\n當 Client 端忽略了有這個 function 要 override，就會導致錯誤 -- 該 Derived 可能無法執行這個預設行為。\n\n## 把預設行為跟提供介面切開\n一個好的做法是--斷開兩者的連結。利用 [[Pure Virtual Function]] 提到的做法，把預設的實作寫在 Pure Virtual Function 裡面，當 Derived 想要用預設實作時自己去 call 就好。\n\n\n```cpp\nclass Airplane {\npublic:\n\tvirtual void fly(const Airport\u0026 destination) = 0; // 提供介面\n}\n\nvoid Airplane::fly(const Airport\u0026 destination)\n{ // 為 pure virtual function 提供實作\n\tdefault code for flying an airplane to the given destination\n}\n\nclass ModelA: public Airplane {\npublic:\nvirtual void fly(const Airport\u0026 destination)\n{ Airplane::fly(destination); }\n};\n\nclass ModelC: public Airplane {\npublic:\nvirtual void fly(const Airport\u0026 destination);\n...\n};\nvoid ModelC::fly(const Airport\u0026 destination)\n{ // ModelC 不用預設的實作，就不要 Call Airplane::fly，自己寫\ncode for flying a ModelC airplane to the given destination\n}\n```","lastmodified":"2024-02-23T05:15:51.430099019Z","tags":["cpp"]},"/notes/Focus/C++/Initializer-List":{"title":"Initializer List","content":"","lastmodified":"2024-02-23T05:15:51.430099019Z","tags":["cpp"]},"/notes/Focus/C++/Inline-and-Translation-Unit":{"title":"Inline and Translation Unit","content":"\n## CPP Ref\nhttps://en.cppreference.com/w/cpp/language/inline\n\n\n### Explanation\n當 function or variable (C++17) 被宣告為 inline，代表它擁有以下特性 (以下簡稱 inline object)\n1. 在每一個 TU (translation unit) 當中，inline object 的定義必須是可存取的 (definition should be reachable -\u003e definition should in hpp)。\n2. 如果一個 inline object 被宣告於 hpp，並且此 hpp 被多個 cpp inlcude，表示\n\t- 此 inline obejct 擁有 [[External Linkage]] (它的名稱在其他 TU 被引用且沒有被宣告 `static`)\n\t- 它在多個 TU 之間可能擁有多個定義，但在每一個 TU 的定義都是相同的。\n\n儘管具有這些特性，最終是否予以 inline subsititution 卻仍由 compiler 決定。\n\n## Inline 的歷史淵源\n\nInline 這個關鍵字最初的用意，也是最廣為人知的用意是把 function call 替換成 function body 本身，也就是 [inline substitution](https://en.wikipedia.org/wiki/inline_expansion \"enwiki:inline expansion\")。其代價是 object file 變大，因為每個 call 到 inline 的地方都會被「貼上」一次，但有優化的作用。\n\n然而，因為是否替換 function call 由 compiler 自由決定，被宣告 inline 的 function 不必然被替換，沒被宣告 inline 也不一定不被替換。這代表 inline function optimization 不在綁定於 keyword `inline`。\n\n需要注意的是，Compiler 選擇 inline optimization 與否，並不會改變有關 multiple definition 的規定。\n\n\u003e Function 最終被 compiler inline 與否，都不應該擁有 multiple definition。\n\n在前面 Explanation 提到，inline function 在多個 TU 當中是擁有多個定義 (multiple definitions) 的，且關鍵字 inline 並不與 inline optimization 綁定。這個關鍵字的意義逐漸從「偏好 inline optimization」轉變成 「允許多重定義」，且這重含意在 C++17 中被延伸到 variable 上面。\n\n## Inline Optimization 的條件\n\n1. Definition is reachable in each TU -\u003e definition should be put in hpp.\n\t- Subition or not is still decided by compiler.\n2. 宣告 inline function 於 hpp，將 definition 放在 cpp\n\t1. 當有其他 TU include 了該 inline function 所在的 hpp，會引發 warning: inline function used but never defined\n\n## Template Specialization\n\n\n[[Template Specialization]]\n### Notes\n## When Does Compiler deciding \"don't do subtition\" \n\nThe **`inline`** keyword tells the compiler that inline expansion is preferred. However, the compiler can create a separate instance of the function (instantiate) and create standard calling linkages instead of inserting the code inline. Two cases where this behavior can happen are:\n\n- Recursive functions.\n    \n- Functions that are referred to through a pointer elsewhere in the translation unit.\n    \n\nThese reasons may interfere with inlining, _as may others_, at the discretion of the compiler; you shouldn't depend on the **`inline`** specifier to cause a function to be inlined.\n\nRather than expand an inline function defined in a header file, the compiler may create it as a callable function in more than one translation unit. The compiler marks the generated function for the linker to prevent one-definition-rule (ODR) violations.\n\n","lastmodified":"2024-02-23T05:15:51.430099019Z","tags":["cpp"]},"/notes/Focus/C++/Interface-of-all-containers":{"title":"Interface of all containers","content":"\n每個 Container 至少會有一個 type parameter 與該 type 的 allocator，allocator 多數時候在背景運行 (在需要它的時候默默調用，user 不需要直接呼叫 allocator)。\n以 `std::vector` 為例，`std::vector\u003cint\u003e` 實際上呼叫的是 `std::vector\u003cint, std::allocator\u003cint\u003e \u003e`。有了 `std::allocator`，你可以動態的調整除了 `std::array` 之外，所有 container 的 size。\n## Create and Delete\nSTL containers 基本上擁有相似的介面\n\n## Size\n判斷容器是否為空，建議使用 `empty` \n1. `empty()` 的速度比 `size()==0` 快。\n2.  `std::forward_list` 沒有 member function `size`，使用 `empty` 更 general 一點。\n\n另外 `max_size()` 可以取得 container 所能擁有的最大成員數量，這是個數值是 [[Implementation-defined]] ，取決於編譯器。\n\n## Access (Iterator)\n\nFor a container cont, you get with cont.begin() the begin iterator and with cont.end() the end iterator, which defines a half-open range. It is half-open because the begin iterator belongs to the range, and the end iterator refers to a position past the range. The iterator pair cont.begin() and cont.end() enables it to modify the elements of the container. Creation and deletion of a container Iterator\n\nRainer Grimm. The C++ Standard Library (Kindle Locations 2391-2395). Kindle Edition. \n\n\n## Assign and Swap \n- Assignment: 分成 \n\t1. copy assignment\n\t2. moving assignment\n\t3. 透過 initializer list assign，此方法不適用 `std::array`\n- swap 有兩種形式\n\t1. 透過 member function `swap`\n\t2. 透過 function template `std::swap`\n\n```cpp\n# assignment \ncont1 = cont2; // copy assignment \ncont1 = std::move(cont2); // moving assignment\n\n// assign with initializer list, excluding for std::array\ncont = {1, 2, 3};\n\n# swap \ncont.swap(cont2);\nstd::swap(cont, cont2); \n\n```\n\n## Compare \n\n兩個容器之間的比較運算符，會逐一比較兩個容器中的元素。比較 associative containers 時，是以 key compare。Unordered associative containers 只支援 `==` 跟 `!=`。\n## Erasure \n自 [C++20 起](https://en.cppreference.com/w/cpp/container/vector/erase2)，STL 提供了兩個 free functions (並非容器的 member functions) 。\n`std::erase(container, val)`, `std::erase_if(container, pred)` 會清除容器裡面滿足條件的所有元素，兩個 function 的回傳值都是那些被清除的 elements。\n\n\n","lastmodified":"2024-02-23T05:15:51.430099019Z","tags":["cpp"]},"/notes/Focus/C++/Internal-and-External-Linkage":{"title":"Internal and External Linkage","content":"https://learn.microsoft.com/en-us/cpp/cpp/program-and-linkage-cpp?view=msvc-170\n\n## External vs. internal linkage\n\nA _free function_ is a function that is defined at global or namespace scope. Non-const global variables and free functions by default have _external linkage_; they're visible from any translation unit in the program. No other global object can have that name. A symbol with _internal linkage_ or _no linkage_ is visible only within the translation unit in which it's declared. When a name has internal linkage, the same name may exist in another translation unit. Variables declared within class definitions or function bodies have no linkage.\n\nYou can force a global name to have internal linkage by explicitly declaring it as **`static`**. This keyword limits its visibility to the same translation unit in which it's declared. In this context, **`static`** means something different than when applied to local variables.\n\nThe following objects have internal linkage by default:\n\n- **`const`** objects\n- **`constexpr`** objects\n- **`typedef`** objects\n- **`static`** objects in namespace scope\n\nTo give a **`const`** object external linkage, declare it as **`extern`** and assign it a value:\n\n[[External Linkage]]","lastmodified":"2024-02-23T05:15:51.430099019Z","tags":["empty"]},"/notes/Focus/C++/Item15-constexpr":{"title":"Item15 constexpr","content":"","lastmodified":"2024-02-23T05:15:51.430099019Z","tags":["empty","cpp11"]},"/notes/Focus/C++/Item47-Use-traits-classes-for-information-about-types":{"title":"Item47 Use traits classes for information about types","content":"","lastmodified":"2024-02-23T05:15:51.430099019Z","tags":["empty"]},"/notes/Focus/C++/Item54-Familiarize-yourself-with-the-standard-library-including-TR1":{"title":"Item54 Familiarize yourself with the standard library including TR1","content":"","lastmodified":"2024-02-23T05:15:51.430099019Z","tags":["empty"]},"/notes/Focus/C++/Item55-Familiarize-yourself-with-Boost":{"title":"Item55 Familiarize yourself with Boost","content":"","lastmodified":"2024-02-23T05:15:51.430099019Z","tags":["empty"]},"/notes/Focus/C++/Lambda":{"title":"Lambda","content":"","lastmodified":"2024-02-23T05:15:51.430099019Z","tags":["cpp"]},"/notes/Focus/C++/Member-Function-Template":{"title":"Member Function Template","content":"並不限用於 constructor，它常被用來處理賦值操作。\n\n以 `shared_ptr` 為例，它的 copy ctor 可以接受 `weak_ptr` 與 `shared_ptr` (不限此二類，沒有全列)。且包含 copy assignment 也是透過 member function template 達成。\n\n只不過 constructor 類的，除了 generic copy constructor (接收 shared pointer type 的) 是接受隱式轉換的， \n\n```cpp\ntemplate\u003cclass T\u003e class shared_ptr {\npublic:\n\t// constructor\n\ttemplate\u003cclass Y\u003e // construct from\n\texplicit shared_ptr(Y * p); // any compatible\n\t// copy ctor for share_ptr type \n\ttemplate\u003cclass Y\u003e // built-in pointer,\n\tshared_ptr(shared_ptr\u003cY\u003e const\u0026 r); // shared_ptr,\n\t// copy ctor for weak_ptr type \n\ttemplate\u003cclass Y\u003e // weak_ptr, or\n\texplicit shared_ptr(weak_ptr\u003cY\u003e const\u0026 r); // auto_ptr\n\t\n\ttemplate\u003cclass Y\u003e // assign from\n\tshared_ptr\u0026 operator=(shared_ptr\u003cY\u003e const\u0026 r); // any compatible\n\t\n\ttemplate\u003cclass Y\u003e // shared_ptr or\n\tshared_ptr\u0026 operator=(auto_ptr\u003cY\u003e\u0026 r); // auto_ptr\n};\n```\n\n## 編譯器依然會自動產生 copying function\n\n條款5中說到，編譯器會自動產生一些 function: [[Default Generated Functions]]\n儘管以上透過 member function template 撰寫了 copying function，這不會阻止 compiler 自動生成 那些預設生成的函式!!\n\n試想，當 `T` 和 `U` 相同，呼叫的 funciton 會是 compiler 自動生成的版本? 還是根據模板函式生成一個 `SmartPtr(const SmartPtr\u003cTop\u003e\u0026 other)` 的 function? \n```cpp\ntemplate\u003ctypename T\u003e\nclass SmartPtr {\npublic:\n\ttemplate\u003ctypename U\u003e // member template \n\tSmartPtr(const SmartPtr\u003cU\u003e\u0026 other); // for a ”generalized copy constructor”\n}\n\nSmartPtr\u003cTop\u003e pt2 = SmartPtr\u003cTop\u003e(new Top);\n```\n\n在 class 內宣告模板函式，並會阻止編譯器生成預設的 copy ctor (non-template)，如果希望完全掌控 copy ctor，則必須**都宣告**\n```cpp\ntemplate\u003ctypename T\u003e\nclass SmartPtr {\npublic:\n\tSmartPtr(SmartPtr const\u0026 rhs); // non-template copy ctor\n\n\ttemplate\u003ctypename U\u003e // template copy ctor\n\tSmartPtr(const SmartPtr\u003cU\u003e\u0026 other); \n}\n\n```","lastmodified":"2024-02-23T05:15:51.430099019Z","tags":["cpp"]},"/notes/Focus/C++/Member-Initialization-List":{"title":"Member Initialization List","content":"\n\u003e 無論如何，使用 member initializer list 對 member data 初始化是最好的。儘管這麼做對內建型別的資料沒差，對非內建型別卻有巨大的意義。\n\n如果你就是想要 call member data 的 default constructor，依然可以透過 member initializer list 達成。只要給予空括號，不填內容即可。\n這樣的好處是明白地列出所有 member data，避免有 data 忘記給初始值，特別是對**非內建型別**的member data，沒有初始化的結果是災難的。\n\n對於內建型別的 Reference \u0026 const，他們**不能被賦值**，**必須透過 member initializer list 初始化**。\n- Related: [[Effective C++ Outline#條款5 了解 C++默默編寫並呼叫哪些函式]]\n\n\n## 合理的使用 Assignment\n某些時候，類別擁有多個 Constructor，每個 Constructor 都需要有自己的 Member initializer list，這又會導致 dumplicated。\n這時候可以是當地將一些 Assignment 和 Initialize 效率差不多的 member data (通常是內建型別)，移到一個 \"統一初始化\" 的 private function，供所有的 Constructor 呼叫。\n這種作法 (pseudo-initialization, 偽初始化) 特別在數值是由讀檔得到的時候特別有用，但可以的話，盡可能使用 member initializer list。\n","lastmodified":"2024-02-23T05:15:51.430099019Z","tags":["cpp"]},"/notes/Focus/C++/Modern-C++-noexcept":{"title":"Modern C++ noexcept","content":"\n[[為異常安全 (Exception-safe) 而努力是值得的]]\nC++11 中新增的 `noexcept` 有如 `const` 一般，是 function signature 的一部分。\n\n\n固然，在 Effective Modern C++ Item 14 當中提及將 function 標示為 noexcept 所帶來的 object file optimize 益處。仍需要切記，`noexcept` 也是 signature 的一部分，如果只是想要享受優化的好處，而沒有仔細審視 function 是否真的 exception safe，直接將 API 暴露給客戶端，而在日後發現並非 exception safe 而收回 noexcept 保證，這將嚴重影響客戶端的使用。\n多數的 function 是 exception natural (中性的)，意即，不主動拋出 exception，但 exception 可能從此 func 所  invoke 的 function 中被拋出來。這就表示此 function 非 exception safe\n\n\n","lastmodified":"2024-02-23T05:15:51.430099019Z","tags":["cpp"]},"/notes/Focus/C++/Mutex":{"title":"Mutex","content":"假設我們用 C API 處理 `Mutex` 物件\n```cpp\nvoid lock(Mutex *pm); // lock mutex pointed to by pm\nvoid unlock(Mutex *pm); // unlock the mutex\n```\n\n使用者需要自己手動分別呼叫 `lock` 與 `unlock`。為了確保不會忘記幫 Mutex 解鎖，可以建立一個由 RAII 守則支配的 Class --資源在建構期間獲得(lock)，在解構期間釋放(unlock)--來管理資源「Mutex 物件」。\n\n```cpp\nclass Lock {\npublic:\nexplicit Lock(Mutex *pm) : mutexPtr(pm) \n\t{ lock(mutexPtr); } // acquire resource\n~Lock() { unlock(mutexPtr); } // release resource\n\nprivate:\nMutex *mutexPtr;\n};\n\n```\n而客戶端調用，也符合 RAII 方式\n```cpp\nMutex m;     // define the mutex you need to use\n...\n{            // create block to define critical section\nLock ml(\u0026m); // lock the mutex\n...          // perform critical section operations\n}            // automatically unlock mutex at end of block\n```\n現在，客戶在也不會因忘記為  `unlock(Mutex)` 而出問題!\n\n## 如果有人試圖複製 `Lock` ?","lastmodified":"2024-02-23T05:15:51.430099019Z","tags":["cpp"]},"/notes/Focus/C++/Non-member-Non-friend-Function-%E7%9A%84%E5%B0%81%E8%A3%9D%E5%BA%A6%E5%84%AA%E6%96%BC-Member-Function":{"title":"Non-member \u0026\u0026 Non-friend Function 的封裝度優於 Member Function","content":"\n\u003e Non-member function 帶來更佳的封裝度、與 Packaging 彈性。\n\n\n這邊說的是 Non-member 且(AND) Non-friend function (Pure function) vs. Member Function。(關於 [[Friend Function]] )\n\n物件導向要求，資料(data) 以及操作資料的函式應該盡量綁在一起，不代表物件導向推崇 member function 是比較好的選擇。\n\n物件導向要求資料應該盡可能地被封裝，卻與直觀相反的，non-member function 的封裝性優於  member function。為什麼? \n\n## 封裝為什麼封裝被推崇? \n\u003e 封裝使得我們在改變事物時，只影響有限的客戶。\n\n- 被封裝的東西變得不可見 -\u003e 越多封裝就越少 client 可以 access -\u003e 對實作方而言，有更大的彈性改變它，因為能 access 它的客戶有限，改變的影響力小。\n- 還有另一個優點是: 帶來包裹彈性 (packaging flexibility)，這與 Namespace \u0026 header file 相關，後面會提及。\n\n## 如何衡量封裝程度\n這個問句可以換句話說，如何量測「有多少 function 可以看到某一塊資料?」。\n\n\u003e 計算能夠存取該資料的函式，越多函式存取則封裝度越低。\n\n對於 Private Member data 而言，能存取它的就是所有的 member function。\nFriend function 雖然不是 non-member function，但他和 member function 同樣擁有 access private data 的能力，所以兩者的封裝度是同樣低的。 \n\n同理，前面章節說的 [[Protected 與 Public 都是低封裝度的 Access Level]]。\n\n## 將有編譯相依的函式放在同一個 Header File\n當我們遵守本頁的守則，拆出許多 Utility Function (工具箱) 之後，該考慮將 Function 依照編譯相依性拆分到不同的 Header file，在不同的 Header file 間共用同一個 namespace 即可。\n\n書中以 `WebBrowser` 舉例，Utility Function 可能有 cookie, bookmark, core funcion (幾乎每個客戶都要的 non-member function)，cookie functions 之間有編譯相依性，放在一塊以此類推。\n\n```cpp\n// web_browser_core.hpp\nnamespace WebBrowserStuff {\n\t// core function\n\tclass WebBrowser;\n}\n\n// cookie.hpp\nnamespace WebBrowserStuff {\n\t// cookie functions\n}\n\n// bookmark.hpp\nnamespace WebBrowserStuff {\n\t// bookmark functions\n}\n```\n\n這也是 STL 的組織方式，當 User 要用 std::list 時不會去 Include 到 `\u003cvector\u003e` 這個 header file。\n\nNamespace 提供一個比較寬鬆的組織方式，即使跨越 header file 仍能隸屬相同的 namespace。\n\n甚至對 Client 而言，擴展 Utility Function 也同樣容易，只要共用 namespace 、在自己的 header file 增加客製化的 utility function 即可 -- 畢竟 Namespace 可以跨 header file! \n\n這是以 Namespace 組織，優於以 class 組織的另一個好處 : 對 Client 端而言，他們無法改變 Class 的定義式，但 namespace 他們可以自由共用。\n\n## 有著繼承也無法取代的優點\n\n當然，不能改變定義式，繼承是個解決方法。\n\n然而 C++ 的繼承中，Child 是不能取得 Parent 的 Private Data 的。繼承可以擴充 Public 方法，這點跟 non-member \u0026\u0026 non-friend function 如出一轍，沒有佔上風，卻在 package fexility 上輸了一截。\n\n這種程度的「擴展機能」相較共用 Namespace 能拆分 Header file 依賴度，就打了折扣。","lastmodified":"2024-02-23T05:15:51.430099019Z","tags":["cpp"]},"/notes/Focus/C++/ODR-use":{"title":"ODR use","content":"https://en.cppreference.com/w/cpp/language/definition#ODR-use\n\n- 當一個物件被稱為 odr use: 物件被讀取 (例外: compile time constant) 或寫入、它的 address 被取用，或有 reference 綁到他身上\n- 當一個 reference 被稱為 odr use: 當它所 reference 到的物件在 compile 期間是未知的\n- 一個 function 被稱為 odr use: 有產生對它的 function call，或它的 address 被取用\n總結: 當一個物件、reference 或 function 被稱為 odr use，表示它的定義必定 exist 於 program 的某處，違反這一點會導致 Link time error。","lastmodified":"2024-02-23T05:15:51.430099019Z","tags":["cpp"]},"/notes/Focus/C++/One-Definition-Rule":{"title":"One Definition Rule","content":"\u003e  在一個 translation unit 當中，Symbol 可以被「宣告」無數次，但只能被定義一次。\n\n宣告將符號的**名稱**導入 program 當中，定義提供創建此 symbol 的所有資訊。\n\n如果名稱表示變量，定義會對該變數進行初始化。function definition 包含 signature 與 function body，class definition 包含 class name, class member，然而 member function 的 definition 是允許被放在其他檔案的。\n\n宣告 (Declaration)\n```cpp\nint i;\nint f(int x);\nclass C;\n```\n定義 (Definition)\n```cpp\nint i{42}; // initialize int i\nint f(int x){ return x * i; }\nclass C {\npublic:\n   void DoSomething();\n};\n```\n\n\nhttps://learn.microsoft.com/en-us/cpp/cpp/program-and-linkage-cpp?view=msvc-170\n\n\u003e In a C++ program, a _symbol_, for example a variable or function name, can be declared any number of times within its scope. However, it can only be defined once. This rule is the \"One Definition Rule\" (ODR). \n","lastmodified":"2024-02-23T05:15:51.430099019Z","tags":["cpp"]},"/notes/Focus/C++/ParamType-%E6%98%AF-Pointer-%E6%88%96-Reference-%E4%BD%86%E4%B8%8D%E6%98%AF-Universal-Reference":{"title":"ParamType 是 Pointer 或 Reference 但不是 Universal Reference","content":"\nRule: \n1. If expr(argument) has **reference**, ignore the reference part. \n2. T = ArgumentType - declared ParamType.\n","lastmodified":"2024-02-23T05:15:51.430099019Z","tags":["cpp"]},"/notes/Focus/C++/ParamType-%E6%98%AF-Universal-Reference":{"title":"ParamType 是 Universal Reference","content":"當 ParamType 被宣告成 `T\u0026\u0026` (Universal Reference) 時，傳入的變數是 rvalue 或 lvalue 在推斷的流程是**不同的**。詳細在 [[Item24 Distinguish universal references from rvalue references]] 會說明。\n\n原則是: \n 1. 當傳入的是 lvalue，`T` 和 `ParamType` 都會推斷成 lvalue reference type。注意，在 Case 1. 當中，`T` 的推斷是不會保留 reference part 的。\n 2. 當傳入的是 rvalue，則規則有如 [[ParamType 是 Pointer 或 Reference，但不是 Universal Reference]]","lastmodified":"2024-02-23T05:15:51.430099019Z","tags":["cpp"]},"/notes/Focus/C++/ParamType-%E9%9D%9E-Reference-%E6%88%96-Pointer":{"title":"ParamType 非 Reference 或 Pointer","content":"當 ParamType 不是 Ref 也非 ptr，真正的 `ParamType=T` 時，傳入的物件會被做 **pass by value**。\n在 pass by value 中，只有 pure class infomation 會被保留下來\n\n1. Remove reference-ness\n2. Remove constness\n3. Remove volatileness (少見)\n\n之所以遵守這個原則是因為，當物件以 Copy (pass by value) 傳進來之後，template function 當中的物件已經跟外面的物件完全脫鉤，對它改變的數值也不該影響到外面 (reference-ness)，而外面的物件能否被改動 (constness) 也不甘 function 內變數的事情。\n因此，這些屬性都會被移除。\n\n但是注意下面這個 case:\n\n```cpp\ntemplate \u003ctypename T\u003e\nvoid f(T param);\n\nconst char* const ptr = 'what is this';\nf(ptr); // arg type: const char* const\n\t\t// T       : const char*\n```\n\nptr 是一個指向 const char 的 pointer (`const char*`)，並且這個 ptr 是不可以被改變的 (`const`)，它必須持續指向被 assigned 的物件。綜合起來就是: ptr 是一個不可被改變的 pointer，它持續指向一個不可被改變的 char 物件。\n\n在它的型態推斷中，由於被 copy 的是 `ptr`，故 ptr 的 constness 會消失。也就是說，ParamType 變成 `const char*`，`parm` 是一個指向「不可被變更的 `char` 物件」的 pointer，但 `parm` **可以更改** 所指的對象，只要對方是一個 `const char` 即可。\n\n\u003e `ptr` 從只喜歡「那一個」短頭髮的女生，變成喜歡短頭髮的女生，哪個都可以。 (渣)\n\n由於被 Copy 的對象是 Pointer，被移除 constness 的也只有 Pointer。Pointer 所指向的對象的 Constness 被保留了下來。\n","lastmodified":"2024-02-23T05:15:51.430099019Z","tags":["cpp"]},"/notes/Focus/C++/Parameter-Pack":{"title":"Parameter Pack","content":"\nWhen the ellipsis `...` is on the left of the type parameter T1, the parameter pack is packed; when on the right, it is unpacked. \n\nThis unpacking in the return statement `T(std::forward\u003cT1\u003e(t1)...)` essentially means that the expression `std::forward\u003cT1\u003e(t1)` is repeated until all arguments of the parameter pack are consumed and a comma is put between each subexpression. \n\nFor the curious, [C++ Insights](https://cppinsights.io/s/ad5b8b5d) shows this unpacking process.\n","lastmodified":"2024-02-23T05:15:51.430099019Z","tags":["cpp"]},"/notes/Focus/C++/Pass-by-value-%E7%95%B6%E4%B8%AD%E7%9A%84-Copy-%E8%A1%8C%E7%82%BA":{"title":"Pass by value 當中的 Copy 行為","content":"\n## Simple Pass By Value\n考量下面的程式 `validateStudent(s)` 執行的成本有什麼?\n\n```cpp\nclass Person;\nclass Student: public Person;\nbool validateStudent(Student s); // pass by value = copy\nStudent s = Student();\nvalidateStudent(s); \n```\n\n成本是\n- Student Copy Constructor\n- Person Copy Constructor\n一個 Copy Ctor 就意味著一次全部 member data 的 Copy，所以 data 越多呼叫越多 Copy Ctor!! \n\n## 多型函式\n當 Signature 是 Parent，傳入的是 Child，更糟糕的是會發生 Slicing! 只有 `Person` 部分的資料會被 Copy，`Worker` 的資料都被切割了。\n\n```cpp\nclass Worker: public Person;\nbool showName(Person s);\n\nWorker w = Worker();\nshowName(w);\n```","lastmodified":"2024-02-23T05:15:51.430099019Z","tags":["cpp"]},"/notes/Focus/C++/Prefer-simple-and-conventional-ways-of-passing-information":{"title":"Prefer simple and conventional ways of passing information","content":"## 如何決定 Function Signature 的長相\n\n- headings: 資料結構 copying 跟 moving 的成本\n- row: parameter 的性質\n\t- In \u0026 retain copy: 在 function 內部會發生 copy \n\t- In \u0026 retain \"copy\": Moved-from means that it is in a valid but not nearer specified state.\n\t- In/out: 在 function 會被變更內容\n\t- out: 透過 function 所產生的回傳值\n後面會有更多 rule 說明這些東西\n![[Pasted image 20240114215359.png]]\n\n案例\n- 當 Copy 很輕鬆，或不可能發生 Copy 的時候，pass by copy 沒問題: int, std::uniqure_ptr。\n- Move 的成本低: `std::vector`, `std::string`\n- Move 的成本適中: `std::array\u003cstd::vector\u003e` or BigPOD (POD stands for Plain Old Data—that is, a class without constructors, destructors, and virtual member functions.)\n- 不知道 Move 的成本: Template。\n## \"in\" parameter \n1. 只有非常「便宜」的才 pass by copy \n2. 其他用 `const \u0026 `\n\nC++ Core guideline 提供一個標準衡量 copy 物件是否足夠「便宜」  \n\u003e 當 `sizeof(parm) \u003c 3*sizeof(void*)`\n\n## \"forward\" Parameter \n這種參數對 lvalue 做 copy，rvalue 做 move。constness 在 lvalue 被忽略，但保留於 rvalue。\n\nforwarding parameter 通常用於[[工廠函式 (Factory Function)]] --  像是透過一個 construct function 生成任意物件\n\n\n```cpp\ntemplate \u003ctypename T, typename ... T1\u003e  // parameter pack \nT create(T1\u0026\u0026 ... t1) {\n   return T(std::forward\u003cT1\u003e(t1)...);\n}\nint main() {\n   // lvalue\n   int five=5;\n   int myFive= create\u003cint\u003e(five);\n\n   // rvalues\n   int myFive2= create\u003cint\u003e(5);\n\n   // no arguments\n   int myZero= create\u003cint\u003e();\n\n   // three arguments; (lvalue, rvalue, rvalue)\n   MyType myType = create\u003cMyType\u003e(myZero, 5.5, true);\n}\n```\nRelated syntax: [[Parameter Pack]]\n\nForward argument 與 template 結合的最好範例就是 `std::make_unique`。\n\n```cpp\ntemplate\u003ctypename T, typename... Args\u003e\nstd::unique_ptr\u003cT\u003e make_unique(Args\u0026\u0026... args) {\n   return std::unique_ptr\u003cT\u003e(new T(std::forward\u003cArgs\u003e(args)...));\n}\nstd::make_unique\u003cT\u003e creates a std::unique_ptr for T\n```\n\n## \"in-out\" Parameters \n在 function 中會更動 object 的數值，因此應以 non-const reference 傳遞。\n\n\n\n\n## 資源所有權 Ownersip Semantics for Parameter Passing\n\n\"Ownersip Semantics\" 直翻 \"所有權語義\"，在談論不同的 Parameter type 宣告下的「資源所有權」。\n\n|  |  |\n| ---- | ---- |\n| Pass by Copy | Function 直接擁有資源 |\n| Pass by pointer | Function \"借用(borrow)\" 此資源，使用前應確認 pointer 非 Null，它「應當」無權釋放資源。   |\n| Pass by reference | 同樣 \"借用\" 資源，但 reference 永遠是 valid value。 |\n| func(std::unique_ptr) | `func` 是資源的新擁有者 (owner)，互叫此 `func` 的 caller 相當於把 ownership 轉移給 `func` (callee)，並且資源會在 function 結束時 release。 |\n| func(std::shared_ptr) | `func` 是新增的資源擁有者，他延長了資源的 lifetime。`func` 在離開前，會把自己的擁有權從資源刪掉，如果它是最後一個擁有者，則資源會在 `func` 離開時 release。 |\n\n弄清楚誰是資源的 owner 至關重要，以下面這個範例，誰應該是資源 `ptr` 的擁有者? (誰應負責 delete resource? )\n\n按照前面的分配，`func` 是 pass by pointer，它可以改寫內容、可以讀取，但不應刪除資源。\n\n我想這一段在說明的是一個「準則」，讓大家一起 follow 這段準則，避免資源所有權混亂造成記憶體洩漏。更方便的做法，不外乎別用 C-array，多用 smart_ptr .... 。\n\n```cpp\nvoid func(double* ptr) {...}; \n\ndouble* ptr = new double []; \nfunc(ptr);\n```\n\n\n[[How to Pass Output Value]]","lastmodified":"2024-02-23T05:15:51.43409902Z","tags":["cpp"]},"/notes/Focus/C++/Protected-%E8%88%87-Public-%E9%83%BD%E6%98%AF%E4%BD%8E%E5%B0%81%E8%A3%9D%E5%BA%A6%E7%9A%84-Access-Level":{"title":"Protected 與 Public 都是低封裝度的 Access Level","content":"\n思維誤區: Protected 不比 Public 具有更好的封裝性\n- 取消一個 Public Member Data 的成本: 所有使用他的客戶端\n- 取消一個 Protected Member Data 的成本 : 所有繼承他的 Derived Class\n這兩種 Access Level 的封裝性都不佳，仍該盡可能的使用 Private。","lastmodified":"2024-02-23T05:15:51.43409902Z","tags":["cpp"]},"/notes/Focus/C++/Pure-Virtual-Destructor":{"title":"Pure Virtual Destructor","content":"現在的情境是，如果，你想要有一個抽象類 -- 抽象類的好處是自身無法被實例化。然而，抽象類的定義是，至少有一個 function 是 Pure Virtural Function。該選擇 \"誰\" 成為 Pure virtural function 呢? 洽巧手上沒有適合的人選! Destructor 會是個好選擇。因為\n1. Abstract Class 總是被當作 Base Class\n2. Base Class 作為多型用途時，應當帶有 virtural destructor\n3.  [[Pure Virtual Function]] 可使該 Class 形成 Abstract\n三個點串起來--「讓 destructor 變成 Pure Virtural 吧」，這樣不會有不該被 virtural 的 function 遭殃! \n\n\u003e Abstruct Class 是不能被實例化的 Class，但可以持有 Abstruct Class 的 Pointer 去操控 Child instance。\n\n不過須記得一個技巧 -- 依然為這個 Base Class 的 Destructor 提供一個空的實作。\n這是因為 Destructor 的運作規則，在繼承架構中，most derived class (最 child 的) 的 destructor 會最先被呼叫，接著是每一個 Base Class 的 Destructor。即使 `AWOV` 作為抽象類沒有實例化的問題，其 destructor 依然會被呼叫，所以需要提供一個空的實作，Linker (編譯器的一部分?) 會報錯。\n```cpp\nclass AWOV {\npublic:\n\tvirtural ~AWOV() = 0;\n}\n\nAWOV::~AWOV() {}; // 依然為它提供一個實作\n```\n\n ","lastmodified":"2024-02-23T05:15:51.43409902Z","tags":["cpp"]},"/notes/Focus/C++/Pure-Virtual-Function":{"title":"Pure Virtual Function","content":"\n\u003e 只繼承 Interface 需自行實做\n\n相當於告訴 Client: 你需要提供一個這樣的函式，但我不干涉你怎麼做它。\n```cpp\nclass Shape {\npublic:\n\tvirtual void draw() const = 0;\n};\n```\n\n不過，我們其實可以為 Pure Virtual Function 提供一份實作碼，只是需要通過 Class Name 呼叫 (以 `Shape::draw` 而非 `shape.draw` 呼叫)，這樣既可以提供一份預設內容，又可以強制 Derived class 要自行實作 (自行 call `Shape::draw`)。\n\n而對於 `Shape` ，它擁有一個 pure virtual function，也就是說它自身永遠不可能被實例化。即使提供實作，也不能直接由 `ps-\u003edraw()` 這樣調用。\n\n```cpp\nShape *ps = new Shape; // error! Shape is abstract\n\nShape *ps1 = new Rectangle; // fine\nps1-\u003edraw(); // calls Rectangle::draw\nps1-\u003eShape::draw(); // calls Shape::draw\n```\n","lastmodified":"2024-02-23T05:15:51.43409902Z","tags":["empty"]},"/notes/Focus/C++/Pure-function":{"title":"Pure function","content":"\n## Pure Function \n\n\u003e 給予相同的輸出，總是回傳相同的結果，它彷彿一個大個 lookup table \n\nC++ 並沒有 keyword 讓 programmer 宣告函式為 pure function \n[Pure Functions in C++‬](https://soroush.github.io/en/2020/08/06/pure-functions-in-cpp/)\n\n## Impure function \n- impure function: 包含了 `random`, `time` 之類的。\n\n\nimpure functions are functions such as random() or time(), which can return a different result from call to call. \nTo put it another way, functions that interact with state outside the function body are impure.\n","lastmodified":"2024-02-23T05:15:51.43409902Z","tags":["cpp"]},"/notes/Focus/C++/STL-alogirthm":{"title":"STL alogirthm","content":"","lastmodified":"2024-02-23T05:15:51.43409902Z","tags":["empty"]},"/notes/Focus/C++/Sequence-Containers":{"title":"Sequence Containers","content":"\n## Complexity \n`O(1)`: 與容器的 size 無關，具有 constant runtime，但兩個容器的 complexity 都是 `O(1)` 並不表示相同的操作有相同的速度，僅表示不隨著容器的增加而影響 runtime。\n\n- `std::array` : homogeneous container of fixed length.\n- `std::vector` : homogeneous container, which length is automatically adjusted at runtime.\n\n| Container | homogeneous | length | Memory is continusous |\n| ---- | ---- | ---- | ---- |\n| `std::array` | Yes | fixed |  |\n| `std::vector` | Yes | Adjust at runtime. | Yes |\n| `std::deque`  | Yes | fixed | 多段 std::array 所組成的 sequence |\n|  |  |  |  |\n## std::array \n\n結合了 C array 的特性以及 `std::vector` 的 interface。\nIndex access 有三種方式\n1. `arr[n]`: 不會 check index out of range\n2. `arr.get(n)`: 當 index out of range 時會拋出 `std::range-error` exception.\n3. `std::get\u003cn\u003e(arr)`\n\n## std::vector\n注意 initialize std::vector 時，`{}` 是 [[Initializer List]]，與 `()` 的意思是不同的。\n```cpp\nstd:: vector \u003c int \u003e( 10, 2011) // 10 個元素都是 2011 \nstd:: vector \u003c int \u003e{10, 2011}  // 2 個元素，分別是 10 跟 2011\n```\n\n### size 與 capacity \n- `size` : 表示容器當前的元素數量\n- `capacity`:  是在不 reallocate 記憶體的情況下，能夠有多少個元素。\n- `resize(n)`: 將容器的 size 增加到 n\n- `reserve(n)`: 保留最後 n 個 elements 的 memory \n- `shrink_to_fit()`: 減少沒用到的 capacity ，這只是一個請求 ([no-binding request](https://en.cppreference.com/w/cpp/container/vector/shrink_to_fit#:~:text=vector%3A%3Ashrink_to_fit\u0026text=It%20is%20a%20non%2Dbinding,to%20the%20elements%20are%20invalidated.))，implementation 可以自行決定是否真的執行。\n\n\n## std::deque\n由很多段 `std::array` 組成的 sequence \n\n## std::list \n雙向 linked list，雖然介面都很像，但實作非常不同\n1. 不支援 random access \n2. access 任意 element 非常慢，因為要 iterate \n3. 加/減 elements 很簡單，接一下 pointer 而已\n4. 加/減 elements 後，iterator 依然有效。\n## std::forward_list\n- 單向 linked list，比 memory 需求比較少。\n- iterator 不支援 `it--`\n- 是唯一不知道自己 size 的 container\n- ","lastmodified":"2024-02-23T05:15:51.43409902Z","tags":["cpp"]},"/notes/Focus/C++/Singleton":{"title":"Singleton","content":"\n## Drawback of Singleton \n- 誰負責銷毀它?\n- 這個 singleton 應該可以被繼承嗎?\n- 怎麼實作 singleton 使它 thread-safe \n- 如果 singleton 之間有相依性，而且在不同的 translation unit，順序應該是? \n\n[What’s the “`static` initialization order ‘fiasco’ (problem)”?](https://isocpp.org/wiki/faq/ctors#static-init-order)\n\n\n## Use Dependency Injection to resolve singleton dependency \n\n如果物件必須用到 singleton ，代表這個物件與 singleton 之間隱藏著 dependency。\n\n比起直接在 function 內呼叫 singleton，將需要的內容透過  argument 、透過 setter 、template argument 等方式設進來，可以把依賴阻隔在真正的內容之外。\n\n透過 [[Dependency Injection]]，把與 singleton 的依賴留 arguemnt.\n","lastmodified":"2024-02-23T05:15:51.43409902Z","tags":["empty"]},"/notes/Focus/C++/Smart-Pointer":{"title":"Smart Pointer","content":"\n在[[為多型用途的基礎類別宣告 virtual 解構式]]文章中的 `TimeKeeper` 例子，我們提及了工廠函式 (factory function)，在該例子，我們把 delete `new` resource 的責任交給 Client。\n\n然而有很多情況--例如 main flow 中過早的 return，resource 可能沒有成功被銷毀。善用 Pointer-like 物件，並把銷毀資源的操作**確實**的寫在 Destructor 中可以避免這些問題。\n\nSmart Pointer 的原理是利用一個 object 去 own (or manage, 管理) 一個 heap-based 的資源，當 Smart Pointer Object 脫離 Scope，Compiler 試圖去 destructor 時，藉機呼叫手上 Object 的 destructor。\n\n## Smart Pointer 當中的顯式與隱式轉換\n1. Smart Pointer 的 `get` function 是一種顯式轉換 (explicit)，允許 client 取得原始物件的原始型別指標。\n2. Smart Pointer Override 了 `operation*` 和 `operator-\u003e`，因此 client 端可以直接對它做指標操作，有如對待 raw pointer，這隱含的是隱式轉換 (implicit)\n\n## 顯式/隱式轉換介面\n如上述， `get` function 是一種顯式轉換 (explicit)，它的優點是使用時意圖清楚，缺點是很醜。\n其實，亦可以提供個隱式轉換的介面，如此當這個物件被放到 base resource 的類別時，就不用特別透過 `get` 提取 base resource，缺點是會提升發生錯誤的風險。\n\n選擇何種，取決於使用情境，記住 [[讓介面易於被使用，不易誤用]]，不要讓你的介面容易被誤用，即可。","lastmodified":"2024-02-23T05:15:51.43409902Z","tags":["cpp"]},"/notes/Focus/C++/Static-Object":{"title":"Static Object","content":"\n\u003e 壽命從被建構出來，持續到程式結束為止。\n\n因此 Stack 和 Heap-based 物件都不是 static object。\n這種物件包含 Global Object，定義在 Namespace Scope 的物件，Class \u0026 Function \u0026 File 內宣告成 `static` 的物件。\n- Function 內的 static object 稱為 local static object (Scope 只在 function 內)\n- 其他被稱為 non-local static object\n它們的 deconstructor 會在 main 結束時被喚起。\n\n當我們有兩個編譯單元 ([[Translation Unit]])，通常表示兩份 Source Code。兩份 Source Code 中都有 non-local static object，且其中一份 static object 的初始化需要使用到另一份 source code 的 static object。\n\n問題在於，有可能要被使用的那個物件尚未被初始化! \n\u003e C++ 對於不同 [[Translation Unit]] 中 non-local Static object 初始化的順序並沒有明確的定義。\n\u003e The relative order of initialization of non-local static objects defined in different translation units is undefined.\n\n這是有原因的，因為決定這個順序非常困難，近乎無解，甚至不值得去找解。\n\n這種問題常見於[[Implicit TemplateInstantiation]] 模板隱式具現化。 (? 不確定翻譯)\n\n## Make Non-local Static Object become Local Static Object\n\n\u003e C++ 保證，函式內的 Local static object 會在該函式被呼叫期間，首次遇到該物件的定義式時初始化。\n\n我們可以利用此原則，解決 dependency of 2 non-local static object in 2 different translated units 的問題。\n\n\u003e 將每個 non-local static object 搬到專屬的 function 內，以 local static object 的方式存在。Design Pattern 中的 [[Singleton]] 就式常見的實作方式。\n\n其原理在於，所以比起直接呼叫 non-local static object，使用 function call 的做法更佳。更棒的是，若你從未呼叫「模擬該 non-local static object 的 function」，則 「那個 object 」根本**不會初始化**，有延遲初始化的功效在! 這是真正的 non-local static object 所不能及的。\n\n`static` 可以確保唯一性，Singleton 本身就常常與 Static 搭配使用。\n\n```cpp\nclass FileSystem { ... };\n\nFileSystem\u0026 tfs()\n{\n    static FileSystem fs;\n    return fs;\n}\n\nclass Directory { ... };\nDirectory::Directory( params )\n{\n    std::size_t disks = tfs().numDisks();\n}  \n\n// The first call function.\nDirectory\u0026 tempDir()\n{\n    static Directory td( params );\n    return td;\n}\n```\n此種手法稱為 reference-returning。\n\n在此例子中，`tmpDir` 創建物件 `td`，在 call `Directory` Constructor 時，會再 call `tfs` ，此時才創建 static object `fs`。透過 function call，確保了物件初始化的順序，先初始化 `fs`，再創建 `td`。\n\n### 優點\n特別在頻繁呼叫的時候，搭配 [[了解 Inline 的裡裡外外]]。\n\n### 缺點\n在 multi-thread 中有不確定性。任何一種 non-const static 物件如果**依賴於其他事件的發生**，都很麻煩。常見的解決方法是，在 single-threaded startup portion 手動喚起所有 reference-returning function，手動解決 race conditions。\n","lastmodified":"2024-02-23T05:15:51.43409902Z","tags":["cpp"]},"/notes/Focus/C++/Swap-and-pimpl":{"title":"Swap and pimpl","content":"\n## std::swap\nSTL 的 swap 平凡無奇，涉及了三次的複製。\n```cpp\nnamespace std {\n    template\u003ctypename T\u003e\n    void swap (T\u0026 a, T\u0026 b) {\n        T tmp(a);\n        a = b;\n        b = tmp;\n    }\n}\n```\n\n但對於「某些型別」而言，他們滿足某些資格。因為有這種前提，`std::swap` 的標準做法(三次複製)是多餘的，他們有更快的解法。\n\n「以指標指向一個物件，那個物件含有真正的資料」的型別，就是那些特殊的、滿足資格的傢伙。常見的手法是 [[pimpl idiom (pointer to implementation)]] ，Pattern 如下: \n- `Widget` 的 Copy Assignment 實際上是複製 `rhs.pImpl` 所有內容到自己的 `pImpl` 複製一份過來。\n```cpp\nclass WidgetImpl {\nprivate:\n    int a, b, c; \n    ... // a lot of data\n}\n\nclass Widget {\npublic:\n    Widget(const Widget\u0026 rhs);\n    // copy assignment: 把 WidgetImpl 的每一個內容都複製一份過來\n    Widget\u0026 operator=(const Widget\u0026 rhs) {\n        *pImpl = *(rhs.pImpl); \n    }\n\nprivate:\n    WidgetImpl* pImpl;\n}\n```\n\n當 Widget 在 swap 時 Copy Assigment 會發生足足三次! 實際上卻是 -- 只要把 `lhs.pImpl` 和 `rhs.pImpl` 兩個 Pointer 互換即可。\n\n## 實作 Swap \n首先，需要用到 [[Template Specialization]] 。我們不被允許改變 STD 空間內的東西，但我們被允許用 STD Template 製造特異化版本，當 swap 用於 `Widget` 物件時自動使用特異化版本的 function。\n\n```cpp\nnamespace std {\n\ttemplate\u003c\u003e \n\tvoid swap\u003cWidget\u003e (Widget\u0026 a, Widget\u0026 b) {\n\t// 以上兩行表示 total template specialization: 當用在 Widget 時\n\t// 用這個特異化的 function!\n\t\t\n\t\t// swap(a.pImpl, b.pImpl); // 會失敗，因為 pImpl 是 private.\n\t\ta.swap(b);\n\t}\n}\n\nclass Widget {\npublic:\n\tvoid swap(Widget\u0026 other) {\n\t\tusing std::swap; // necessary.\n\t\tswap(pImpl, other.pImpl);\n\t}\n}\n```\n\n在 `Widget::swap` 裡指定 `using std::swap` 是必要的。\n\n\u003e [!danger]\n\u003e 讀到 P111，我懷疑 C++11 之後有不同的做法，先不細看。\n\n\n## Name Lookup Rules\n","lastmodified":"2024-02-23T05:15:51.43409902Z","tags":["cpp"]},"/notes/Focus/C++/Template-%E5%B8%B6%E4%BE%86%E7%9A%84%E7%A8%8B%E5%BC%8F%E7%A2%BC%E8%86%A8%E8%84%B9":{"title":"Template 帶來的程式碼膨脹","content":"Template 可能導致 binary 內有重複的程式碼、資料，儘管 source code 看起來沒有重複的問題，object code 卻異常肥大。\n\n## 避免輸入類別無關的 code 帶來的程式膨脹\n跟共性與變性分析 (commonality and variability analysis)\n把程式碼中與「輸入類別有關」跟「與輸入類別無關」的部分分開。困難的是需要學習「感受」template 被具現化很多次時可能發生的「重複行為」。\n\n下面這段例子，Template 輸入參數有兩個: `T` 跟 `n` (矩陣的 size)，只要這兩個參數的組合不一樣，就會具現化一次物件。\n`sm1` 跟 `sm2` 分別是一個 \"5\\*5 矩陣\" 跟 \"10\\*10矩陣\" 物件，並且 `SquareMatrix::invert` 會被具現化**兩次**!! \n```cpp\ntemplate\u003ctypename T, std::size_t n\u003e\nclass SquareMatrix { \npublic:\n\tvoid invert(); \n};\n\nSquareMatrix\u003cdouble, 5\u003e sm1;\nsm1.invert(); // call SquareMatrix\u003cdouble, 5\u003e::invert\nSquareMatrix\u003cdouble, 10\u003e sm2;\nsm2.invert(); // call SquareMatrix\u003cdouble, 10\u003e::inver\n```\n\n解決辦法: 把 `invert` 核心部份抽出來自成一個 Template，另一個 Template 專處理不同的 size。\n下面的解決辦法有幾個看點\n1. `SquareMatrixBase` 和 `SquareMatrix` 走的是 private 繼承，表示 **不是 is a 關係**。\n2. `using SquareMatrixBase\u003cT\u003e::invert` 是為了避免[[繼承時的名稱遮掩行為]]，`SquareMatrixBase::invert` 與 `SquareMatrix::invert` 雖然 signature 不同，卻有名稱遮掩問題。\n3. `this-\u003einvert(n)`: \n\t1. [[了解如何在 Template 中指涉 Base Class 成員]] 中提到的。\n\t2. 這裡做的是隱晦的inline 呼叫，不會因為呼叫而帶來而外的成本。[[了解 Inline 的裡裡外外]]\n\n這樣一來\n- `SquareMatrixBase\u003cdouble\u003e` 只會有一份\n- `SquareMatrix\u003cdouble, 5\u003e`, `SquareMatrix\u003cdouble, 10\u003e` 各一份，但他們呼叫到的 `SquareMatrixBase\u003cdouble\u003e`  會是同一份。\n```c++\ntemplate\u003ctypename T\u003e // size-independent base class for\nclass SquareMatrixBase { // square matrices\nprotected:\n\tvoid invert(std::size_t matrixSize); // invert matrix of the given size\n};\n\ntemplate\u003ctypename T, std::size_t n\u003e\nclass SquareMatrix: private SquareMatrixBase\u003cT\u003e {\nprivate:\n\tusing SquareMatrixBase\u003cT\u003e::invert; // 因為有同名的 invert (雖然 signature 不同)\npublic:\n\tvoid invert() { this-\u003einvert(n); } // make inline call to base class\n}; // version of invert\n```\n\n## 與輸入類別相關的 code 所帶來的程式膨脹\n像是 `std::vector\u003cint\u003e`, `std::vector\u003cdouble\u003e` 勢必會造成兩個不同的 class。\n同樣的 `std::vector\u003cint*\u003e`, `std::vector\u003cdouble*\u003e` 也會，如果沒有必要生成這麼多的 class，對於 pointer type，讓操作強型別 (Strongly type pointer `T*`) 去呼叫無型別 (`void*`) 是需要的。\n\n\n\n\n\n\n","lastmodified":"2024-02-23T05:15:51.43409902Z","tags":["cpp"]},"/notes/Focus/C++/Template-%E7%9A%84%E7%94%A8%E9%80%94":{"title":"Template 的用途","content":"- Container Used: Template 讓 Programmer 得以建立 Type-Safe 的容器，像是 list, map, vector...\n- Generic Programming: 寫出的程式碼跟所處理的類別彼此獨立 (ex. STL 的 `for_each`, `find` 和 `merge`)\n- Template metaprogramming: 在 Compiler 內執行、並在編譯完成時停止執行的 program (the creation of programs that execute inside C++ compilers and that stop running when compilation is complete.)\n","lastmodified":"2024-02-23T05:15:51.43409902Z","tags":["cpp"]},"/notes/Focus/C++/Template-%E8%88%87%E9%9A%B1%E5%BC%8F%E4%BB%8B%E9%9D%A2":{"title":"Template 與隱式介面","content":"\n- 物件導向以顯式介面 (explicit interface) 和執行期多型 (runtime polymorphism) 解決問題。\n- Template 與 Generic Programming 而言，隱式介面 (implicit interface) 與編譯期多型 (compile-time) 更重要。\n\n## 多型\n|      | 物件導向  | Generic Programming  |\n|  ----  | ----  | ----  |\n| 多型  | 執行期多型 (runtime polymorphism) | 編譯期多型 (compile-time) |\n| 概念(打比方)  | 執行期間決定哪一個 virtual function 要被呼叫 | 編譯期間做 template 具象化、與函式重載決議 (function overloading resolving)| \n\n\n## 介面\n|      | 物件導向  | Generic Programming  |\n|  ----  | ----  | ----  |\n| 介面  | 顯式介面 (explicit interface) | 隱式介面 (implicit interface)    |\n| 說明  | Signature 由函式名稱、參數型別、反回型態構成，class 明確定義有哪些 function| 沒有定義明確的 signature，只要有對應的 overloading function 被呼叫即可。|\n\n### 顯式介面\n- Function Signature 由函式名稱、參數型別、反回型態構成。\n\t- 對 overloading 而言，函式名稱相同、參數型別相同、return type 不同，無法成功 overload。他們會被視為 duplicate。\n\t- 但對一個 function 而言，function name, parameter type, return type 是必須的，而 effective C++ 的作者習慣將這三組一起稱為 signature。\n- Class 會明確的定義有哪些 function，下例 `Widget` 就有 constructor, destructor, `size`, `normalize`, `swap`。並且 `Widget` 具有 virtual function，表示它有可能有 Derived class 而得以做 runtime polymorphism。\n\n```cpp\nclass Widget {\npublic:\n\tWidget();\n\tvirtual ~Widget();\n\tvirtual std::size_t size() const;\n\tvirtual void normalize();\n\tvoid swap(Widget\u0026 other);\n};\n```\n\n### 隱式介面\n再看下例的 Template function: \n```cpp\ntemplate\u003ctypename T\u003e\nvoid doProcessing(T\u0026 w)\n{\n\tif (w.size() \u003e 10 \u0026\u0026 w != someNastyWidget) { ... }\n}\n```\n乍看下，此 function 對 T 似乎有兩個要求\n1. 具有 member function `size`，且回傳一個 int type。\n2. 支援 `operator!= `，得以比較 `someNastyWidget` \n\n實際上 [[operator overloading]] 讓這兩個約束不需要\"完全\"滿足\n- 第一點\n\t- 確實，T 需要有 `size` 函式，它也可以是從 `T` 的 base class 繼承來的，都可。\n\t- 但是 return type **不一定** 需要為 int，假設 `T::size` 回傳 type `X`，只要 `(X, int)` 這樣的參數式得以呼喚起一個 `operator\u003e` 即可!\n\t- 這並非表示要有一個 `operator\u003e(X, int)`，如果 `X` 有能力透過隱式轉換成 `Y`，並且存在 `operator\u003e(Y, int)`，就足以讓此條件滿足了! \n- 第二點\n\t- 同理，只要有 `operator!=` 支援比較 T 與 type of `someNastyWidget` 就足夠了。\n\t\t- 同第一點的邏輯，最低條件需要有一個 `operator!=(X, Y)` 的函式，且 `T` 具有轉換成 `X` 的能力，type of `someNastyWidget` 具有轉換成 `Y` 的能力。\n\n現在，展開 doProcessing 的全貌\n```c++\ntemplate\u003ctypename T\u003e\nvoid doProcessing(T\u0026 w)\n{\n\tif (w.size() \u003e 10 \u0026\u0026 w != someNastyWidget) {\n\t\tT temp(w);\n\t\ttemp.normalize();\n\t\ttemp.swap(w);\n\t}\n}\n```\n\n此 template function 同樣對於 member function `normalize`, `swap`, `size`，copy constructor 有要求 -- 總之要讓那些 function 在 `T` 上有效，做甚麼轉換都行!\n\n這些加諸在 `T` 上的「隱晦的要求」，就像是一種隱式介面 -- 能執行成功就代表這個 T 具有這些介面。而被傳入的 `T` 是否具有這些介面，在編譯期間就會檢查。\n\n就像我們無法對顯示介面的 class 呼叫一些不存在的 function 一樣，呼叫了不存在於顯式介面上的函式將無法通過編譯，無法滿足隱式介面的程式也同樣無法通過編譯。\n\n\n","lastmodified":"2024-02-23T05:15:51.43409902Z","tags":["cpp"]},"/notes/Focus/C++/Template-Method":{"title":"Template Method","content":"#DesignPattern","lastmodified":"2024-02-23T05:15:51.43409902Z","tags":["empty"]},"/notes/Focus/C++/Template-ParamType-deduction":{"title":"Template ParamType deduction","content":"\n\u003e `T` is a part of ParamType when it declared in template.\n\n- Case1. [[ParamType 是 Pointer 或 Reference 但不是 Universal Reference]]\n- Case2. [[ParamType 是 Universal Reference]]\n- Case3. [[ParamType 非 Reference 或 Pointer]]\n- Case4. [[Array As an Argument]]\n- Case5. [[Function As an Argument]]\n\n## Conclusion\n\n1. 當 Argument 是有 Reference 時，其 Reference-ness (`\u0026`) 會被忽略\n2. Universal Reference 在收到 lvalue argument 走的程序是特別的。\n3. 做 Pass by value (Copy) 時，常數性(constness) 會消失\n4. Function name \u0026 array name Argument 會 decay 成 Pointer 進行 template deduction，除非該 template 的 parameter type 是宣告成 Reference。\n\n","lastmodified":"2024-02-23T05:15:51.43409902Z","tags":["cpp"]},"/notes/Focus/C++/Template-Specialization":{"title":"Template Specialization","content":"\nTemplate 可以針對特定的 Type 特化，寫法如下\n1. `template\u003c\u003e` 裡面不放任何參數，表示這不是 template 也不是標準的 class，是一個特化的 `MsgSender`。\n2. `class MsgSender\u003cCompanyZ\u003e` 表示  template `MsgSender` 在遇到 input type 是 `CompanyZ` 的時候，要用以下定義的內容。\n以下這段範例就是 `MsgSender` 針對 `CompanyZ` 特別訂製的內容，這就是模板全特化 (Total Template Specialization)。\n\n```c++\ntemplate\u003c\u003e // a total specialization of\nclass MsgSender\u003cCompanyZ\u003e { // MsgSender; the same as the\npublic: // general template, except sendClear is omitted\nvoid sendSecret(const MsgInfo\u0026 info)\n{ ... }\n};\n```\n此例呼應 [[了解如何在 Template 中指涉 Base Class 成員]] 的範例，`MsgSender` 對於一般輸入類別都有 `sendSecret` 跟 `sendClear` 兩個 function。但在這裡，`CompanyZ` 的特化版將不存在 `sendClear`! \n\n## Template Specialiaztion 與 Declaration\n雖然 Template 多習慣把實作寫在 hpp，若將 Template Specialiaztion 實作寫在 hpp 卻可能發生問題。\n假設有三個檔案，`temp.hpp` 寫著 template 與 Template Specialiaztion 的實作，兩個 cpp: `a.cpp` 與 `b.cpp` 分別 include  temp.hpp，基於 [[One Definition Rule]]，這會引發 multiple definition (見 [multiple definition of template specialization when using different objects](https://stackoverflow.com/questions/4445654/multiple-definition-of-template-specialization-when-using-different-objects))。\n\n解決方法有兩種\n1. 宣告 Template Specialiaztion 於 hpp，實作放在 cpp\n2. 一樣把實作放在 hpp，但是多宣告 inline 於 Template Specialiaztion 的實作上。\n\n### 分離 Template Specialiaztion 實作\n\ntemp.hpp: \n```cpp\ntemplate\u003ctypename T\u003e void func(T\u0026 val);\ntemplate\u003c\u003e void func\u003cint\u003e(int\u0026 val); // Specialiaztion\n```\n\ntemp.cpp\n```cpp\ntemplate\u003c\u003e void func\u003cint\u003e(int\u0026 ) {}\n```\n\n\n\n## 應該選擇分離 Definition 還是宣告 inline?\n\nLike the other Q\u0026A mentions, the specialization is its own entity. If you do as you did, declare the specialization in a header, and then define them in another (single) TU, that is well-formed. Any TU that includes that header will see that the specialization for `int` and `float` are only declarations. \nAs such, their definition may be placed elsewhere, just like a non-template function.\n\nIf you want a header only library, where the specialized functions are defined inline, then you must use the `inline` specifier, as the ODR requires.\n\nNeither way is \"the correct\" way in the sense you seem to be asking about. Each has its own advantages and disadvantages. Defining the functions inline helps make libraries be header only. But if the functions are complex, then all of their dependencies are pulled into every TU that includes the header. \n\nAlso, changing the specializations will cause all of those TU's to be re-compiled. So there's merit for tucking the implementation away too at times. You'll need to judge on a case by case basis.\n\nhttps://stackoverflow.com/questions/63867758/c-inline-or-not-inline-declarations-of-template-class-specializations\n\n\n### 對 Template Specialiaztion 的實作宣告 inline \n\n這其實相當有趣，因為 function 是否 inline 取決於 compiler，即使宣告 inline 也不一定代表 compiler 會真的對 function inline  ([[了解 Inline 的裡裡外外]])。\n那麼為何在 hpp 內對  Template Specialiaztion definition 宣告 inline 能解決問題?  [Stackoverflow 的回答](https://stackoverflow.com/a/48403514) 給出了解答。\n\n根據  C++ standard 條目 3.2:4 ([file](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3690.pdf) P49 One definition rule)，可以拆成兩段來看: \n\u003e (1) Every program shall contain exactly one definition of every non-inline function or variable that is odr-used in that program; no diagnostic required. The definition can appear explicitly in the program, it can be found in the standard or a user-defined library, or (when appropriate) it is implicitly defined (see 12.1, 12.4 and 12.8). \n\u003e (2) An inline function shall be defined in every translation unit in which it is [[ODR use]].\n\n當 Specialiaztion 不是 inline 的時候，它被當作 non inline function 對待，而對於 non inline function/variable，在 program 中只應該擁有一份 definition。因此兩次 include 同一份 header 造成了問題: 多個 definition (include 的本質就是把 hpp 貼到 cpp 裡面)。\n\n當 Specialiaztion 是 inline 的時候，Specialiaztion 滿足了條目的第二部分: inline function 必須被定義於每一個使用到的 translation unit，也就是該則回答裡面提到的 : \n\n\u003e an inline function must be defined in each module using the function.\n\n這或許也可以反向說明，在 [[了解 Inline 的裡裡外外]] 環節中提到的，只有 hpp 中含有實作的 function 可以有隱性 inline 申請，因為想要 inline 一個 function，在編譯期間，每一個使用到這個 function 的 translate unit 都需要有這個 function。當實作抽離，這個條件就沒辦法達成。\n\n## Resources\n- [Examples for ORD](https://wiki.sei.cmu.edu/confluence/display/cplusplus/DCL60-CPP.+Obey+the+one-definition+rule)\n- ","lastmodified":"2024-02-23T05:15:51.43409902Z","tags":["cpp"]},"/notes/Focus/C++/Template-and-Generic-Programming":{"title":"Template and Generic Programming","content":"\n本文中要透過 [[Member Function Template]] (成員函式模板) 完成一個泛化的 copy constructor。\n\n---\n\n這段範例的意思是，對於 `SmartPtr\u003cT\u003e` 存在一個由 `SmartPtr\u003cU\u003e` 建構的管道 (透過 Copy Constructor)。\n這邊的型別轉換沒有標示為 `explicit`，一旦標示為 `explicit`，就需要明白寫出轉型 (cast) 動作。\n使用隱式轉換式因為 raw pointer 本來就支援隱式轉換，仿效相同模式，`SmartPtr` 也使用隱式轉換。\n\n```cpp\ntemplate\u003ctypename T\u003e\nclass SmartPtr {\npublic:\n\ttemplate\u003ctypename U\u003e // member template \n\tSmartPtr(const SmartPtr\u003cU\u003e\u0026 other); // for a ”generalized copy constructor”\n}\n```\n\n現在，不同的 `SmartPtr` 具現體 (instantiations, 具現化的類別) 之間可以自由轉換了，但像是 Top -\u003e Bottom 這種違反繼承規則的不合法的轉換，沒有被禁止! \n\n我們可以在 copy constructor 中加一些約束條件，避免這種不合法轉換。參考 share pointer 的作法，首先提供一個 `get` 的 public function 讓 raw pointer (`T*`) 得以被取得，這樣在 copy constructor 處理 rhs 的時候，才有辦法取得 `U*` pointer。\n接著，在 Member initialization list 當中，把 `U* ptr` 傳給內部的 `T* heldPtr`。若繼承關係不合法，則這個 Raw pointer 之間的 copy 行為就會發生問題，而無法通過編譯!!\n\n```cpp\ntemplate\u003ctypename T\u003e\nclass SmartPtr {\n\npublic:\n\ttemplate\u003ctypename U\u003e\n\tSmartPtr(const SmartPtr\u003cU\u003e\u0026 other) // initialize this held ptr\n\t: heldPtr(other.get()) { ... } // with other’s held ptr\n\tT* get() const { return heldPtr; }\n\nprivate: // built-in pointer held\n\tT *heldPtr; // by the SmartPtr\n};\n\n```","lastmodified":"2024-02-23T05:15:51.43409902Z","tags":["cpp"]},"/notes/Focus/C++/The-C++-STL-Outline":{"title":"The C++ STL Outline","content":"## Containers\n\n- 共同介面: Ch3 [[Interface of all containers]]\n- Ch4 [[Sequence Containers]]\n- Ch5 [[Associative Containers]]\n\n\n### Sequence Containers\n\n\n\n\n## Associative Continers\n\n- Unordered containers have better performance. \n\n","lastmodified":"2024-02-23T05:15:51.43409902Z","tags":["cpp","moc"]},"/notes/Focus/C++/The-definition-and-declaration-of-static-const":{"title":"The definition and declaration of static const","content":"\u003e [!todo]\n\u003e P14\n\n\n","lastmodified":"2024-02-23T05:15:51.43409902Z","tags":["empty"]},"/notes/Focus/C++/Translation-Unit":{"title":"Translation Unit","content":"\n\u003e A translation unit is the source code giving rise to a single object file. It's basically a single source file, plus all of its `#include` files.\n\n編譯單元指: 產出單一目的檔 (single object file) 的那些 source code，通常是 source code + included header file.","lastmodified":"2024-02-23T05:15:51.43409902Z","tags":["cpp"]},"/notes/Focus/C++/Translation-Unit-and-Linkage":{"title":"Translation Unit and Linkage","content":"https://learn.microsoft.com/en-us/cpp/cpp/program-and-linkage-cpp?view=msvc-170\n\n一個 program 是由一個或多個 translation unit 組成，一個 translation unit 則由一個 implementation file (cpp) 和它使用到的所有 header file (hpp) 所組成。\n\n每一個 translation unit 可以被獨立編譯，當所有的 translation unit 都編譯完成，linker 會把 translation units 融合成一個 Program。違反 [[One Definition Rule]] 會在這個階段爆出 linking error，其原因是有同名稱的 symbol 被定義了多次。\n\n\n通常，讓一個 variable 在多個檔案之間可見，就是宣告它於一個 header file，將會使用到這個變數的 cpp 都 include 該 header file。透過在 header file 添加 include guards，你可以確保這個 symbol 在一個 translation unit 當中只會被宣告一次。並且，只在一個 cpp 當中撰寫它的實作。\n\n[[Internal and External Linkage]]","lastmodified":"2024-02-23T05:15:51.43409902Z","tags":["cpp"]},"/notes/Focus/C++/Undeined-behavior-and-Implementation-defined-behavior":{"title":"Undeined behavior and Implementation defined behavior","content":"- Undefined behavior : 無法預期結果\n- [[Implementation-defined]] behavior: 取決於編譯器\n","lastmodified":"2024-02-23T05:15:51.43409902Z","tags":["cpp"]},"/notes/Focus/C++/Virtual-Base-Class":{"title":"Virtual Base Class","content":"\n\u003e 讓鑽石繼承中，帶有該資料的 Base Class 成為 virtual base class。\n\n此例中就是 `File` 要成為 virtual base class，`InputFile` \u0026 `OutputFile` 在繼承 `File` 時要加上 `virtual`。\n![[Item40_VBC.png]]\nC++ STL 裡面有一個這樣的體系，只是他們是 class template 上的繼承關係 (basic_ios, basic_istream, basic_ostream, basic_iostream)。\n\n## 代價\n\nPublic 繼承應該總是為 virtual public 嗎?  virtual 有代價\n- 存取 virtual base class member data 會比 non-virtual class member data 慢。\n- virtual base class 初始化規則複雜、不直觀的多。\n\n## virtual base class 的初始化\n由最底層 (most derived class ) 負責\n1. most derived class 需要認知到 virtual base class 在哪，它可能很遙遠\n2. 一但有新的 derived class 被加入，責任將拋到它身上。\n\n### 忠告\n1. 不輕易使用 virtual base class \n2. 如果必須使用，避免在裡面放資料，這樣就不需要擔心初始化與賦值帶來的問題了。\n","lastmodified":"2024-02-23T05:15:51.43409902Z","tags":["cpp"]},"/notes/Focus/C++/Virtual-Function":{"title":"Virtual Function","content":"\n## 在 Ctor / Dtor 呼叫 virtual function\n![[Itm10_TranscationUML.png]]\n\n在這裡，Transcation 的 Constructor 呼叫的會是 `Transcation::logTranscation`。\n又，該 function 為 Pure virtual function，若它沒被定義，則當編譯器呼叫時會引發錯誤，而若有.... 就會 Link 到該 base class function。\nRelated: [[區分介面繼承(interface)和實作繼承(implement)]]\n\n一個不正式的講法: Base Calss 建構期間，所呼叫的 virtual function 不是 virtual function。  \n\n\u003e [!important] \n\u003e 在 Drived Class Object 執行 Based Class Constructor 期間，物件的型別實際上是 Base Class。\n\n這是根本的原因，由於在 Based Class Constructor 物件是 Base Class，呼叫 Base Class 的 function 也是自然的事。\n不只是 virtual function 會被決議(resolve to) 至 Base Class，如果使用 `dynamic_cast` (Runtime type infomation)，也會把物件視為 Base Class! [[少做轉型動作(Minimize casting)]]\n\n相同的問題也存在於 Destructor，在 Destructor 中 Drived Class 的部分會先被消滅，一旦進入 Base Class Destructor ，C++ 就會看待它為一個 Base Class。\n\n## 以傳遞參數給 non-virtual function，取代使用 Virtual function\n將 virtual function 從 con/desturctor 中移除! 說來容易，卻不易察覺。Constructor 可能 call 別的 function，而 virtual 可能藏身在其中! 並且，很難確保 Child Class 也會服從這項規定。\n\n替代方案是，使用 non-virtual function，把 Log 以 string 的方式傳給 Base Class 的 non-virtual Log function。\n","lastmodified":"2024-02-23T05:15:51.43409902Z","tags":["cpp"]},"/notes/Focus/C++/enum-hack":{"title":"enum hack","content":"","lastmodified":"2024-02-23T05:15:51.43809902Z","tags":["empty"]},"/notes/Focus/C++/nm":{"title":"nm","content":"\n\n[man](https://linux.die.net/man/1/nm)\n[nm 的中文摘錄](https://pxnet2768.pixnet.net/blog/post/69177699)\n\n```\n00000000000012d8 t _GLOBAL__sub_I__ZN8test_cls2f3Ev\n00000000000012f2 W _ZN8test_cls2f1Ev\n00000000000011ca T _ZN8test_cls2f3Ev\n\n```\n大寫: Global Symbol，小寫: local symbol。\n\n\n`W`: The symbol is a weak symbol that has not been specifically tagged as a weak object symbol. When a weak defined symbol is linked with a normal defined symbol, the normal defined symbol is used with no error. When a weak undefined symbol is linked and the symbol is not defined, the value of the symbol is determined in a system-specific manner without error. On some systems, uppercase indicates that a default value has been specified.\n\n`T`\n","lastmodified":"2024-02-23T05:15:51.43809902Z","tags":["cpp"]},"/notes/Focus/C++/non-member-non-friend-function":{"title":"non-member \u0026\u0026 non-friend function","content":"[[Non-member \u0026\u0026 Non-friend Function 的封裝度優於 Member Function]]","lastmodified":"2024-02-23T05:15:51.43809902Z","tags":["cpp"]},"/notes/Focus/C++/operator-overloading":{"title":"operator overloading","content":"","lastmodified":"2024-02-23T05:15:51.43809902Z","tags":["empty"]},"/notes/Focus/C++/override":{"title":"override","content":"","lastmodified":"2024-02-23T05:15:51.43809902Z","tags":["empty","cpp11"]},"/notes/Focus/C++/pimpl-idiom-pointer-to-implementation":{"title":"pimpl idiom (pointer to implementation)","content":"\u003e 將物件的實作細目隱藏在一個指標背後\n\n## 第一種手法: Handle Class\n\n此手法會把一個類別分成兩個 Class: \n- 一個是暴露給客戶端的接口 Handle Class (ex. `Person`)，它只會擁有一個 pointer 指向實作 class\n- 一個是實作類別 Implementation Class (ex. `Personimpl`) ，所有真正要存的資料都在這裡面。\n\n由於接口 `Person` 只 own 一個 smart pointer ，它不需要知道 `PersonImpl` 有多大，因此可以用 forward declare 解決。它還提供了一些 getter，但提供 getter 也都可以透過 forward declare 解決一切。\n\n客戶端在 `include person.hpp` 時，只會跟著 include 到 string 和 memory 兩個 header file 而已。至此，`PersonImpl` 做了什麼更動，直接跟客戶端脫鉤。\n\n\n```cpp\n#include \u003cstring\u003e // standard library components shouldn’t be forward-declared\n#include \u003cmemory\u003e // for tr1::shared_ptr; see below\nclass PersonImpl; // forward decl of Person impl. class\nclass Date; // forward decls of classes used in\nclass Address; // Person interface\nclass Person {\npublic:\n\tPerson(const std::string\u0026 name, const Date\u0026 birthday,\n\tconst Address\u0026 addr);\n\tstd::string name() const;\n\tstd::string birthDate() const;\n\tstd::string address() const;\n\t...\nprivate: // ptr to implementation;\n\tstd::tr1::shared_ptr\u003cPersonImpl\u003e pImpl; // 這是唯一的 member data\n}; // std::tr1::shared_ptr\n```\n\n[[編譯依存-宣告式、定義式與實作細節]]\n\n### 實作檔案 (CPP)\n實作檔案需要同時 include `Person.hpp` 和 `PersonImpl.hpp`\n-  `Person.hpp` : 為了實作 `Person`的 function\n-  `PersonImpl.hpp`: 才能 Call `PersonImpl` 的 function。\n\n```cpp\n#include \"Person.h\" \n#include \"PersonImpl.h\" \nPerson::Person(const std::string\u0026 name, const Date\u0026 birthday,\nconst Address\u0026 addr)\n: pImpl(new PersonImpl(name, birthday, addr))\n{}\nstd::string Person::name() const\n{\nreturn pImpl-\u003ename();\n}\n```\n\n\n## 第二種手法: Interface Class 的設計方式\n暴露給客戶的是 Interface Class，這個類別本身會設計成一個 abstract base class (interface class)。[[區分介面繼承(interface)和實作繼承(implement)]]\n\n### Interface Class: 暴露給 Client 的接口\nInterface class 的用途是僅有敘述 drived class 的介面，它沒有 member data、也沒有 constructor，只有一個 virtual destructor，跟一堆 [[Pure Virtual Function]] 來敘述介面。而 drived class 就是它的實作 (相當於前面 implement class 的腳色)\n```cpp\nclass Person {\npublic:\n\tvirtual ~Person();\n\tvirtual std::string name() const = 0;\n\tvirtual std::string birthDate() const = 0;\n\tvirtual std::string address() const = 0;\n...\n};\n```\n\n我們暴露給 Client 端的是 Interface class，Interface calss 是 abstract class，然而， **abstract class 不能被具象化**。因此，用此方法設計時，需要在  interface class 裡面提供一個「讓 client 端獲取物件」的特殊方法。\n\n這個特殊方法通常稱為 [[工廠函式 (Factory Function)]]，它們會回傳一個 interface class pointer，卻指向動態配置(被 `new` 出來) 的 derived class 物件。這種函式在 interface class 內往往宣告為 `static`。如下例的 `create`: \n\n```cpp\nclass Person {\npublic:\n...\nstatic std::tr1::shared_ptr\u003cPerson\u003e \ncreate(const std::string\u0026 name, // Person initialized with the\n\t\tconst Date\u0026 birthday, // given params; see Item 18 for\n\t\tconst Address\u0026 addr); // why a tr1::shared_ptr is returned ...\n};\n```\n\n### Concrete Class: 相對於 Interface Class 的對應實作\nInterface Class 所對應的實作類別會是一個具象類 (concrete class)，它必須擁有真正的 constructor。假設這個實作類別是 `RealPerson`: \n\n```cpp\nclass RealPerson: public Person {\npublic:\n\tRealPerson(const std::string\u0026 name, const Date\u0026 birthday,\n\tconst Address\u0026 addr)\n\t: theName(name), theBirthDate(birthday), theAddress(addr)\n\t{}\n\tvirtual ~RealPerson() {}\n\tstd::string name() const; // implementations of these \n\tstd::string birthDate() const; // functions are not shown, but \n\tstd::string address() const; // they are easy to imagine\nprivate:\n\tstd::string theName;\n\tDate theBirthDate;\n\tAddress theAddress;\n};\n```\n\n現在知道 `RealPerson` 的 constructor 長相，回頭 `Person::create` 的實作也是輕而易舉: \n```cpp\nstd::tr1::shared_ptr\u003cPerson\u003e Person::create(const std::string\u0026 name,\nconst Date\u0026 birthday, const Address\u0026 addr)\n{\n\treturn std::tr1::shared_ptr\u003cPerson\u003e( \n\t\t\tnew RealPerson( name, birthday, addr));\n}\n```\n\n## pimpl 手法的成本\n以上說明了兩種花俏的手法，它能降低耦合，減少編譯時間。成本呢?\n\n### Handle Class 的成本\n1. 每次對 Handle class 取值都是間接取值: handle class 需要跟 impl pointer 取得資料。\n2. 與不用 pimpl pattern 手法想比 (不去耦合)，每增加一個 handle class 物件，就會增加一個 impl pointer 的大小 (通常以 smart pointer 存)。\n3. impl object 是以動態記憶體配置 (`new`)，承受動態記憶體配置與釋放的成本，也有可能遇到 `bad_alloc` (記憶體不足)。\n### Interface Class 的成本\n1. Interface Class 每個函式都是 virtual function，每次的函式呼叫都要付出間接跳躍 (indirect jump) 的成本。見: [[為多型用途的基礎類別宣告 virtual 解構式]]\n2. 只要有 virtual function，就會有 vptr (virtual table pointer)，其成本參見:  [[不要為非多型用途的 Base Class 宣告 Virtual Function]]\n\n### 提醒\n不論 handle class 或 interface class，一旦脫離 inline 函式都無法有太大的作為(why? 不過就是都要在 class 定義式中直接把實作寫完的意思)。因為這類 class 是為了隱藏實作細節或函式本體的!! [[了解 Inline 的裡裡外外#向 Compiler 發出申請]]\n\n\n## 該使用 pimpl 嗎?\n- 當以上提及的速度成本或大小問題，使得類別的耦合問題相形之下不怎麼嚴重時，就應該直接用具象類別 (concrete class) 取代 pimpl 手法。\n","lastmodified":"2024-02-23T05:15:51.43809902Z","tags":["cpp"]},"/notes/Focus/C++/shared_ptr":{"title":"shared_ptr","content":"[shared_ptr in cppreference](https://en.cppreference.com/w/cpp/memory/shared_ptr)\n\n\u003e Constructing a new `shared_ptr` using the raw underlying pointer owned by another `shared_ptr` leads to undefined behavior.\n\nshared pointer 是資源管理物件，它內部會儲存一個 couting，計算有幾個 shared_ptr 使用中。當一個 shared_ptr 消失，則 couting 減一，直到 couting 歸零則 release 這個物件的 memory。\n然而，維持這個記數的正常運作有一個前提: 所有的 shared_ptr 都是從第一個 shared_ptr COPY 而來。使用 raw pointer 去製造一個新的 pointer 無法保證這個機制正確。\n\n## 實際案例\n此例中，\n1. new 了一個 A 物件的 raw pointer \n2. 放進 sm_ptr1\n3. 取 A 物件的 reference \n4. 對此 reference 物件取 address\n如果使用 `std::cout` 印出 `sm_ptr1`, `raw_ptr`, 對 reference 取的 address 都會得到同一個結果。\n然而，如果把 (4) 取出的 address 拿去再建一個 shared_ptr (5) 出來，情況就不同了。\n\n現在有兩個 shared_ptr，但把 `use_count()` 印出來卻都是 1。在執行期間發生了更糟糕的事: `free(): double free detected in tcache 2`。\n\n這應該是因為同一個 memory 被 free 了兩次的意思。原因是，有兩個 shared pointer 沒有共享計數，在 main loop 走到最尾端的時候，一個 shared_ptr 被消滅、同時把 A 物件的 memory 也清掉了，第二個 shared_ptr 被消滅時，也試圖做相同的事情，故而引發此問題。\n\n\n```cpp\nclass A { ... }\nint main()\n{\n    A* raw_ptr = new A(); // (1)\n    auto sm_ptr1 = std::shared_ptr\u003cA\u003e(raw_ptr); // (2)\n    std::cout\u003c\u003c\"Raw ptr  \"\u003c\u003c raw_ptr \u003c\u003c std::endl;\n    std::cout\u003c\u003c\"Smartptr1 \"\u003c\u003c sm_ptr1 \u003c\u003c \" \" \u003c\u003c sm_ptr1.use_count() \u003c\u003c std::endl;\n    A\u0026 ref = *sm_ptr1; // (3)\n    std::cout\u003c\u003c\"\u0026(*sm_ptr1)  \"\u003c\u003c \u0026ref \u003c\u003c std::endl; // (4)\n    \n    auto sm_ptr2 = std::shared_ptr\u003cA\u003e(\u0026ref); // (5)\n    std::cout\u003c\u003c\"Smartptr2 \"\u003c\u003c sm_ptr2 \u003c\u003c \" \" \u003c\u003c sm_ptr2.use_count() \u003c\u003c std::endl;\n    std::cout\u003c\u003c\"Smartptr1 \"\u003c\u003c sm_ptr1 \u003c\u003c \" \" \u003c\u003c sm_ptr1.use_count() \u003c\u003c std::endl;\n\n    std::cout\u003c\u003c\"end\"\u003c\u003cstd::endl;\n}\n```\nOutput\n```\nRaw ptr  0x55be93224eb0\nSmartptr1 0x55be93224eb0 1\n\u0026(*sm_ptr1)  0x55be93224eb0\nSmartptr2 0x55be93224eb0 1\nSmartptr1 0x55be93224eb0 1\nend\nfree(): double free detected in tcache 2\nAborted\n```\n\n\n## enable_shared_from_this\nC++11 在導入 smart pointer 的同時，也還提供了 [enable_shared_from_this](https://en.cppreference.com/w/cpp/memory/enable_shared_from_this) 這個工具。\n然而，這個工具不能解決上面被 free 兩次的問題。\n\n想要透過 `enable_shared_from_this` 取得技術正確的 shared_ptr，你必須\n1. 拿到第一個 shared_ptr \n2. 透過對第一個 shared_ptr 呼叫 [smartPtr-\u003eshared_from_this](https://en.cppreference.com/w/cpp/memory/enable_shared_from_this/shared_from_this \"cpp/memory/enable shared from this/shared from this\")的方式取得第二個 shared_ptr\n如果都能夠拿到第一個 shared_ptr 的話，又何必多此一舉? 直接 Copy 就好了!\n\n[這篇文章](https://kheresy.wordpress.com/2018/08/08/enable_shared_from_this/)提供了一個觀點: \n1. `enable_shared_from_this` 是為了讓 class 內部可以取得自身物件的 shared_ptr。\n2. 給 call back 架構使用\n\n第一點的部分，在沒有這個工具時，假如試圖在 class 裡面寫這種函式提供 shared_ptr，事實上每一個呼叫函式的人拿到的都是不同的資源管理器，指向同一個物件，就會產生 free 多次的問題。至於第二點，參見[文章範例](https://kheresy.wordpress.com/2018/08/08/enable_shared_from_this/)。\n\n```cpp\n// wrong method\nA::get_shared_ptr()\n{\n\treturn std::shared_ptr\u003cA\u003e(this);\n}\n```\n\n\n","lastmodified":"2024-02-23T05:15:51.43809902Z","tags":["cpp"]},"/notes/Focus/C++/typedef-and-using":{"title":"typedef and using","content":"","lastmodified":"2024-02-23T05:15:51.43809902Z","tags":["empty","modern"]},"/notes/Focus/MOCs/C++-Resources":{"title":"C++ Resources","content":"\n## Notes\n- [[../C++/C++ Core Guidelines|C++ Core Guidelines]]\n- [[../C++/The C++ STL Outline|The C++ STL Outline]]\n- [[../C++/Effective C++ Outline|Effective C++ Outline]]\n\n## Webs\n- [CppCoreGuidelines](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines)\n- [CppDeveloperRoadmap](https://github.com/salmer/CppDeveloperRoadmap)\n- [整理了一份C++学习路线图](- https://mp.weixin.qq.com/s/poq9aDdEL5kLM5sjSqJ72A)\n- \n\n## STL  \n1. C++標準庫：學習教本與參考工具（第二版） 作者： Nicolai M. Josuttis 譯者： 侯捷\n\t- 內容涵蓋 C++11 的 STL .\n\t- https://www.books.com.tw/products/0010658042?sloc=main\n2. The C++ Standard Library  (Rainer Grimm)\n\t1. 擔心  C++17 以上的 STL 有難度，還是從侯捷的讀起比較好\n\t2. https://leanpub.com/cpplibrary\n\t3. https://leanpub.com/cpplibrary\n3. [侯捷 STL Youtube](https://www.youtube.com/watch?v=jHfbmCmsmFc\u0026list=PLTcwR9j5y6W2Bf4S-qi0HBQlHXQVFoJrP\u0026index=3)\n4. \n## How to Learn Modern C++\n[近年常被問到如何學習 C++](https://blog.tinlans.org/2022/04/17/%E8%BF%91%E5%B9%B4%E5%B8%B8%E8%A2%AB%E5%95%8F%E5%88%B0%E5%A6%82%E4%BD%95%E5%AD%B8%E7%BF%92-c/)\n\n[C++ Core Guidelines](https://github.com/isocpp/CppCoreGuidelines) 其實對於從未閱讀過 Effective 系列書籍的現代新入門者而言還是很重要的，如果可能的話，我會推薦先讀過 Effective 系列的書再去看它。但 Effective 系列的書有不少內容已經過時，一個折衷的方法就是從摘要 C++ Core Guidelines 的書來當作切入點。這邊可以推薦兩本：  \n[Beautiful C++: 30 Core Guidelines for Writing Clean, Safe, and Fast Code](https://www.tenlong.com.tw/products/9780137647842) ([電子版](https://www.informit.com/store/beautiful-c-plus-plus-30-core-guidelines-for-writing-9780137647842))  \n[C++ Core Guidelines Explained: Best Practices for Modern C++](https://www.tenlong.com.tw/products/9780136875673) ([電子版](https://www.informit.com/store/c-plus-plus-core-guidelines-explained-best-practices-9780136875673))\n\n\n\n\n\n## Online Resource\n- [IT 碼農](https://tanqingbo.cn/CSBook001/#C)\n- [碼農之家](https://www.xz577.com/)\n- [搬書匠](http://www.banshujiang.cn/)\n","lastmodified":"2024-02-23T05:15:51.43809902Z","tags":["cpp","moc"]},"/notes/Longtern/%E5%AE%A4%E5%85%A7%E6%94%B6%E7%B4%8D":{"title":"室內收納","content":"## 大創 A4 檔案架\n- 適合收納圓形碗盤、鍋蓋\nhttps://shop.daiso.com.tw/products/4984355713968\n![[daiso_book_box.png]]\n\n## 大創網架\n\n![](https://www.youtube.com/watch?v=yno05S_lKWs)\n","lastmodified":"2024-02-23T05:15:51.446099022Z","tags":[]},"/notes/Longtern/Books/%E4%B8%96%E7%95%8C%E7%AC%AC%E4%B8%80%E7%9A%84R90%E9%AB%98%E6%95%88%E7%9D%A1%E7%9C%A0%E6%B3%95":{"title":"世界第一的R90高效睡眠法","content":"[世界第一的R90高效睡眠法:C羅、貝克漢的睡眠教練教你如何睡得少，也能表現得好](https://tphcc.ebook.hyread.com.tw/bookDetail.jsp?id=357480)\n\n\n\n![[Pasted image 20240119131524.png]]\n\n## 咖啡因\n\n英國食品標準: 每日攝取咖啡因含量 400mg: \n- 星巴克每日精選: 330g、濃縮咖啡: 75g、\n咖啡因半衰期 6hr\n\n\n## 陽光\n- Lumie , 飛利浦，晨光喚醒燈\n## Step \n1. 選定一個應該起床的最早時間! \n\t1. 隔週有 8:30 的 meeting，則應該選擇 8:00 起床，並且確保中間這一個小時滿足通勤、梳洗等一切準備工作。\n2. 從必需起床時間往前回推，90分鐘一個週期總共要睡幾個週期。\n3. 用週期計算睡眠時間: 一周要睡滿 7\\*5 = 35 個週期，而非每天要睡滿 5 個週期\n\n7:30 起床，套用 5個週期: 12:00 要睡覺，11:45 就要鑽進被窩。\n如果錯過了 12:00 睡覺的時間，則下一個周期是 1:30，你可以考慮 1:00 準備上床。\n\n## 飲食\n色胺酸是製造退黑激素的原料，雞肉、起司、牛奶、堅果、香蕉等，有豐富蛋白質的食物可以找到\n\n3. ","lastmodified":"2024-02-23T05:15:51.442099021Z","tags":[]},"/notes/Longtern/Books/%E5%B0%8F%E5%BF%83%E6%95%88%E7%8E%87%E9%99%B7%E9%98%B1":{"title":"小心效率陷阱","content":"https://www.youtube.com/watch?v=5kNCcpM61eo\n\n## 「輸出」決定輸入\n利用費曼的「12道難題」決定想要的「輸出」有哪些，在日常中發現有價值的輸入時，比對這 12 項輸入，放入對應的類別。\n\n\n## PARA 的缺陷\n類別界線過於模糊，使人困惑。作者不斷強調以 \"Project\" 為導向，事實上 PARA 的後三項過於雷同。\n\n與其經過層層架構找到資料該有的位置，倒不如直接分類\n1. 短期項目 (Project)\n2. 長期項目\n\n## 傳播者的 Bias \n\n打造第二大腦、卡片和筆記法，特別適合創作者。影片、文章、編舞者....，這不一定適合所有人。","lastmodified":"2024-02-23T05:15:51.442099021Z","tags":[]},"/notes/Longtern/Books/%E6%9B%B8%E5%96%AE":{"title":"書單","content":"\n## 紐約時報\n- [《紐約時報》2023年度十大好書](https://cn.nytimes.com/books/20231201/best-books-2023/zh-hant/)\n\n## 選擇書單\n\n### 思維鍛鍊\n\n- [提案高手不靠靈感的12個思考拆解術:迪士尼、豐田、時尚大師與樂高都在用!輕鬆存取好點子, 老闆、客戶都買單](https://tphcc.ebook.hyread.com.tw/bookDetail.jsp?id=352698)\n- [逆向思考](https://tphcc.ebook.hyread.com.tw/bookDetail.jsp?id=343575)\n- [本質思考習慣:逃脫陷阱，從根本解決問題的九大鍛鍊](https://tphcc.ebook.hyread.com.tw/bookDetail.jsp?id=342587)\n- [判斷的基本:明確丶適時丶精準丶長遠，高績效工作的70個原則](https://tphcc.ebook.hyread.com.tw/bookDetail.jsp?id=342586)\n- \n### 養生\n[世界第一的R90高效睡眠法:C羅、貝克漢的睡眠教練教你如何睡得少，也能表現得好](https://tphcc.ebook.hyread.com.tw/bookDetail.jsp?id=357480)\n[[世界第一的R90高效睡眠法]]\n[經絡拍打基本法:怎麼拍？拍哪裡？為什麼？](https://tphcc.ebook.hyread.com.tw/bookDetail.jsp?id=343339)\n\n\n### 人生\n- [七個問題看見你的天賦(說書)[有聲書]:在人生下半場, 展開自己人生的模樣](https://tphcc.ebook.hyread.com.tw/bookDetail.jsp?id=351365)\n\n\n\n\n\n\n","lastmodified":"2024-02-23T05:15:51.442099021Z","tags":[]},"/notes/Longtern/Books/%E7%95%AA%E8%8C%84%E9%90%98":{"title":"番茄鐘","content":"\n\u003e 番茄鐘的重點不是浪費了多少時間，是達成多少個番茄! 不要亡羊補牢，不要加班減輕罪惡感。\n## 番茄鐘工作法的目標\n1. 減少時間流逝的焦慮\n2. 削減干擾以提升專注程度\n3. 改進工作坊是\n4. 增加 \"質\" 和 \"量\" 的評估能力\n\n\u003e 番茄工作法的靈感來自 \"時間箱 (time boxing)\"，用番茄鐘來「量化」精力 (注意力)，\n\n番茄鐘的規則\n1. 不可打斷、不可分割。\n2. 每25分鐘休息5分鐘\n3. 每4個番茄鐘休息 15 分鐘\n\n## 番茄工作法步驟\n\n 一日之初計畫\"今日工作表\"，整天持續追蹤，一日之末 \"盤點工作\"。 這個週期可以是一日，也可以是半日，以更靈活的調整安排。\n\n1. 今日工作表: 只放今天要完成的任務\n2. 盤點工作表: 所有待辦項目，他們需要一個清點表。\n\n### 今日工作表\n範例見最後面\n#### 一天之始: 決定今日事項\n1. 今日要完成的事項、優先序，\n2. 保留緊急欄位，填寫突然想到的事件，如果急迫則可以調整。\n#### 內部干擾 (自己的)\n如果是一通緊急電話，硬生生打斷番茄鐘，則應該加上註記 `\"`。最後面的表格是書中的範例，\"X\" 表示被執行完成的番茄鐘，逗號則表示被干擾、中斷的次數。\n不管是被干擾還是直接中斷，都做同一個記號。被干擾依然可以繼續把番茄鐘完成，就可以畫上 \"X\"。中斷則要重新開始計時，符號上沒有差異。\n\n#### 外部干擾 (來自組織的)\n有時候急迫的事項來自同事，和內部干擾相似，當外部干擾來的時候改用 `-` 註記。\n1. 今天必須完成的: 一發生就先放到\"緊急欄位\"，並在前面標上幾點前完成它。\n2. 不必今天完成，但有重要性: 在\"事項盤點表\" 標註 `U` 與截止日期。\n\n#### 緊急欄位\n不一定真正是「急事」，或許放個 10~20分鐘，在心裡的優先序就不同了。他們有不同的處理方式\n1. 挪到一天結束的盤點時間\n2. 挪到長休息時間，例如上網查演唱會資料\n3. 非常緊急，則直接插入下一個番茄鐘來處理。\n\n### 盤點工作表\n一日之末，檢討\n1. 預估能力，清點那些「出乎意料」的存在: \n\t1. 事項盤點表上 \"U\" 的事項\n\t2. 今日工作表上的 \"臨時急迫事項\"\n2. 分心次數\n\n### 預估事項需要的精力\n\n#### 盤點工作表\n1. 在事項盤點表可以為各項目預估，需要幾個番茄。\n2. 如果一個事項要超過 5~7 個番茄，則考慮拆分。\n3. 不滿一個番茄，則先放著，等安排今日工作時再湊湊看。\n\t1. 同性質的湊一個番茄，例如: 寄信、打電話...\n\n#### 今日工作表\n1. 先列出今天可用的番茄\n2. 今日工作表上的工作內容，不應該超過今日可用的負荷量。\n3. 從盤點工作表，按照重要程度把事項拉出來填入\n4. 在今日工作表上，標示預估的番茄數量。並如實紀錄實際花費番茄\n\n#### 檢討預估能力\n1. 紀錄今日工作表的預估與實際花費\n\t1. 事項應該盡量具體、量化? \n\t2. \n\n### 時間表\n1. 把吃飯休息時間、會議時間放上去。\n2. 根據剩下的空格時間，決定今日有幾個番茄。\n3. 尊重自己的時間表，該休息就休息。\n4. 盡可能以 4個番茄為單位 (一個循環)，劃分出時間段。\n\n### 其他\n- 紙筆筆 3C 更好用!\n- https://www.playpcesor.com/2022/11/windows.html\n\n### How to\n1. 時間表: 用 elina 的周計畫\n2. 番茄鐘表格: 自己用 word 拉? \n\n![[Pasted image 20240115234811.png]]","lastmodified":"2024-02-23T05:15:51.442099021Z","tags":[]},"/notes/Longtern/Books/%E9%9B%BB%E5%AD%90%E6%9B%B8%E5%B9%B3%E5%8F%B0":{"title":"電子書平台","content":"[HyRead 新北市](https://tphcc.ebook.hyread.com.tw/index.jsp)\n\n\n","lastmodified":"2024-02-23T05:15:51.442099021Z","tags":[]},"/notes/Longtern/Books/Everyday-business-storytelling":{"title":"Everyday business storytelling","content":"\n\u003e 今日的我們過分規範 (overcodifiying) 這個世界，試圖捕捉與系統化一切事務(大數據!)，這是一種強左腦、強調邏輯的誘惑。麥克爾吉里斯特主張，執著於嚴格計算每一件事，將阻擋想像力帶來的重大突破。\n\n\u003e 如今我們在溝通的時候，過度強調數字、統計、分析。\n\n數據帶來**洞見**! 數據能支撐故事嗎? 數據能推動敘事嗎? 數據是否編排得當? (請反覆推敲，使得洞見變得顯眼)\n\n## 好的故事\n故事必須引人入勝，才讓人願意看下去。\n\n跳過建立脈絡的環節，相當於忘記告訴所有人，你提出的 Solution 為何重要。講快一點，不是劈頭就講結局! \n\n前三個路標怎麼融合、順序怎麼出場都行，但結局必須在最後。\n\n\n\n### 四大路標\n\n#### 背景 = 關注點\n拋出主要內容前，先建立背景 (脈絡)，把鎂光燈打在「你想解決的議題」上。\n\n#### 人物\n\n人物 = 受到影響的人，商業故事來說通常是消費者、利害關係人、員工、夥伴 ... \n1. 有姓名的人物: 虛構一個人，幫他取名。\n2. 沒有姓名的人物: 最常見的作法，最安心。\n3. 你自己: 通常在演講。\n\n#### 衝突: 舊故事\n\u003e 先描述目前的狀況 (舊故事)\n\n- 發生了某些問題，它阻擋了機會跟可能性。衝突該指出當下 (發生中) 不和諧、不足之處。\n\n#### 結局: 新故事 \n\u003e 再解釋機會與更好的未來 (新故事)\n\n面對衝突的解決方式: 收攏到你想提出的 Solution。\n\n\n## Why What How \n- Why: 背景、人物、衝突 : 給觀眾「為何要關心結局」的理由。\n- What: 大創意: 打開一絲曙光，讓觀眾感覺到「衝突的不安感將要被解決」，它是一座心理橋梁，協助觀眾走過衝突、走向結局。\n- How: 結局: Solution，如何解決衝突。\n\n### 大創意\n簡單、對話式的陳述，沒有術語，總結故事但不提細節，**只**說一言以蔽之的**好處**。\n\n- 我們必須投資更多方案，想辦法**留住高階人才**。-\u003e在結局才仔細說 \"如何做 (how)\"\n- 新的薪資結構協助我們找回利潤。\n- 你需要安全的儲存空間，保護每位員工的業務資料\n- 為了擴張全球業務，我們必須留意跨境購物者。\n\n\n## 如何做簡報: 透過格式與排版集中觀眾的注意力\n### 生動的標題\n標題的作用在於\n1. 引導觀眾的關注點\n2. 協助你控制敘事 (觀眾中途加入、演講被中途干擾，也能迅速抓回當前位置)\n3. 確保故事不斷前進\n\n就像新聞報導，標題需闡述洞見、放在最上方。\n\n對於有好的標題的投影片，就像接力棒一棒棒 (一頁頁) 傳下去，引導到結局，\n標題間的**連結性**非常重要。\n\n\u003e 生動的標題像是 GPS 路線圖，串起標題後有如拿到故事的大綱。請檢視\n\u003e 「標題是否明顯推動故事前進?」\n\n### 好的標題指南\n1. 簡潔\n2. 明確\n3. 有如在對話，沒有術語\n\n- 營收: 推出雲端~~服務~~後，營收在過三年飆升\n- 近況更新: X 專案準備在第四季上線\n- 時間線: 預備分三階段推出\n\n不要放虛字! 提供有價值的內容。\n\n\n\n\n\n## 心得\n\n一整個套路看下來，我最先想到的是 **廣告**。這個年頭的廣告總以 「你是否覺得」為開頭，敘述你的困擾 (why) 。接著丟出它的產品 (what)，告訴你產品如何解決問題 (how)。\n直接以本書的中文廣告為例: \n\n(Why: 故事背景)\n你是否常遇到……  \n- 老闆、同事、客戶……都聽不懂人話，不是不耐煩就是沒反應？  \n- 老闆突然要你講重點，只要報告3張簡報就好……怎麼辦？  \n- 寫e-mail交辦工作，但是對方不是沒回信就是要你三催四請才會動一下？  \n\n(What: 大創意，概要說明解決方案有什麼、達到什麼目標)\n故事╳數據╳視覺輔助  \n讓點子穿越雜音、大腦不抗拒，打動受眾，讓他們認同你  \n  \n套用萬用說故事架構：背景、人物、衝突、結局，  \n銷售點子、影響決策、工作達標，任何溝通都適用！  \n\n(How: 理論上該說解決方案，但說太清楚就不用看書了，所以敘述方式有些相似於偏向**故事 (why)**，但最後依然點題結局: \"職場贏家\" )\n\n\n\\#終止混亂的訊息 \\#終止亂塞的數據  \n你只有一次機會在接下來的大會議、簡報或電子郵件，讓你的點子被聽見。  \n可是你很忙，所以你趕緊拿一些現成的東西應急，借同事的圖表、抓一些文字來充版面，東拼西湊出一份投影片。  \n  \n這種充滿混亂的訊息，密密麻麻難以閱讀，也沒明確呼籲大家行動的投影片，本書作者稱為「科學怪人簡報」。這類簡報會害你錯過機會，讓你無法在職場脫穎而出。  \n  \n因此，有時你在簡報或報告時會納悶，為什麼對方都聽不懂人話，不是不耐煩，就是沒反應；寄郵件跟催工作時，也愛回不回？  \n  \n你的困擾，和《財星》500大企業的員工一樣。他們也跟你一樣很忙，也會拿「科學怪人簡報」來應急。  \n  \n現在，讓服務過臉書、雀巢、惠普、埃森哲、麥當勞、蘋果、樂高、萬豪、T-Mobile、美敦力等全球頂尖品牌的團隊的這對從矽谷起步的姐妹淘，珍妮．柯諾夫與李．拉佐魯斯來幫助你。  \n  \n就算工作忙，你也可以透過作者獨到的萬用說故事架構助你一臂之力，讓你可以和老闆、客戶、同事好好溝通，順利通過提案、銷售點子，建言聽得進去，每一天你都可以發揮職場影響力，穩坐職場贏家！\n\n\n\n\n\n\n\n\n","lastmodified":"2024-02-23T05:15:51.43809902Z","tags":["cpp"]},"/notes/Longtern/Books/The-Second-Brain":{"title":"打造第二大腦","content":"\u003e 成為一個「能傳達資訊、且具有出色詮釋能力」的人! \n\n- Key Feature In this sentence:\n\t- Can construct infomation\n\t- Can express info effectively\n\n## 小心效率陷阱\n讀完此書後，我嘗試將 CODE 與 PARA 實踐在個人資料庫上，卻發現十分的困難，特別是 PARA。我無法將各類別的界線劃分清楚，層層架構只給我帶來麻煩。\n\n在 [YT 影片:小心效率陷阱](https://www.youtube.com/watch?v=5kNCcpM61eo)中，我找到了共鳴。\n\n\nCODE，特別是多階段的萃取，本就是在過去的筆記系統中會做的事。PARA 並沒有為我帶來太大的效益。\n要說有什麼啟發，就是 \"Project 導向\" 而非 \"類別導向\"，再更進一步地說，影片作者提到的「只要將類別分成長期、短期兩種」，正是我從「打造第二大腦」中學習到並可接受的新想法 。\n\n我將影片中獲得的 Idea 放在: [[小心效率陷阱]] \n\n\n## CODE : 萃取知識的順序\n\n### C (Capture)\n\u003e 將資訊蒐集在沒有雜訊的地方，你可以心無旁騖地找到它。\n\n- 即使只是看一眼收藏，也要慎選收藏的地方。\n- 不好的地方: 個人信箱、FB 的收藏 (很容易被社群吸走) ...\n- 適合的地方: 屬於自己的聊天室 (Line keep)\n\n### O (Orgnize)\n\u003e 以 Project 分類 ，不要以類別分類。\n\n- 淺台詞: 以目的導向分類。ex. 「專注力協議」的書摘應該放在「成為心無旁鶩的人」而不是「心理學」。\n- 像是歸類在「心理學」、或是「工作生產力」這種圖書館式的分類，不看標題也知道它是哪一類，不需要做無意義的分類。\n\n### D (Distill, 萃取)\n\u003e 用 Bullet Point 告訴未來的你，這篇筆記在說什麼?\n\n- 4 個層次的萃取，每一次萃取約保留 10~20% 的訊息量。\n- 萃取的時機很重要，無效的萃取反而遺失重要訊息。\n- How to partice? Distill the note when read it once time.\n\n### E (Express, 表達)\n\u003e Any way. Deliver it, and share! \n\n寫文章、影片... 總之分享它!\n\n## 輸出決定輸入! 你想解決什麼問題?\n\u003e Which problems do you want to resovle by The Second Brain? \n\n**費曼: 12道難題**\n它應該具有轉移性，核心精神不變，但領域可能改變的特質。記得這些你的目標，當資訊流過你身邊時，驗證他們是否能幫助你解決這些難題? If true, Capture it! \n\n\n---\n\n## Capture: What Info Can put into Your Second Brain?\n\n- 摘要! 通常不應超過原資訊量的 1/10\n- 具有啟發性的，改變你的想法的 (不懂 太抽象)\n- 在未來可以被使用的 (ex. How to own a project? How to leader a team?)\n- 跟你自身相關的: 珍貴的，你想永久記憶的回憶。\n- 相反、不同觀點的: 避免佐證偏差 (confirmation bias)，可以使你跳脫當前認知的。\n\n\u003e 記住，重新消化過的資訊更好吸收! \n\n## Organize: Where Do the Info Put?\n\n不使用圖書館式的分類法，作者提出 PARA 方法，可以看出重要程度依序遞減。人的注意力有限，請第一眼，就看到最可能幫助你的資料。\n\n\u003e 讓最重要的任務、最短期的目標的相關資料上，沒有過多的雜訊\n\nP (Project): 短期任務\n- Working project\n- Personal project (ex. blog), side project, 減重... \n- \n\n\u003e 事實上剩下三個類別過於雷同\n\n\nA (Area): 長期任務，長期想掌握的目標\n- 健康，不同於 project 中的「減重」是明確目標、是達成健康的手段，健康是長期目標。\n\nR (Resource): 未來有用處的\n- 隨處瀏覽下覺得有用的東西\n\t- 剛好看到有人推薦 C++ 書推薦\n- 有興趣的東西、嗜好: 精油、咖啡\n- 有用的參考: travel plan\n\nA (Archive): 備而不用\n- 不再有興趣的\n- 已經完成的旅行、專案素材\n\n\n\n## Distill 萃取\n\n- 不要花相同的時間，處理相同的原始資料\n- 摘要! 用簡短的 bullet point 列出重點。\n- 誤區: 當不能了解其用處時，不應強行消化，否則重點非重點。\n\n\u003e My opinion: 每調閱它、閱讀一次，就萃取一次。\n\n### 參考方法: 4 個層次萃取\n\n每個步驟間應保留約 10~20% 的資料量，否則 brief isn't brief.\n1. 擷取段落\n2. 粗體字\n3. 螢光筆 highlight\n4.  bullet point \n\n### 以會議筆記舉例\n\n1. 列出所有討論出來，需要做的 (need to do)\n2. 劃出重點項目、關鍵字\n3. 簡短列出: 如何執行 (execute)\n\n## Express 表達\n\n### 哲學思辨: 如何騰出專注力，卻不消耗專注力?\n\u003e 使用中間產物\n\nProject 自起點到終點(成品)，有許多中間產物，例如: 草稿、大綱、顧客回覆。收集這些資料，放進第二大腦，達到重複使用! \n\n### 中間產物\n1. Note\n2. 不使用的 Proposal \n\t1. 以及檢討，為何不使用。可能是有重大缺陷，需要避免以後踩到。\n3. 半成品??? \n4. 團隊的文件，這相當於他人的經驗\n\n\n### 切分「一件事」\n一件事有很多碎片，如果你是從零開始，可以把完成這件事需要那些碎片寫下來，並把你花費專注力 build 好的碎片存起來，讓這些碎片可以 Re-use。\n\n同時，你在從零建構碎片時，也可以吸取別人的經驗，Reuse 別人的碎片! \n\n\n\n\n## Resource\n- Author's website: https://www.buildingasecondbrain.com/resources\n- Obsidian As a Second Brain: https://www.youtube.com/watch?v=nz99I7apNLI\u0026list=WL\u0026index=2\n- Should Logseq be Your Second Brain? https://www.youtube.com/watch?v=VJ2reQcpbYA\u0026list=WL\u0026index=3\n- Pick a Notes App: Your Notetaking Style (Part 1) https://www.youtube.com/watch?v=f3dDVtJ2sec\u0026list=WL\u0026index=4\n","lastmodified":"2024-02-23T05:15:51.442099021Z","tags":[]},"/notes/Longtern/Cooking/%E5%84%AA%E5%85%88%E5%98%97%E8%A9%A6%E6%96%99%E7%90%86":{"title":"優先嘗試料理","content":"\n## 涼拌木耳豆皮\n\n## 藜麥毛豆便當\n可做冷凍包! 壓力鍋一鍋到底\n\n藜麥 約300公克  \n毛豆仁 約100公克  \n紅甜椒 黃甜椒 各半條。  \n雞蛋 2顆  \n雞高湯 約500c.c.  \n橄欖油 適量  \n砂糖 約1湯匙  \n黑胡椒 適量\nhttps://www.menustudy.com/blogs/daily-menu/104082\n\n\n- 加玉米筍、玉米粒的也有\n","lastmodified":"2024-02-23T05:15:51.442099021Z","tags":["food"]},"/notes/Longtern/Cooking/%E5%A3%93%E5%8A%9B%E9%8D%8B%E7%85%AE%E5%84%AA%E6%A0%BC":{"title":"壓力鍋煮優格","content":"\n1，先將裝優格容器用熱水煮過，擦乾這個步驟很重要喔！\n\t- 食材    AB優酪乳跟六甲莊鮮奶\n\t- 可用你喜歡的鮮奶，我也看過有人用豆漿\n2，優酪乳1:3鮮奶\n3，倒入容器裡攪拌均勻\n4，放入萬用鍋，按保溫狀態6~9小時\n所以我都是睡前做，早上起床都有溫溫的優格可以吃 \n這邊要提醒一下，天氣也會影響做優格的時間，冬天時間會比較長一點，我不知道每個人萬用鍋型號會不會有差異，做優格的溫度40-60度，你們可以去試看看，我這次嚐試在萬用鍋裡放點水跟蒸架，有留點細縫，沒有完全蓋上，（發現有縮短做優格的時間）如果全蓋上溫度好像比較高，如果要更精準一點可以用溫度計量一下\n\n5，剛做好的優格是溫溫的很像豆花，放涼我才進冰箱冷藏，定型過的優格\n\n優格上層會有一層水是正常的，那是乳清蛋白，不要到掉，我會加點水果跟優格或是巧克力粉……之類的打一打淋在沙拉，布丁，優格上面。優格我沒有加糖，盡量在3天內吃完\n\n---\nhttps://www.menustudy.com/blogs/daily-menu/107840\n菜單研究室\n\n---\n[金小萬做優格](https://cookpad.com/tw/%E9%A3%9F%E8%AD%9C/16867090-%E8%90%AC%E7%94%A8%E9%8D%8B%E9%A3%9F%E8%AD%9C%E4%B8%8D%E9%9C%80%E8%8F%8C%E7%B2%89%E5%85%A9%E6%AD%A5%E9%A9%9F0%E5%A4%B1%E6%95%97%E8%90%AC%E7%94%A8%E9%8D%8B%E8%87%AA%E8%A3%BD%E5%84%AA%E6%A0%BC-%E9%A3%9B%E5%88%A9%E6%B5%A6%E9%87%91%E5%B0%8F%E8%90%AC)\n1. 小優酪乳 200 ml\n2. 全脂鮮奶 400 ml\n3. 玻璃保鮮盒（加熱殺菌）\n攪拌均勻，鎖上機器，保溫 7 小時 (墊高)","lastmodified":"2024-02-23T05:15:51.442099021Z","tags":[]},"/notes/Longtern/Cooking/%E5%A4%A7%E9%A4%90%E6%96%99%E7%90%86":{"title":"大餐料理","content":"## BBQ 汁手撕豬肉\nhttps://www.christinesrecipes.com/2016/07/bbq-pulled-pork.html\n\n[自家煮的 BBQ 汁](http://www.christinesrecipes.com/2016/07/barbecue-sauce.html)，非常好用。用這個汁煮 BBQ手撕豬肉，味道很讚。如果有壓力煲，就非常方便，45分鐘搞定。或用慢煮煲高火 6小時。煮好的豬肉撕開時，透出清香，非常惹味。一次煮多一些，以備不時之需。把煮好的手撕豬肉和汁，分開用盒子放在冷凍室（freezer）中，可存放3個多星期。隨時需要，就拿出適當分量加熱。早餐，午餐或下午茶作三文治，非常方便呢。  \n\n### 食譜\n**預備時間**: 10 分鐘  \n**烹調時間**: 50 分鐘  \n**分量**: 6 至 8人\n\n- 豬肩肉 (pork shoulder 梅花肉) 1公斤\n- 鹽 ½ 茶匙\n- 蒜粉（garlic powder） 1茶匙\n- 小茴香粉（cumin powder）1 茶匙\n- 芫荽粉（coriander powder） ½ 茶匙\n- BBQ 汁（[材料和做法參考此食譜](http://www.christinesrecipes.com/2016/07/barbecue-sauce.html)） 1杯\n- 雞湯 1杯\n\n**做法**:  \n1. 豬肉洗淨，抹乾水分。從中央切開兩半，務求大小適合放置在鍋中。\n2. 把鹽，蒜粉，小茴香粉和芫荽粉，拌勻。置大盤中，放入豬肉滾轉，讓香料混合物平均黏在豬肉的表面。\n3. 豬肉放入鍋中，用大火煎香兩面 ，帶出香料的香氣。倒進 BBQ 汁和雞湯。開啟壓力功能，煮 45分鐘（或用慢煮鍋用高火 6小時），即成。\n4. 撈起豬肉，放在乾淨的切板上。用兩隻叉子撕成幼絲。\n5. 汁過篩，把過濾出的材料用搞拌器搞爛成糊。把糊狀物和汁一起倒進鍋中，用中火煮約 6至 8分鐘，直至汁收乾一半濃稠些。淋在撕開的豬肉絲上。可做三文治，漢堡包，或佐飯吃。一樣好味道呢。\n\n## 烤肋排\n\n*食譜來源：「一鍋抵多鍋，每家必備的70道萬用鍋，零失敗美味提案」\n\n【烤肋排~如何軟硬適中？】\n試試先煮\u003e後醃\u003e再烤至兩面金黃吧！\n\n- 萬用鍋示範型號：HD2179\n- 3-4人份\n\n材料：\n- 豬肋排 500克\n- 豬肋排醃料：(也可用市售醃醬)\n- 巴薩米克醋 45ml\n- 番茄醬 3湯匙\n- 黃芥茉 1/4湯匙\n- 紅糖 1又 1/2湯匙\n- 蜂蜜（或楓糖）1/4湯匙\n- 蒜 1瓣\n- 初搾橄欖油 1/2湯匙\n\n步驟:\n1. 豬肋排放進內鍋，加水蒸過肋排。上蓋限壓閥轉至「密封」，按「功能選擇」鍵，選擇「煮粥」模式（30分鐘）及「開始烹調」鍵 。\n2. 蒸熟後取出豬肋排 ，待涼後放入密封袋與醃料醃三小時~過夜。\n3. 豬肋排濾去醃料（醬汁留下備用）。按「無水烹調」鍵，選「烤排骨」，放入豬肋排（肉面朝下）關蓋烤20分鐘，中途要翻面及觀察不要烤焦。\n4. 倒進醬汁收汁至濃稠。\n\nTips:\n1. 豬肋排如過長不能整排放進內鍋，可先切成條狀再煮，及分批烤。\n\n\n## 孜然烤肋排\n\n- 肋排6-8根\n- 洋蔥-半顆\n- 孜然粉-均勻抹在肋排上（如果喜歡味道重一點的可以多加）\n- 黑胡椒粉少許（喜歡吃辣的可以用辣椒粉代替)\n- 醬油-一湯匙（請斟酌自家醬油鹹度做調整）\n- 橄欖油-少許\n- 冰糖-少許\n- 水-一湯匙\n\n做法\n1. 除了洋蔥，全部材料伴勻醃半小時，將醃好肋排放入鍋內鋪上洋蔥。 \n2. 無水模式烤肋排\n3. 開鍋後，再選烤蝦模式將另一面也煎上色\n4. 試吃味道做調整\n5. 上色好就可以上桌啦！\n*洋蔥應該都化掉了，喜歡有醬汁的人可以把底部洋蔥醬汁淋上去\n","lastmodified":"2024-02-23T05:15:51.442099021Z","tags":[]},"/notes/Longtern/Cooking/%E6%97%A5%E6%9C%88%E6%BD%AD%E7%B4%85%E8%8C%B6":{"title":"日月潭紅茶","content":"- 謝江林茶莊: 容易腸胃不舒服，不回購。\n- ","lastmodified":"2024-02-23T05:15:51.442099021Z","tags":["food"]},"/notes/Longtern/Cooking/%E7%99%BD%E6%9C%A8%E8%80%B3%E6%96%99%E7%90%86":{"title":"白木耳料理","content":"https://tokyonion52.pixnet.net/blog/post/354828454-%E6%A1%82%E8%8A%B1%E9%87%80%E5%A5%B6%E8%8C%B6%E6%9C%A8%E8%80%B3\n\n看到全聯的奶茶木耳特價，想模仿白木耳的方式，也參考人家的甜湯作法\n1. 木耳摘除硬耳部分，手撕成小朵(撕成不規則切面，比較容易釋出膠質!)\n2. 放入、水，大火煮滾後小火煮 1hr \n3. 關火，悶 30~1hr，可以釋放更多膠質 (也可省略)\n4. 喝之前加入桂花釀","lastmodified":"2024-02-23T05:15:51.442099021Z","tags":["food"]},"/notes/Longtern/Cooking/%E7%B4%A0%E9%A3%9F%E9%AB%98%E8%9B%8B%E7%99%BD%E6%96%99%E7%90%86":{"title":"素食高蛋白料理","content":"## 素食者蛋白質來源\n1. 黃豆製品: 豆漿、豆腐、豆乾、豆包，但炸豆皮、豆腐忌口，會吸收過多的油。\n2. 黑豆\n3. 毛豆\n4. 鷹嘴豆\n\n| 一顆雞蛋 | 換算 |\n| ---- | ---- |\n|  | 兩格傳統豆腐 |\n|  | 半盒嫩豆腐 |\n|  | 無糖豆漿 190cc |\n|  | 25g 黑豆 |\n|  | 50g 毛豆 |\n|  | 33g 鷹嘴豆 |\n|  |  |\n\n## 500 kcal 便當\nhttps://www.youtube.com/watch?v=hu1GkoHBI0c\n\n**菜單**\n- 藜麥飯\n- 雞腿肉番茄蛋: 先煎雞腿、在放小番茄，最後下雞蛋，一分鐘就要起鍋蛋才會嫩!\n- 木耳切絲，蒸\n- 豆腐烘蛋: 蛋汁+弄碎的豆腐，烤\n\n\n\n\n## 素食便當\n\nhttps://www.youtube.com/watch?v=7GsYaROdrbI\n\n- 藜麥玉米飯\n- 煎板豆腐 (醃過)\n- 洋蔥豆腐蛋\n- 毛豆蘿蔔絲\n- 調味: 無糖花生醬\n### 食材\n板豆腐x2、新鮮玉米x2根、藜麥x2杯、毛豆 200克、紅蘿蔔1根、花椰菜1顆、洋蔥1顆、薑絲少許、黑胡椒、醬油、薑黃粉、油、鹽巴、花生醬\n\n### 事前準備\n1 塊板豆腐切片，加醬油:水=1:1，再加少許黑胡椒，醃製30分鐘。\n2 杯半藜麥洗完泡水30分鐘，將玉米切下來，與2杯半藜麥放進電鍋煮（內鍋放2杯半的水），外鍋放一杯水。\n\n### 烹飪步驟\n1. 將洋蔥切絲，開火加油，油熱鍋後，小火爆香洋蔥至微變色，將板豆腐捏碎丟入鍋中小火翻煮，加入薑黃粉調色，加鹽巴、黑胡椒調味，盡量把豆腐收乾，避免盛盤後出汁問題，小火炒乾後，盛盤完成。\n2. 薑切絲下油鍋爆香，下紅蘿蔔絲拌炒，加入水小火燜煮至軟，加入青豆仁、鹽、胡椒粉調味，拌至熟後起鍋備用。\n3. 加一點點油，熱鍋後，將醃製好的豆腐一片一片下鍋煎，控制油溫不能太高，讓板豆腐平均上色後，即可起鍋。\n4. 滾水煮花椰菜1-2分鐘，記得滾水裡要加一些鹽巴，避免花葉菜沒味道，起鍋後，花生醬直接加在花椰上調味即可。\n","lastmodified":"2024-02-23T05:15:51.442099021Z","tags":["food"]},"/notes/Longtern/Cooking/%E7%B6%B2%E5%8F%8B%E5%A3%93%E5%8A%9B%E9%8D%8B%E7%94%A8%E6%99%82%E7%B6%93%E9%A9%97":{"title":"網友壓力鍋用時經驗","content":"蒸東西: 開蓋蒸就像一般電鍋，用壓力蒸可以少一半的水。\n\n## 蒸早餐\n\n- 用不銹鋼內鍋，內鍋放半杯水\n- 無水料理、焗烤時蔬3分鐘\n- 3分鐘立馬拿出來，蛋是溏心蛋，如果想要熟一點可以悶一下再拿，或用4分鐘\n- 蓋上一般鍋蓋，**不必蓋上蓋**。時間到就可以了\n\n## 烤三層肉\n看起來普普，但很下飯，搭配檸檬汁沾著吃也比較去油解膩。\n作法：\n1. 三層肉刷上醬油 (我用薄鹽醬油) 整塊放入內鍋(因為我用安康內鍋所以有鋪烤焙紙)。\n2. 用無水烹調烤排骨模式，剩13分鐘時候開鍋翻面灑孜然粉，剩3分鐘的時候再開鍋將另一面也灑孜然粉，繼續烤到結束。\n3. 沾醬是檸檬汁(有加一點點水)+迷迭香\n## 健康版本鹹酥雞\n- 醃料：蒜頭，醬油，五香粉，味霖，黑胡椒\n- 把里肌雞條放進去捏一捏，冰進冰箱。晚上，雞里肌切小塊，沾地瓜粉，等回潮。\n\t- 回潮：肉沾完地瓜粉白白的，靜置在盤裏讓白白的粉變得濕濕的，變成咖啡色的感\n- 無水料理，烤雞模式 18 分鐘。(也有說法可以兩段九分鐘，中途翻肉)。\n- 反省：粉最後有點沾黏，濕濕的，下次再試試其他方法或是粉～突發其想，用蕃茄醬感覺會變估佬肉或是韓式炸雞的效果\n\nhttps://www.facebook.com/groups/257779554349366/posts/833106060150043/\n\n## 紅燒牛腩\n(金小萬)\nhttps://www.facebook.com/groups/257779554349366/posts/4874776709316271/\n1. 少許油加入冰糖炒至冰糖溶化後加入牛肋條炒至牛肋條上色後，倒入金小萬不沾內鍋.\n2. 將薑片爆香後依序放入洋葱和牛蕃茄炒香，在加入紅蘿蔔和白蘿蔔。\n3. 加入豆瓣醬、醬油膏和白胡椒粉、少許塩調味後在加入少許的開水略煮一下即可倒入金小萬不沾內鍋。\n4. 金小萬 點選牛肉/羊肉 行程燉煮牛肋條即可。\n\n- 開鍋食用心得：牛肋條燉的很軟嫩，但是紅/白蘿蔔就太爛了⋯但是拌飯拌麵口感不錯很好吃\n- 因為我們家喜歡吃有口感的蘿蔔，所以我另外在開鍋，將紅/白蘿蔔放入不沾內鍋加入少許的醬油和一點點開水即可，選米飯行程煮出來的口感還不錯，在跟我原本燉好的紅燒牛腩拌勻後家人都說紅/白蘿蔔很好吃了。\n- 豆油伯醬油、屏科大薄塩醬油膏\n\n\n## 冰花煎餃加蛋\n(金小萬，棕小萬應該無法中途開蓋)\n- 烤雞模式+不沾鍋+抹一點油\n- 冷凍餃直接下鍋，倒麵粉水（麵粉1:水8:油1）\n- 上壓力鎖\n- 倒數五分鐘前開蓋倒兩顆散蛋上蓋\n- 喜歡的話可以灑一些黑芝麻增加香氣\n- 行程跑完，開鍋上盤\n\n## 小萬可以放碗盤進去蒸煮嗎\n\nhttps://www.facebook.com/groups/257779554349366/posts/942123972581584/\n\n## 配件\n- [蒸架討論文](https://www.facebook.com/groups/257779554349366/posts/2549104948550137/)\n\t- IKEA 官網: 可搭配使用一般4-5公升的深鍋，最多可堆疊3個，方便同時蒸煮大量食材\n\t- https://www.ikea.com.tw/zh/products/cookware/pots-and-cooking-accessories/stabil-art-90163525\n\t- 23 cm、八吋都有機會匹配\n- 不沾鍋搭配矽膠刮刀為佳\n- 內蒸架 Linox 竹節蒸架: https://shopee.tw/product/152178501/23422827173?utm_campaign=-\u0026utm_content=-5976304978596f42425a30385f355f326e385830---\u0026utm_medium=affiliates\u0026utm_source=an_16136160000\u0026utm_term=9x77iire7ac7\n- ","lastmodified":"2024-02-23T05:15:51.442099021Z","tags":[]},"/notes/Longtern/Cooking/%E8%90%AC%E7%94%A8%E9%8D%8B%E4%BD%BF%E7%94%A8%E7%B6%93%E9%A9%97":{"title":"萬用鍋使用經驗","content":"## 手撕豬\n### 材料\n- 約 1kg 的五花肉\n- 醬料: 黃芥末醬、A1 牛排醬、米酒 .... \n### 步驟\n1. 肉四面拍鹽巴、黑白胡椒粉，煎的金黃\n2. 把肉浸在調好的醬料醃漬至少 30分鐘\n3. 壓力鍋「豆類模式」: 先設保壓 1hr，翻面再 30 分鐘。\n4. ","lastmodified":"2024-02-23T05:15:51.442099021Z","tags":[]},"/notes/Longtern/Cooking/%E9%A3%9B%E5%88%A9%E6%B5%A6%E5%A3%93%E5%8A%9B%E9%8D%8B-%E5%85%A7%E9%8D%8B%E7%A0%94%E7%A9%B6":{"title":"飛利浦壓力鍋 內鍋研究","content":"\n- 安康內鍋: 不鏽鋼 $2000 UP，材質後時可直火\n- 第一夫人: 不鏽鋼 $500~1000，不可直火但便宜\n- 飛利浦不沾鍋: 可以到 $500，有時 momo 定價 $1000，建議一年換一個。\n\n## 不沾鍋\n魚骨頭、骨頭湯等硬殼東西建議不要用不沾內鍋煮。\n\n","lastmodified":"2024-02-23T05:15:51.442099021Z","tags":["food"]},"/notes/Longtern/Golang/Golang":{"title":"Golang","content":"# Golang\n\n\n## go: go.mod file not found in current directory or any parent directory\n\n在嘗試安裝模組時出現問題，需要先 init module 再下 `mod get`\n\n```\ngo mod init \u003ccurrent-dir-name\u003e\n```\n\nhttps://www.techdatao.com/article/detail/57.html\n\n![image-20231001224624854](img/Golang/image-20231001224624854.png)\n\n## GOROOT and GOPATH\n\n設置環境變數的方法\n```\ngo env -w GO111MODULE=auto\n```","lastmodified":"2024-02-23T05:15:51.442099021Z","tags":[]},"/notes/Longtern/Hugo/Hugo-Publish-Simple-Page":{"title":"以 Hugo 發佈簡單的頁面","content":"## Hugo 建立部落格的範例\n\n直接用 Hugo 建立部落格，不使用 Quartz 的範例:\n\n### Start\n```bash \nhugo new site quickstart  \ncd quickstart  \ngit init  \ngit submodule add https://github.com/theNewDynamic/gohugo-theme-ananke themes/ananke  \necho \"theme = 'ananke'\" \u003e\u003e config.toml  \nhugo server\n```\n\n## Add a content page \n```\nhugo new content my-first-post.md\n```\n\n\n\n[https://gohugo.io/getting-started/quick-start/](https://gohugo.io/getting-started/quick-start/)\n\n### 將 Markdown 檔案轉換成 Web Page\n下兩者擇一即可\n\n```bash \nhugo server --buildDrafts  \nhugo server -D\n```\n\nindex.html 通常沒有內容，想要知道剛才新增的夜面有沒有成功登記在案，可以去: http://localhost:1313/sitemap.xml\n\n\n主題會有自己的 `config.toml`，通常會在該主題 github 的 example site (可能是一個資料夾或專案) 底下，以 hugo-coder 為例，在把主題載到 `themes/hugo-coder` 底下之後: \n\n```bash\ncp themes/hugo-coder/exampleSite/config.toml .\n```\n\n這樣就不用重零配置。但需要注意，啟用 `hugo server ` 時，預設讀取的設定檔是 `hugo.toml`，而主題提供的預設設定檔案通常是 `config.toml`。想要直接使用 `config.toml` 需要指定參數: \n\n```bash\nhugo server -D --config config.toml\n```\n\n## docsy\nDocsy 需要用到 `npm` 以及 `hugo-extension`\n\n```bash\nhugo new site test-docsy  \ncd test-docsy\ngit init  \ngit clone --depth 1 https://github.com/me/example.git themes/docsy\n## 安裝 docsy 獨有的依賴項目\ncd themes/docsy/userguide/\nnpm install\nnpm run serve\ncd ../../../ # root of test-docsy\n###\necho \"theme = 'docsy'\" \u003e\u003e config.toml  \nhugo server\n```\n\n\n\n### Bug: binary go not found...\n注意 hugo build 的版本與當前 go 的版本是否一致!\n\n\n## Coder \n```bash \nhugo new site quickstart  \ncd quickstart  \ngit init  \ngit submodule add https://github.com/luizdepra/hugo-coder themes/hugo-coder  \necho \"theme = 'ananke'\" \u003e\u003e config.toml  \nhugo server\n```\n\n## Resource \n[Hugo 從零開始 建立自己的部落格](https://devbricker.github.io/post/hugo/deploy/hugo_build1/)\n[用 Hugo 來寫文章吧](https://tonypepe.com/posts/hugo/hugo)","lastmodified":"2024-02-23T05:15:51.442099021Z","tags":[]},"/notes/Longtern/Hugo/Hugo-front-matter":{"title":"Hugo 可使用的metadata","content":"\nSource: https://gohugo.io/content-management/front-matter/\n\n舉例:\n\n```yaml\ncategories:\n- Development\n- VIM\ndate: \"2012-04-06\"\ndescription: spf13-vim is a cross platform distribution of vim plugins and resources\n  for Vim.\nslug: spf13-vim-3-0-release-and-new-website\ntags:\n- .vimrc\n- plugins\n- spf13-vim\n- vim\ntitle: spf13-vim 3.0 release and new website\n```\n\n可建立 Obsidian 模板:\n\n```yaml\ntitle: \ndate: {{date}}\ndescription: \n\nslug: alias-name\ntags:\n- default\ncategories:\n- default\n\n```\n\n本頁所使用的 metadata: \n```yaml\ntitle: \"可使用的metadata\"\ndate: 2023-04-09\nslug: usable meta data # 網址變成此名稱\ncategories:\n- blog\n```\n\n這裡，我讓檔案名稱變成\n- filename: `Hugo front matter.md` \n- title: `可使用的metadata` \u003e 頁面標題\n- slug: `usable meta data` \u003e 連結名稱\n\n\n## Category vs. Tag\n\n在打造第二大腦中，作者提出 Tag 是一種打破資料夾邊界的連結方式。我希望，在我的部落格中，我希望讓網頁會 Category 做資料夾壁壘的分類，有必要時再以 tag 打破邊界。\n\n但似乎 quartz 支援的只有 tags 而沒有 categories。我想參考這篇文章試試看能不能打開該功能: \nhttps://ithelp.ithome.com.tw/articles/10244921\n\n## Description\n沒有用，不會改變預覽頁面的內容。\n","lastmodified":"2024-02-23T05:15:51.442099021Z","tags":[]},"/notes/Longtern/Obsidian/Obsidian-Map-View":{"title":"Obsidian Map View","content":"[Github: Obsidian Map View](https://github.com/esm7/obsidian-map-view)\n\n## 紀錄\n\n### 導入已記錄在 Map 的地點\n1. 開啟命令面板 -\u003e  \"Map View: add inline geolocation link\"，文字 `[](geo:)` 會被插入。\n2. 在中括號中輸入地點，像是: `[台北101]`，會跳出下拉選單，點選之後經緯度位置會自動填在 `(geo:)` 當中。\n\n### 從 Command 上新增地點\n\n1. 開啟命令面板 -\u003e\"Map View: New geolocation note\"。\n2. 跳出一個 Dialog，貼上連結、或是 Search 地點都可以。\n\t- 網址連結分析的規則: [URL parsing rules](https://github.com/esm7/obsidian-map-view#url-parsing-rules)\n\t- Search 地點會受到選擇哪一個地點資訊提供者所影響: [configured geocoding provider](https://github.com/esm7/obsidian-map-view#changing-a-geocoding-provider) \n\n### 從既有的筆記新增地點\n### Inline geolocation link\n如前面「從 Command 新增地點」，在文章中以 `[](geo:)` 標示地點。\n\n### 以 Metadata 標註本文是一個地點\n\n1. 開啟命令面板 -\u003e\"Add geolocation (front matter) to current note\"。\n\n\n## Changing a Geocoding Provider\n1. 去 Google 申請 Googla Map API\n2. 在 Obsidian Map View 的設定當中把 Provider 改成 Google，貼上 API Key.\nhttps://github.com/esm7/obsidian-map-view#changing-a-geocoding-provider\n\n\nGoogle API 可以設權限 Query 哪些內容，其中 [Places API](https://developers.google.com/maps/documentation/places/web-service/cloud-setup) 可以讓我們在 Command Line 直接搜尋 Google 地點。花費會比較高，但如果是作為筆記軟體，應該會是在 Google 的免費額度 200美金之內。\n\n## 把 Map Source 切換成 Google \n參考 : https://github.com/esm7/obsidian-map-view/issues/51\n在 Map source 中新增一個 Google Map 選項，Url: `https://mts1.google.com/vt/lyrs=m@186112443\u0026hl=x-local\u0026src=app\u0026x={x}\u0026y={y}\u0026z={z}\u0026s=Galile`\n","lastmodified":"2024-02-23T05:15:51.442099021Z","tags":["obsidian"]},"/notes/Longtern/Obsidian/Obsidian-Plugins":{"title":"Obsidian Plugins","content":"## Theme\n- 當前用的是 Thing2\n- [minimal](https://minimal.guide/Home) 也是熱門的主題，且與許多 plugin 相容\n\t- 但是 header 之間不同階級沒有大小之分，我不喜歡，要用需要改 CSS。\n\n\n\n## Plugin\n- Obsidian Dataview mode: like notion https://ithelp.ithome.com.tw/articles/10279262\n- [[Obsidian Map View]]: [source](https://github.com/esm7/obsidian-map-view#intro)\n- \n","lastmodified":"2024-02-23T05:15:51.442099021Z","tags":[]},"/notes/Longtern/Obsidian/Sync-Obsidian":{"title":"Obsidian Publish 的替代選擇","content":"想在 IOS 上面也有 Sync 的 Obsidian 可以用!\n\n社群的作法是裝 ISH 以 Git 同步，我想實驗用 Terminus (比起 ISH 有在維護)\n\n- [Sync with git on iOS for free using iSH](https://forum.obsidian.md/t/mobile-sync-with-git-on-ios-for-free-using-ish/20861)\n- [Setting up iOS git-based syncing with mobile app (using Working Copy)](https://forum.obsidian.md/t/mobile-setting-up-ios-git-based-syncing-with-mobile-app-using-working-copy/16499)\n","lastmodified":"2024-02-23T05:15:51.442099021Z","tags":[]},"/notes/Longtern/Python/Asyncio":{"title":"Asyncio","content":"# Asyncio \n\n在 [Asyncio](https://brainynight.github.io/posts/2022-10-23-python-asyncio) 這篇簡介的文章中，有一個簡單的例子如下。本文將針對此例仔細探討。\n\n```python\nimport asyncio\n\nasync def single_process(cmd):\n    proc = await asyncio.create_subprocess_shell(\n        cmd,\n        stdout=asyncio.subprocess.PIPE,\n        stderr=asyncio.subprocess.PIPE)\n    try:\n        await asyncio.wait_for(proc.communicate(), timeout=2)\n        print(cmd, \"complete\")\n    except asyncio.TimeoutError:\n        print(cmd, \"timeout\")\n        \nasync def run_all(cmds):\n    lt = []\n    for cmd in cmds:\n        lt.append(single_process(cmd))\n    await asyncio.gather(*lt)\n\nif __name__ == \"__main__\":\n    cmds = [\n        \"sleep 1 \u0026\u0026 echo hello\",\n        \"sleep 1.5\",\n        \"echo world\",\n        \"sleep 500\",        \n    ]\n    asyncio.run(run_all(cmds))\n```\n\n## Asyncio \n\nmain page: https://docs.python.org/zh-tw/3/library/asyncio.html\n\n接下來只會介紹 main page 當中高階 API 的部分內容。\n\n- [`asyncio.Runner`](https://docs.python.org/zh-tw/3/library/asyncio-runner.html): 是一個 context manager (使用 `with` 語句)，使我們不用管資源關閉或釋放的問題。\n- [協程與任務 (coroutines and tasks)](https://docs.python.org/zh-tw/3/library/asyncio-task.html): 這兩者是 high level API 使用者主要會使用到的類別，建議可詳讀。\n- [Debug mode](https://docs.python.org/zh-tw/3/library/asyncio-dev.html)\n- [Synchronization Primitives](https://docs.python.org/zh-tw/3/library/asyncio-sync.html): asyncio 提供了一些和 threading 模組相似的物件，像是 Lock, Semaphore。不過要注意，asyncio 模組的內容大多都是 non-thread-safe 的。\n- [High Level API Index](https://docs.python.org/zh-tw/3/library/asyncio-api-index.html)\n\n\n\n\n## Coroutine\n\n官對\"Coroutine\" 這個詞彙的說明，我不打算仔細解釋。\n\n在官方文件中，coroutine 很反覆的被提及，有時指的是 coroutine object ，有時是 coroutine function。\n\n- coroutine function: 被以 `async def` 宣告的 function\n- coroutine object: 呼叫 coroutine function 時所回傳的物件。\n\n詳見 [PEP 492](https://peps.python.org/pep-0492/)。\n\n\u003e 協程 coroutine[¶](https://docs.python.org/3/glossary.html#term-coroutine)\n\u003e\n\u003e Coroutines are a more generalized form of subroutines. Subroutines are entered at one point and exited at another point. Coroutines can be entered, exited, and resumed at many different points. They can be implemented with the [`async def`](https://docs.python.org/3/reference/compound_stmts.html#async-def) statement. See also [**PEP 492**](https://peps.python.org/pep-0492/).\n\u003e\n\u003e 協程函數 coroutine function\n\u003e\n\u003e A function which returns a [coroutine](https://docs.python.org/3/glossary.html#term-coroutine) object. A coroutine function may be defined with the [`async def`](https://docs.python.org/3/reference/compound_stmts.html#async-def) statement, and may contain [`await`](https://docs.python.org/3/reference/expressions.html#await), [`async for`](https://docs.python.org/3/reference/compound_stmts.html#async-for), and [`async with`](https://docs.python.org/3/reference/compound_stmts.html#async-with) keywords. These were introduced by [**PEP 492**](https://peps.python.org/pep-0492/).\n\n\n\n一個協程通常透過協程函數取得，如下例 `cfunc` function ，會回傳一個 coroutine object。\n\n```python\nimport asyncio\n\nasync def cfunc():\n    print('hello')\n    await asyncio.sleep(1)\n    print('world')\n```\n\n何以得知? 如果使用 ipython 這類的互動 console，直接看 `cfunc()` 物件是什麼東西，會看到這樣的內容:\n\n```python\n\u003e\u003e\u003e cfunc()\n\u003ccoroutine object cfunc at 0x7fe9094b2650\u003e\n\u003e\u003e\u003e type(cfunc())\n\u003cclass 'coroutine'\u003e\n```\n\n這表示，此 function 回傳的內容會是一個 coroutine object! 要注意，coroutine object 必須使用一些支援異步執行的函式/語法來正確的運行，例如 `asyncio.run`， `cfunc()` 實質上的功能，就只是回傳一個 coroutine object 而已。\n\n## Awaitable object \n\n指的是可以用在 `await` expression 的物件，主要的三種 awaitable object 是 coroutines, Tasks, 和 Futures，另外就是擁有 `__await__()` 方法的物件。`await` 只能被使用在 coroutine function 內。三種 type 當中，Future 屬於比較底層的 API，將不說明。\n\n### coroutine object\n\n前例的 `asyncio.sleep(1)` ，本質上也是透過一個 coroutine function 取得 coroutine object，因此必須以關鍵字  `await` 接住這個 coroutine object。\n\n若 coroutine function 內還會呼叫另一個 coroutine function，被呼叫的 coroutine function 前必須加 `await`，因為它回傳的是個 coroutine object。\n\n```python\nimport asyncio\nimport time\n\nasync def say_after(delay, what):\n    await asyncio.sleep(delay)\n    print(what)\n\nasync def main():\n    print(f\"started at {time.strftime('%X')}\")\n    # needs to add `await` when call a coroutine function, but not directly execute.\n    await say_after(1, 'hello') \n    await say_after(2, 'world')\n    print(f\"finished at {time.strftime('%X')}\")\n\n# The method for directly execute is asyncio.run\nasyncio.run(main())\n```\n\n-  `asyncio.run` 才會真正執行被給予的 coroutine object\n\n### asyncio.Task\n\n`create_task` 回傳一個 `asyncio.Task` 物件，我們得以提前創造 task，等到需要想要執行這個 task 的地方，再以 `await` 呼叫。\n\n同樣的，這裡的「執行」並不是真的「跑」下去，比較像是標示「我想再這裡執行這個 function」。真正的執行依然是交給 `run`。\n\n\n```python\nasync def main():\n    task1 = asyncio.create_task(say_after(1, 'hello'))\n    task2 = asyncio.create_task(say_after(2, 'world'))\n    \n    print(f\"started at {time.strftime('%X')}\")\n    # Wait until both tasks are completed (should take around 2 seconds.)\n    await task1\n    await task2\n    print(f\"finished at {time.strftime('%X')}\")\nasyncio.run(main())\n```\n\n[`TaskGroup`](https://docs.python.org/3/library/asyncio-task.html#asyncio.TaskGroup) 是另外一種創建 task 並執行的方法，可以不用寫 `await` (隱性的在 `with` 結束時呼叫 await 把 tasks call 一遍)，不過這個 API 只在 Python3.11 起提供，就不多提。\n\n\n\n## asyncio.gather\n\n```python\nasyncio.gather(*aws, return_exceptions=False)\n```\n\n- 接收多個 awaitable 物件，如果 awaitable 物件當中有 coroutine，gather 會把它當作 Task 調度 (scheduled as a `Task`)。\n- 回傳值: 當所有的 awaitable object 都完成任務後，`asyncio.gather` 會把這些任務的回傳值放在一個 list 裡面回傳結果。結果的順序與放進 `gather` 的順序相同。\n- `return_exception` \n    - 預設是 false，當任務執行中發生 exception，會及時 raise exception，並取消 gather (剩下的任務將不會跑到)\n    - 若為 true，則不會 raise exception，而是將 exception 的內容 (?) 當作執行成功的結果，一起在 `gather` 的回傳清單中。\n\n## asyncio.wait\n\n```python\nasyncio.wait(aws, *, timeout=None, return_when=ALL_COMPLETED)\n```\n\n- 接收一個 list，內含多個 awaitable 物件。\n- 程式會停在這裡執行同時所有的任務\n\n\n\n## Subproccess\n\nhttps://docs.python.org/zh-tw/3/library/asyncio-subprocess.html\n\n\n\n\n\n\n\n## A\n\n`asyncio.create_subprocess_shell` 是一個 coroutine function，回傳的是 `asyncio.subprocess.Process` 物件。[doc](https://docs.python.org/zh-tw/3/library/asyncio-subprocess.html#asyncio.create_subprocess_shell) \n\n\n\n\n\n\n\n","lastmodified":"2024-02-23T05:15:51.442099021Z","tags":[]},"/notes/Longtern/Quartz/%E4%BD%BF%E7%94%A8-Quartz-%E5%BB%BA%E7%AB%8B%E9%83%A8%E8%90%BD%E6%A0%BC":{"title":"使用 Quartz 建立部落格","content":"\n\n## Install\n\n1. Git\n2. Go lang\n3. Hugo: 需要手動加環境變數\n4.  `go-obsidian`\n    ```go\n    go install github.com/jackyzha0/hugo-obsidian@latest\n    ```\n5. **Optional**  `make` `: Windows 下須使用 MinGW 安裝，參考: [C++ 開發環境 在 Windows 11 中安裝 mingw-w64 及設定環境變數](http://kaiching.org/pydoing/cpp-guide4/how-to-install-mingw-w64-and-set-environment-variable.html)\n\nHugo 需要以 [PowerShell](https://learn.microsoft.com/en-us/powershell/scripting/install/installing-powershell-on-windows) 或 WSL , Git Bash 這種 linux-based terminal 運行。\n\n## Start to Quzrtz\n官方網站有相關的教學: \n- https://quartz.jzhao.xyz/notes/setup/\n- https://quartz.jzhao.xyz/notes/obsidian/\n\n以下我將擷取最短步驟\n### 摘要步驟\n\n1. Fork quartz 的 Github 專案，並 clone 到 Local。\n2. 在 Clone 下來的倉庫中找到資料夾 `content`\n3. 在 `content` 資料夾中創建 Obsidian 倉庫，或是把既有的倉庫內容放到 content 裡面。\n4. 將 Obsidian 倉庫轉換成 Hugo 可用的\n\n    ```bash\n     hugo-obsidian -input=content -output=assets/indices -index -root=.\n    ```\n\n    需要注意，markdown 檔名不可以有 `.`，且每一篇文章都要有 metadata: 在頁首有 `title` 的資訊，如下: \n\n    ```markdown\n    ---\n    title: \"Private Stuff\"\n    ---\n    ```\n\n    其實有更多的 meta-data 可以設定，可以看 quartz 給的範例。由於使用 quartz 創建模板必須要 metadata，[作者建議](https://quartz.jzhao.xyz/notes/obsidian/)可以直接在 Obsidian 裡面創建模板，讓每新增一個模板都有這些資訊! \n\n5. 啟用 Hugo Server\n\n    ```bash\n     hugo server --enableGitInfo --minify \t# render faster\n     hugo server --disableFastRender \t\t# search bar will enable\n    ```\n\n\n## 關於 Obsidian 模板功能\n- 可以參考此文介紹如何建立模板 [【Obsidian 使用教學】筆記篇 05 — 結合資訊處理流程，讓筆記的 Metadata 變得更詳細](https://medium.com/pm%E7%9A%84%E7%94%9F%E7%94%A2%E5%8A%9B%E5%B7%A5%E5%85%B7%E7%AE%B1/obsidian-%E4%BD%BF%E7%94%A8%E6%95%99%E5%AD%B8-%E7%AD%86%E8%A8%98%E7%AF%87-05-%E7%B5%90%E5%90%88%E8%B3%87%E8%A8%8A%E8%99%95%E7%90%86%E6%B5%81%E7%A8%8B-e6a953438f43)\n- 要注意，插入模板的時候，需要打完檔案名稱，並把 Insert 的鼠標要在 Header 1 下的第一行。\n\n## Obsidian Embed \n在 Obsidian 會把頁面嵌入，在 Quartz 會直接轉換成內部連結。\n\n## 發佈到 Github Page\n\n參考 [[Publish Quartz to Github Page]]\n\n\n## 修改首頁\n\n如果想在首頁放置一些連結，引導到特定頁面，需要注意以下幾點: 雙向連結內放的是「相對於該頁面的路徑」，路徑對應的是檔案名稱。\n\n1.  當檔案名稱有空白時，網址會以 `-` 取代空白，但在雙向連結的撰寫中不可以寫 `-`。\n```\n[[notes/Area/PKM/Setup Quartz]] # OK  \n[[notes/Area/PKM/Setup-Quartz]] # Broken internal link\n```\n2.  注意結尾不要多加反斜線    \n3.  主頁相對於各檔案都是以 `note/` 開始\n\n## graphConfig\n在 `data/graphConfig` 最下面有一個設定項 `paths`，這是可以設定指定頁面節點的顏色，通常針對 MOC Page，如下例就是把 Effective-C++-Outline 的節點設成藍色。\n\n```yaml\npaths:\n    - /notes/Project/Effective-C++-Series/Effective-C++-Outline: \"#4388cc\"\n```","lastmodified":"2024-02-23T05:15:51.442099021Z","tags":[]},"/notes/Longtern/Quartz/Publish-Quartz-to-Github-Page":{"title":"將 Quartz 發佈到 Github Page","content":"由於我對 github action 不熟悉，在設置到 github page 的時候遇到了一點困難...。\n\n首先，如果專案是從 templage fork 過來的，它應該分成 `hugo` 跟 `master` 兩個 branch。其中\n\n- `hugo`: 存放 config, markdown files (`content` 底下) 的地方\n- `master`: 利用 github action 把專案內容轉成靜態網頁\n\n我因為是 clone 下來再 push 到自己的專案，沒有遵守這兩個命名方式而遇到了一點困難。在我的專案中，`main` 對應的是存放 markdown files (轉換前) 的 page，`publish` 才是 github page 再生成時所根據的 branch。\n\n## 設置 Github Action \n\n如作者的[教學](https://quartz.jzhao.xyz/notes/hosting/)所說，首先要打開 workflow permission。位置是 `Setting \u003e Action \u003e General`。\n\n![Set workflow Permission](https://quartz.jzhao.xyz/notes/images/github-actions.png)\n\n## 設置 Github Page \n\n在 `Setting \u003e Pages` 當中，將設置 Source 項目的 branch 設成 `master` (我則是設成 `pubslish`)。Domain name 除非自己有特別買網域，否則不用動。\n\n![Github page setting](https://quartz.jzhao.xyz//notes/images/github-pages.png)\n\n## Domain Name \n\n一共會影響兩個地方:\n\n- `config.toml`\n- `.github/workflows/deploy.yaml`\n\n如果用 github 預設的網址會是 `\u003cYOUR-GITHUB-USERNAME\u003e.github.io/\u003cProject-Name\u003e`。`config.toml` 的設定很簡單，就寫這個專案 root 網址為何:\n\n```yaml\nbaseURL = \"https://\u003cYOUR-GITHUB-USERNAME\u003e.github.io/\u003cPROJ\u003e/\"\n```\n\n`.github/workflows/deploy.yaml` 則要小心，這裡直接以我的為例，需要改兩個地方。\n\n```yaml\non:\n  push:\n    branches:\n      - main # 作者的範例是 hugo, 因為我有換 branch name 所以要改      \n```\n\n這樣，每當 push 行為發生在 `main` branch 上，就會觸發這個 action。 \n\n\n```yaml\n      - name: Deploy\n        uses: peaceiris/actions-gh-pages@v3\n        with:\n          github_token: ${{ secrets.GITHUB_TOKEN }}\n          publish_dir: ./public\n          publish_branch: publish\t# 作者預設是 master\n          cname: brainynight.github.io # 不用把 proj name 也寫上去\n```\n\n## 預覽變更\n\nGithub Action 當中，已經把建立 graph (`hugo-obsidian`) 的步驟也包含上去了。但要發布之前我們總需要自己本地先看看。\n\n作者其實有 makefile，應該可以 `make server`，會自動建立 graph 和 `hugo server`，或是懶得安裝 `make` 也可以直接打指令。以 windows 想複製 D 槽檔案為例: \n\n```bash\ncp /d/Database/*.md content/notes\nhugo-obsidian -input=content -output=assets/indices -index -root=.\nhugo server --disableFastRender\n```\n\n","lastmodified":"2024-02-23T05:15:51.442099021Z","tags":["Quartz"]},"/notes/Longtern/Special-Syntax-in-Theme-Things-2":{"title":"Special Syntax in Theme Things 2","content":"\n## Basic\n- [ ] to-do\n- [/] incomplete\n- [x] done\n- [-] canceled\n- [\u003e] forwarded\n- [\u003c] scheduling\n\n## Extras\n- [?] question\n- [!] important\n- [*] star\n- [\"] quote\n- [l] location\n- [b] bookmark\n- [i] information\n- [S] savings\n- [I] idea\n- [p] pros\n- [c] cons\n- [f] fire\n- [k] key\n- [w] win\n- [u] up\n- [d] down\n\n\nhttps://github.com/colineckert/obsidian-things\n","lastmodified":"2024-02-23T05:15:51.442099021Z","tags":[]},"/notes/Longtern/Travel/%E4%BA%AC%E9%83%BD%E6%95%A3%E7%AD%96":{"title":"京都散策","content":"## 飯店\n- [櫻花台畫廊酒店](https://www.agoda.com/zh-hk/sakura-terrace-the-gallery/hotel/kyoto-jp.html?finalPriceView=1\u0026isShowMobileAppPrice=false\u0026cid=1844104\u0026numberOfBedrooms=\u0026familyMode=false\u0026adults=2\u0026children=0\u0026rooms=1\u0026maxRooms=0\u0026checkIn=2023-09-2\u0026isCalendarCallout=false\u0026childAges=\u0026numberOfGuest=0\u0026missingChildAges=false\u0026travellerType=1\u0026showReviewSubmissionEntry=false\u0026currencyCode=TWD\u0026isFreeOccSearch=false\u0026isCityHaveAsq=false\u0026los=2\u0026searchrequestid=8a0982f6-77d5-45ce-a656-6cc1dd4b821d)\n\t- https://www.youtube.com/watch?v=h6oUyvCPZuw\n\t- https://immay.tw/post-222160129/\n\t- 京都的八条\u0008口附近也算是住宿很方便的地方，從關西空港來的話，有直達的機場巴士，下車後走到飯店也不到五分鐘就能抵達\n## 賞楓\n- https://osaka.letsgojp.com/archives/55899/\n\t\n## 主行程\n-  [嵐山一日遊](https://mimihan.tw/arashiyama/)\n- 貴船神社\n- 鴨川散步\n- 和服(清水寺)\n\n## 候補行程\n- 山崎釀酒廠: https://unclecoffee.com.tw/2019/06/22/kyoto-yamazaki-distillery/\n- 酒的美術館: https://www.1shot.tw/31935/%E9%96%8B%E5%9C%A8%E8%B6%85%E5%95%86%E7%9A%84%E9%85%92%E5%90%A7%EF%BC%9F%E6%97%A5%E6%9C%AC%E3%80%8C%E9%85%92%E7%9A%84%E7%BE%8E%E8%A1%93%E9%A4%A8bar%E3%80%8D%E9%82%84%E6%9C%89%E8%B6%85%E4%BE%BF\n- \n\n## 夜間活動\n- 京都塔\n- 八坂神社夜間參拜\n\n## 貴船神社\nhttps://www.youtube.com/watch?v=5J6ZUDTCzns\nhttps://osaka.letsgojp.com/archives/72977/\n\n## 點心\n- 蕨餅 (わらびもち)\n\n\n## 清水寺周邊\n靠近清水寺人多，\n- 清水寺周邊: 二年坂、三年坂\n- [高台寺](https://www.bring-you.info/zh-tw/kodaiji)周邊:的[寧寧之道、石塀小路](https://www.bring-you.info/zh-tw/nenes-street)、[八坂神社](https://www.bring-you.info/zh-tw/yasaka-jinja)、[祇園花見小路](https://www.bring-you.info/zh-tw/kyoto-hanamikoji)\n\t- 高台寺、八坂\nsrouce: [【京都清水寺周邊怎麼逛】一年坂、二年坂、三年坂、清水坂、八坂通老街散策](https://www.bring-you.info/zh-tw/sannenzaka-ninenzaka-streets)\n\n![清水寺一日遊](https://www.bring-you.info/wp-content/uploads/2015/08/%E6%B8%85%E6%B0%B4%E5%AF%BA%E4%B8%80%E6%97%A5%E9%81%8A%E5%9C%B0%E5%9C%96.jpg)\n\n","lastmodified":"2024-02-23T05:15:51.442099021Z","tags":[]},"/notes/Longtern/Travel/%E4%BA%AC%E9%83%BD%E8%BF%91%E9%83%8A%E4%B9%8B%E6%97%85":{"title":"京都近郊之旅","content":"## 飛機\n- 8:10 ~ 11:35 台北 - 關西，預計13:35 出關西機場\n- 12:45 ~ 14:55 關西 - 台北，預計 9:45 前需抵達關西機場。\n\n\n## 行程\nDay1 (日) 機場 \u003e 京都，晚上京都車站周圍採買。\nDay2 (一) 京都 \u003e 天橋立 \u003e 伊根 (15:00 起 check in)\nDay3 (二) 伊根 \u003e 京都 (18:00)\nDay4 (三) 貴船\nDay5 (四) 清水寺\nDay6 (五) 宇治，15:00 前往大阪\nDay7 (六) 返程\n\n\n\n\n## 伊根\n- 素食: 需要提前一周預訂 https://www.facebook.com/Ine.Nagisa\n\n","lastmodified":"2024-02-23T05:15:51.442099021Z","tags":[]},"/notes/Longtern/Travel/%E4%BA%AC%E9%98%AA%E8%87%AA%E7%94%B1%E8%A1%8C":{"title":"京阪自由行","content":"https://www.google.com/maps/d/u/0/edit?hl=zh-TW\u0026mid=158vpdkObAFS45TZNWz6fMtHHnIdmz5Q\n\n## 資料\n- [HotelsCombined](https://www.hotelscombined.com/)\n- https://resv.kyototeikikanko.gr.jp/Teikan/Web/Default.aspx\n\n## 機場交通\n![[關西機場交通.png]]\n\nhttps://www.youtube.com/watch?v=GoxGEMl35HI\n可以在 kkday 購票，有外國人特價。\n- 可以考慮購買 ICOCA (類似台灣的悠遊卡)\n- 留意何處\u0026如何取票\n\n## 素食\n- Tully's (連鎖咖啡店) 有素食餐點可選\n- 都野菜賀茂: 青菜吃到飽，有早餐時段。注意營業時間: https://yukigo.tw/blog/post/45832476-kamo\n- \n\n## 伴手禮\n- 山椒粉\n- 七味粉: \n\t- 原了郭 的 \"黑七味\"\n\t- 北野天滿宮附近的 \"長文屋\"，七味粉可以請老闆調配。可選擇中辣、山椒多的搭配，麻辣的。\n\t- \n\n\n## 注意事項\n- [藥妝店的話術陷阱](https://www.facebook.com/groups/2108024906179434/permalink/3395386450776600/?mibextid=S66gvF)\n\n","lastmodified":"2024-02-23T05:15:51.442099021Z","tags":[]},"/notes/Longtern/Travel/%E4%BC%B4%E6%89%8B%E7%A6%AE%E7%A0%94%E7%A9%B6":{"title":"伴手禮研究","content":"## 原了郭 黑七味\n![黑七味](https://cdn1.cybassets.com/media/W1siZiIsIjI0MjQwL3Byb2R1Y3RzLzQwNTAwMzcxLzE2ODE3MTY5MjRfMDYwMTljMjZhZjQ0ZGFiYmM3MmQuanBlZyJdLFsicCIsInRodW1iIiwiNjAweDYwMCJdXQ.jpeg?sha=eee9c63a0541501b)\n\n\n『原了郭』是京都知名的七味粉專賣店。創業於元祿16年（西元1703年），已有超過300歷史。\n招牌產品是手工製的『黑七味』，有別於一般的七味粉，使用黑芝麻、白芝麻、山椒、大麻籽、罌粟籽、海苔、唐辛子。據說是百年來代代相傳的配方，加上手工研製，因此只要稍微撒一些就香氣四溢，並能增加料理的風味。\n\n## 長文屋七味粉\n- https://winnie-cucina.com/20200106/\n- [京都で最高の七味を手に入れた！美味しくて唸る名店紹介「長文屋」（七味・京都市北区）](https://liquid-sense.com/2023/03/20/unaru-chobunya/)\n\n這間七味粉是現買才現做，依\u0008唐辛子(辣椒粉)的含量多寡分小辣、中辣、辣、大辣，搭配其他辛香料（ 山椒、麻の実(大麻籽)、芥子(罌粟籽)、青海苔、黒胡麻、白胡麻、紫蘇）而成，總共會加到八味，多加一味青紫蘇。\n\u003e 需要再注意營業日與時間\n\n■地址：京都市北区北野下白梅町54-8  \n■電話/傳真：075-467-0217  \n■營業時間：10：00-18：00 \n■ 法定假日：週三，週四","lastmodified":"2024-02-23T05:15:51.442099021Z","tags":[]},"/notes/Longtern/Travel/%E6%97%A5%E6%9C%AC%E6%97%85%E9%81%8A":{"title":"日本旅遊","content":"\n```mapview\n{\"name\":\"Default\",\"mapZoom\":5,\"centerLat\":37.5561912158483,\"centerLng\":138.35449397563937,\"query\":\"\",\"chosenMapSource\":0}\n```\n\n溫泉地圖: https://yadococo.net/?mibextid=Zxz2cZ\n\n\n[[東京近郊自助]]\n[[北海道自助]]\n[[京阪自由行]]\n\n---\n# 東京\n\n- [東洋大學](geo:35.7227395,139.7502677)\n- \n### 抹茶\n- [古桑庵](geo:35.6106826,139.6685775)tag:coffee \n- \n### 餐廳\n- 巴西烤肉吃到飽 [シュラスコ\u0026ビアレストラン](geo:35.6775599,139.7693144)tag:food \n- 土古里: 據傳比敘敘園好，2人分和牛拼盤 6600\n- \n\n\n\n\n\n---\n# 大阪\n- 燒肉力丸/烤肉力丸，有很多分店!\n\t- 官網: http://handafood.jp/access/\n\t- 中文 Vlog:  https://www.youtube.com/watch?v=PJ7TLFGoOFk\n\t\t- [燒肉力丸難波道頓堀店](geo:34.668604,135.4985534)tag:bbq\n\n---\n\n\n# 北海道\n## 秋田\n- [ステーキハウス 森吉 森のテラス](geo:40.0898909,140.4098114)tag:bbq\n\n## 仙台\n- 司牛舌: [牛タン焼専門店 司](geo:38.2636452,140.8705123)tag:bbq ，在仙台有多家分店\n\t- Google Map: https://goo.gl/maps/rHR7rjZqH65rzLcr9\n\t- 社團討論: https://www.facebook.com/groups/Tohoku.trip/permalink/3517369665202698/?mibextid=W9rl1R\n- \n- https://natasha-traveler.tw/tsukasa/\n- https://natasha-traveler.tw/tsukasa/","lastmodified":"2024-02-23T05:15:51.442099021Z","tags":[]},"/notes/Longtern/VimSeries/%E6%92%B0%E5%AF%AB-Nvim-Plugin":{"title":"撰寫 Nvim Plugin","content":"Nvim 有建 Python interface，需要下載模組 `pynvim`。可以下指令 `:h remote-plugin` 看官方給的教學，`:h python` 也有其他資訊。\n\n\n## 如何確定當前的 Nvim 有支援 Python\nNvim 可以使用 `checkhealth` 得知\n```\n:checkhealth\n```\n\n## 如何確定當前的 Vim 有支援 Python\n用 `:echo has(\"python\")`, `:echo has(\"python3\")` 來看是否支援 Python, Python3。\n\n想看 Python 版本: `python import sys; print(sys.version)`。\n\n","lastmodified":"2024-02-23T05:15:51.446099022Z","tags":[]},"/notes/Longtern/VimSeries/Vim-and-System-Clipboard":{"title":"Vim and System Clipboard","content":"\n## 在 Linux Neovim 上面使用系統剪貼簿\n1. 確認 `$DISPLAY` 有正確的數值\n2. 確認 `xclip` 可執行\n3. 在 init.nvim 中設置，意思是把 neovim 的剪貼簿連到 register `+`或  `*`\n\t```\n\t\"choose 1\n\tset clipboard=unnamed  \n\tset clipboard=unnamedplus\n\t```\n4. ff\n\n### unnamed 與 unnamedplus 的差別\nunmaed register 是 `*`，unnamedplus 是 `+`，兩者都是 system clipboard，差別在於\n- unmaed register `*` : 在 Linux 中表示 selection clipboard\n- unnamedplus register `+`: 就是真正的 copy paste 所放置的系統剪貼簿，在其他 OS 中也是如此。\n\n[远程主机及本地主机之间共享 Clipboard，以及 Neovim 访问 Clipboard 全解析](https://shichunhui0924.medium.com/%E8%BF%9C%E7%A8%8B%E4%B8%BB%E6%9C%BA%E5%8F%8A%E6%9C%AC%E5%9C%B0%E4%B8%BB%E6%9C%BA%E4%B9%8B%E9%97%B4%E5%85%B1%E4%BA%AB-clipboard-%E4%BB%A5%E5%8F%8A-neovim-%E8%AE%BF%E9%97%AE-clipboard-%E5%85%A8%E8%A7%A3%E6%9E%90-f9040ebb8586)","lastmodified":"2024-02-23T05:15:51.446099022Z","tags":[]},"/notes/Longtern/VimSeries/coc-snippets":{"title":"coc-snippets","content":"# Coc-snippets\n\n- 只要檔名有包含語言名稱，就可以被載入\n\n    ```\n    python1.snippets\n    python2.snippets\n    ...\n    ```\n\n    \n","lastmodified":"2024-02-23T05:15:51.446099022Z","tags":[]},"/notes/Longtern/Whisky/%E6%A0%BC%E8%98%AD%E5%82%91-%E5%96%AE%E4%B8%80%E9%BA%A5%E8%8A%BD%E5%A8%81%E5%A3%AB%E5%BF%8C":{"title":"格蘭傑-單一麥芽威士忌","content":"\nGlenmorangie X Single Malt Scotch Whisky\n\n- 買於好事多，跟 \"知多\" 喝起來差不多，CP 值極佳!! \n- 理想價格: 600-650\n\n","lastmodified":"2024-02-23T05:15:51.446099022Z","tags":["empty"]},"/notes/Longtern/Whisky/%E6%B1%80%E5%A3%AB%E9%A0%93-%E8%99%95%E5%A5%B3%E6%A1%B6%E5%96%AE%E4%B8%80%E7%B4%94%E9%BA%A5%E5%A8%81%E5%A3%AB%E5%BF%8C-%E6%B3%A2%E6%9C%AC":{"title":"汀士頓-處女桶單一純麥威士忌 (波本)","content":"\n- 價格: 799\n- 色澤:金黃色  \n## 酒條通介紹\n  \n香氣:風頭正勁的初次橡木香氣和檸檬皮和甜麥芽糖與蘋果和肉荳蔻美味的迴盪。  \n  \n口感:愉悅的甜味喚起果脯和香草太妃糖與石楠蜂蜜平衡的層次。  \n  \n尾韻:一個令人滿意的新鮮香料與蜂蜜麥芽和甜美的橡木味再帶出更多驚奇的滋味。\n\n## 個人感覺\n- 辣度比雪莉桶強烈且持久","lastmodified":"2024-02-23T05:15:51.446099022Z","tags":["empty"]},"/notes/Longtern/Whisky/%E8%89%BE%E5%80%AB-%E9%99%B3%E9%87%80%E5%96%AE%E4%B8%80%E7%B4%94%E9%BA%A5%E5%A8%81%E5%A3%AB%E5%BF%8C700ml-%E6%B3%A2%E6%9C%AC":{"title":"艾倫-陳釀單一純麥威士忌700ml (波本)","content":"\n- 價錢 899\n- https://www.609.com.tw/Product/113312\n\n## 介紹\n艾倫酒廠位於蘇格蘭最美及最有名的島嶼之一：艾倫島。  \n酒廠坐落於島上的Lochranza，擁有蘇格蘭最純淨的水源Loch na Davie。  \n  \n堅持不添加人工色素，波本桶熟成。  \n  \n香氣:柑橘和香草的香氣混合著活潑的蘋果和精緻的海風氣息。  \n口感:散發出甜美水果、溫暖香料、柑橘、奶油香草和燒焦橡木的香氣。\n## 感想\n\n顏色是麥穗田般淺淺的金黃色，店員介紹說有種口腔被油脂包覆的感覺。\n\n入口並不嗆辣，鼻腔能感受到橡木的尾韻，","lastmodified":"2024-02-23T05:15:51.446099022Z","tags":["empty"]},"/notes/Longtern/Whisky/%E9%A1%98%E6%9C%9B%E6%B8%85%E5%96%AE":{"title":"威士忌的願望清單","content":"\n雅墨12年單一純麥威士忌700ml Aultmore 12 Year Old ($1180)\nhttps://www.609.com.tw/Product/110880\n\n\n\n## 待過濾\n- [五支波本威士忌推薦文](https://medium.com/need-a-drink/%E5%8F%AA%E9%9C%80%E4%BA%94%E7%93%B6-%E6%B3%A2%E6%9C%AC-%E5%A8%81%E5%A3%AB%E5%BF%8C-%E7%BE%8E%E5%8F%B0%E5%8F%8B%E5%A5%BD-%E6%8E%A8%E8%96%A6%E6%B8%85%E5%96%AE-my-only-5-bourbon-whisky-i-need-112ff911ffbe)\n\n","lastmodified":"2024-02-23T05:15:51.446099022Z","tags":[]},"/notes/README":{"title":"README","content":"# README \nMy personal knolwedge management. \n\n","lastmodified":"2024-02-23T05:15:51.446099022Z","tags":[]}}