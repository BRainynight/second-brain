{"/":{"title":"🪴 Main Page","content":"\n我會將我所讀所學的一點點摘要進來，希望有一天他們可以建構起強大的知識網路。\n\n\n\n## 近期閱讀\n\n- [[notes/Resource/Books/The Second Brain]]\n\n\n## 文章引導\n\n- [[notes]]\n- [[tags]]\n- [[notes/Project/Effective C++ Series/Effective C++ Outline]]\n\n\n","lastmodified":"2023-05-07T06:09:55.497193346Z","tags":[]},"/notes/Archive/Special-Syntax-in-Theme-Things-2":{"title":"Special Syntax in Theme Things 2","content":"\n## Basic\n- [ ] to-do\n- [/] incomplete\n- [x] done\n- [-] canceled\n- [\u003e] forwarded\n- [\u003c] scheduling\n\n## Extras\n- [?] question\n- [!] important\n- [*] star\n- [\"] quote\n- [l] location\n- [b] bookmark\n- [i] information\n- [S] savings\n- [I] idea\n- [p] pros\n- [c] cons\n- [f] fire\n- [k] key\n- [w] win\n- [u] up\n- [d] down\n\n\nhttps://github.com/colineckert/obsidian-things\n","lastmodified":"2023-05-07T06:09:55.529193552Z","tags":[]},"/notes/Area/Hugo/Hugo-Publish-Simple-Page":{"title":"以 Hugo 發佈簡單的頁面","content":"## Hugo 建立部落格的範例\n\n直接用 Hugo 建立部落格，不使用 Quartz 的範例:\n\n### Start\n\nhugo new site quickstart  \ncd quickstart  \ngit init  \ngit submodule add https://github.com/theNewDynamic/gohugo-theme-ananke themes/ananke  \necho \"theme = 'ananke'\" \u003e\u003e config.toml  \nhugo server\n\n[https://gohugo.io/getting-started/quick-start/](https://gohugo.io/getting-started/quick-start/)\n\n### 將 Markdown 檔案轉換成 Web Page\n\nhugo server --buildDrafts  \nhugo server -D\n","lastmodified":"2023-05-07T06:09:55.529193552Z","tags":[]},"/notes/Area/Hugo/Hugo-front-matter":{"title":"Hugo 可使用的metadata","content":"\nSource: https://gohugo.io/content-management/front-matter/\n\n舉例:\n\n```yaml\ncategories:\n- Development\n- VIM\ndate: \"2012-04-06\"\ndescription: spf13-vim is a cross platform distribution of vim plugins and resources\n  for Vim.\nslug: spf13-vim-3-0-release-and-new-website\ntags:\n- .vimrc\n- plugins\n- spf13-vim\n- vim\ntitle: spf13-vim 3.0 release and new website\n```\n\n可建立 Obsidian 模板:\n\n```yaml\ntitle: \ndate: {{date}}\ndescription: \n\nslug: alias-name\ntags:\n- default\ncategories:\n- default\n\n```\n\n本頁所使用的 metadata: \n```yaml\ntitle: \"可使用的metadata\"\ndate: 2023-04-09\nslug: usable meta data # 網址變成此名稱\ncategories:\n- blog\n```\n\n這裡，我讓檔案名稱變成\n- filename: `Hugo front matter.md` \n- title: `可使用的metadata` \u003e 頁面標題\n- slug: `usable meta data` \u003e 連結名稱\n\n\n## Category vs. Tag\n\n在打造第二大腦中，作者提出 Tag 是一種打破資料夾邊界的連結方式。我希望，在我的部落格中，我希望讓網頁會 Category 做資料夾壁壘的分類，有必要時再以 tag 打破邊界。\n\n但似乎 quartz 支援的只有 tags 而沒有 categories。我想參考這篇文章試試看能不能打開該功能: \nhttps://ithelp.ithome.com.tw/articles/10244921\n\n## Description\n沒有用，不會改變預覽頁面的內容。\n","lastmodified":"2023-05-07T06:09:55.529193552Z","tags":[]},"/notes/Area/Obsidian/Obsidian-Map-View":{"title":"Obsidian Map View","content":"[Github: Obsidian Map View](https://github.com/esm7/obsidian-map-view)\n\n## 紀錄\n\n### 導入已記錄在 Map 的地點\n1. 開啟命令面板 -\u003e  \"Map View: add inline geolocation link\"，文字 `[](geo:)` 會被插入。\n2. 在中括號中輸入地點，像是: `[台北101]`，會跳出下拉選單，點選之後經緯度位置會自動填在 `(geo:)` 當中。\n\n### 從 Command 上新增地點\n\n1. 開啟命令面板 -\u003e\"Map View: New geolocation note\"。\n2. 跳出一個 Dialog，貼上連結、或是 Search 地點都可以。\n\t- 網址連結分析的規則: [URL parsing rules](https://github.com/esm7/obsidian-map-view#url-parsing-rules)\n\t- Search 地點會受到選擇哪一個地點資訊提供者所影響: [configured geocoding provider](https://github.com/esm7/obsidian-map-view#changing-a-geocoding-provider) \n\n### 從既有的筆記新增地點\n### Inline geolocation link\n如前面「從 Command 新增地點」，在文章中以 `[](geo:)` 標示地點。\n\n### 以 Metadata 標註本文是一個地點\n\n1. 開啟命令面板 -\u003e\"Add geolocation (front matter) to current note\"。\n\n\n## Changing a Geocoding Provider\n1. 去 Google 申請 Googla Map API\n2. 在 Obsidian Map View 的設定當中把 Provider 改成 Google，貼上 API Key.\nhttps://github.com/esm7/obsidian-map-view#changing-a-geocoding-provider\n\n\nGoogle API 可以設權限 Query 哪些內容，其中 [Places API](https://developers.google.com/maps/documentation/places/web-service/cloud-setup) 可以讓我們在 Command Line 直接搜尋 Google 地點。花費會比較高，但如果是作為筆記軟體，應該會是在 Google 的免費額度 200美金之內。\n\n## 把 Map Source 切換成 Google \n參考 : https://github.com/esm7/obsidian-map-view/issues/51\n在 Map source 中新增一個 Google Map 選項，Url: `https://mts1.google.com/vt/lyrs=m@186112443\u0026hl=x-local\u0026src=app\u0026x={x}\u0026y={y}\u0026z={z}\u0026s=Galile`\n","lastmodified":"2023-05-07T06:09:55.529193552Z","tags":["obsidian"]},"/notes/Area/Obsidian/Obsidian-Plugins":{"title":"Obsidian Plugins","content":"## Theme\n- 當前用的是 Thing2\n- [minimal](https://minimal.guide/Home) 也是熱門的主題，且與許多 plugin 相容\n\t- 但是 header 之間不同階級沒有大小之分，我不喜歡，要用需要改 CSS。\n\n\n\n## Plugin\n- Obsidian Dataview mode: like notion https://ithelp.ithome.com.tw/articles/10279262\n- [[Obsidian Map View]]: [source](https://github.com/esm7/obsidian-map-view#intro)\n- \n","lastmodified":"2023-05-07T06:09:55.529193552Z","tags":[]},"/notes/Area/Obsidian/Sync-Obsidian":{"title":"Obsidian Publish 的替代選擇","content":"想在 IOS 上面也有 Sync 的 Obsidian 可以用!\n\n社群的作法是裝 ISH 以 Git 同步，我想實驗用 Terminus (比起 ISH 有在維護)\n\n- [Sync with git on iOS for free using iSH](https://forum.obsidian.md/t/mobile-sync-with-git-on-ios-for-free-using-ish/20861)\n- [Setting up iOS git-based syncing with mobile app (using Working Copy)](https://forum.obsidian.md/t/mobile-setting-up-ios-git-based-syncing-with-mobile-app-using-working-copy/16499)\n","lastmodified":"2023-05-07T06:09:55.529193552Z","tags":[]},"/notes/Area/Quartz/%E4%BD%BF%E7%94%A8-Quartz-%E5%BB%BA%E7%AB%8B%E9%83%A8%E8%90%BD%E6%A0%BC":{"title":"使用 Quartz 建立部落格","content":"\n\n## Install\n\n1. Git\n2. Go lang\n3. Hugo: 需要手動加環境變數\n4.  `go-obsidian`\n    ```go\n    go install github.com/jackyzha0/hugo-obsidian@latest\n    ```\n5. **Optional**  `make` `: Windows 下須使用 MinGW 安裝，參考: [C++ 開發環境 在 Windows 11 中安裝 mingw-w64 及設定環境變數](http://kaiching.org/pydoing/cpp-guide4/how-to-install-mingw-w64-and-set-environment-variable.html)\n\nHugo 需要以 [PowerShell](https://learn.microsoft.com/en-us/powershell/scripting/install/installing-powershell-on-windows) 或 WSL , Git Bash 這種 linux-based terminal 運行。\n\n## Start to Quzrtz\n官方網站有相關的教學: \n- https://quartz.jzhao.xyz/notes/setup/\n- https://quartz.jzhao.xyz/notes/obsidian/\n\n以下我將擷取最短步驟\n### 摘要步驟\n\n1. Fork quartz 的 Github 專案，並 clone 到 Local。\n2. 在 Clone 下來的倉庫中找到資料夾 `content`\n3. 在 `content` 資料夾中創建 Obsidian 倉庫，或是把既有的倉庫內容放到 content 裡面。\n4. 將 Obsidian 倉庫轉換成 Hugo 可用的\n\n    ```bash\n     hugo-obsidian -input=content -output=assets/indices -index -root=.\n    ```\n\n    需要注意，markdown 檔名不可以有 `.`，且每一篇文章都要有 metadata: 在頁首有 `title` 的資訊，如下: \n\n    ```markdown\n    ---\n    title: \"Private Stuff\"\n    ---\n    ```\n\n    其實有更多的 meta-data 可以設定，可以看 quartz 給的範例。由於使用 quartz 創建模板必須要 metadata，[作者建議](https://quartz.jzhao.xyz/notes/obsidian/)可以直接在 Obsidian 裡面創建模板，讓每新增一個模板都有這些資訊! \n\n5. 啟用 Hugo Server\n\n    ```bash\n     hugo server --enableGitInfo --minify \t# render faster\n     hugo server --disableFastRender \t\t# search bar will enable\n    ```\n\n\n## 關於 Obsidian 模板功能\n- 可以參考此文介紹如何建立模板 [【Obsidian 使用教學】筆記篇 05 — 結合資訊處理流程，讓筆記的 Metadata 變得更詳細](https://medium.com/pm%E7%9A%84%E7%94%9F%E7%94%A2%E5%8A%9B%E5%B7%A5%E5%85%B7%E7%AE%B1/obsidian-%E4%BD%BF%E7%94%A8%E6%95%99%E5%AD%B8-%E7%AD%86%E8%A8%98%E7%AF%87-05-%E7%B5%90%E5%90%88%E8%B3%87%E8%A8%8A%E8%99%95%E7%90%86%E6%B5%81%E7%A8%8B-e6a953438f43)\n- 要注意，插入模板的時候，需要打完檔案名稱，並把 Insert 的鼠標要在 Header 1 下的第一行。\n\n## Obsidian Embed \n在 Obsidian 會把頁面嵌入，在 Quartz 會直接轉換成內部連結。\n\n## 發佈到 Github Page\n\n參考 [[Publish Quartz to Github Page]]\n\n\n## 修改首頁\n\n如果想在首頁放置一些連結，引導到特定頁面，需要注意以下幾點: 雙向連結內放的是「相對於該頁面的路徑」，路徑對應的是檔案名稱。\n\n1.  當檔案名稱有空白時，網址會以 `-` 取代空白，但在雙向連結的撰寫中不可以寫 `-`。\n```\n[[notes/Area/PKM/Setup Quartz]] # OK  \n[[notes/Area/PKM/Setup-Quartz]] # Broken internal link\n```\n2.  注意結尾不要多加反斜線    \n3.  主頁相對於各檔案都是以 `note/` 開始\n\n## graphConfig\n在 `data/graphConfig` 最下面有一個設定項 `paths`，這是可以設定指定頁面節點的顏色，通常針對 MOC Page，如下例就是把 Effective-C++-Outline 的節點設成藍色。\n\n```yaml\npaths:\n    - /notes/Project/Effective-C++-Series/Effective-C++-Outline: \"#4388cc\"\n```","lastmodified":"2023-05-07T06:09:55.529193552Z","tags":[]},"/notes/Area/Quartz/Publish-Quartz-to-Github-Page":{"title":"將 Quartz 發佈到 Github Page","content":"由於我對 github action 不熟悉，在設置到 github page 的時候遇到了一點困難...。\n\n首先，如果專案是從 templage fork 過來的，它應該分成 `hugo` 跟 `master` 兩個 branch。其中\n\n- `hugo`: 存放 config, markdown files (`content` 底下) 的地方\n- `master`: 利用 github action 把專案內容轉成靜態網頁\n\n我因為是 clone 下來再 push 到自己的專案，沒有遵守這兩個命名方式而遇到了一點困難。在我的專案中，`main` 對應的是存放 markdown files (轉換前) 的 page，`publish` 才是 github page 再生成時所根據的 branch。\n\n## 設置 Github Action \n\n如作者的[教學](https://quartz.jzhao.xyz/notes/hosting/)所說，首先要打開 workflow permission。位置是 `Setting \u003e Action \u003e General`。\n\n![Set workflow Permission](https://quartz.jzhao.xyz/notes/images/github-actions.png)\n\n## 設置 Github Page \n\n在 `Setting \u003e Pages` 當中，將設置 Source 項目的 branch 設成 `master` (我則是設成 `pubslish`)。Domain name 除非自己有特別買網域，否則不用動。\n\n![Github page setting](https://quartz.jzhao.xyz//notes/images/github-pages.png)\n\n## Domain Name \n\n一共會影響兩個地方:\n\n- `config.toml`\n- `.github/workflows/deploy.yaml`\n\n如果用 github 預設的網址會是 `\u003cYOUR-GITHUB-USERNAME\u003e.github.io/\u003cProject-Name\u003e`。`config.toml` 的設定很簡單，就寫這個專案 root 網址為何:\n\n```yaml\nbaseURL = \"https://\u003cYOUR-GITHUB-USERNAME\u003e.github.io/\u003cPROJ\u003e/\"\n```\n\n`.github/workflows/deploy.yaml` 則要小心，這裡直接以我的為例，需要改兩個地方。\n\n```yaml\non:\n  push:\n    branches:\n      - main # 作者的範例是 hugo, 因為我有換 branch name 所以要改      \n```\n\n這樣，每當 push 行為發生在 `main` branch 上，就會觸發這個 action。 \n\n\n```yaml\n      - name: Deploy\n        uses: peaceiris/actions-gh-pages@v3\n        with:\n          github_token: ${{ secrets.GITHUB_TOKEN }}\n          publish_dir: ./public\n          publish_branch: publish\t# 作者預設是 master\n          cname: brainynight.github.io # 不用把 proj name 也寫上去\n```\n\n## 預覽變更\n\nGithub Action 當中，已經把建立 graph (`hugo-obsidian`) 的步驟也包含上去了。但要發布之前我們總需要自己本地先看看。\n\n作者其實有 makefile，應該可以 `make server`，會自動建立 graph 和 `hugo server`，或是懶得安裝 `make` 也可以直接打指令。以 windows 想複製 D 槽檔案為例: \n\n```bash\ncp /d/Database/*.md content/notes\nhugo-obsidian -input=content -output=assets/indices -index -root=.\nhugo server --disableFastRender\n```\n\n","lastmodified":"2023-05-07T06:09:55.529193552Z","tags":["Quartz"]},"/notes/Project/Effective-C++-Series/%E4%BA%86%E8%A7%A3-Inline-%E7%9A%84%E8%A3%A1%E8%A3%A1%E5%A4%96%E5%A4%96":{"title":"了解 Inline 的裡裡外外","content":"\n## 原理\n用程式碼取代 function call\n\n## 向 Compiler 發出申請\n\nProgrammer 可以明確的提出請求，或隱喻的提出。但編譯器可以拒絕這個申請，大部分過於複雜的函式都會被拒絕 inline:\n- 有 loop 的\n- 多數的 virtual function (等 Runtime 才確定哪個被喚醒)\n\n顯示與隱式的分別:\n- 顯式: 關鍵字 `inline` 是一種對 Compiler 發出的明確請求，但 Compiler 不一定會聽話。\n- 隱式: 有另一種暗示請求，就是把 function 實作寫在 class 定義裡面。這種通常是 member function，但 friend function 也可直接定義在 class 內，因此也可能被隱式宣告為 inline。\n\n```cpp\nclass Person {\npublic:\n\tint age() const { return theAge; } \n\t// an implicit inline request: age is  defined in a class efinition\nprivate:\n\tint theAge;\n};\n```\n\n\n\n## 優點\n當 inline function 本身很小的時候，把程式碼展開在呼叫者的「函式本體」的成本(object code 大小) ，會比呼叫該 function 所產生的成本來的小! \n\n## 缺點\n1. 當 inline func 函式本體龐大，這些龐大的碼會散布在各個呼叫者的函式本體，導致程式太大。\n2. 由於它的表現相當於直接展開在各個呼叫者身上，一旦 inline function 有更改，caller 也會被更動。而 non-inline 就只會是重新連結的問題，對重新 Compile 的負擔比較小。\n3. Debugger 沒辦法對付 Inline function --- 怎麼對一個不存在的函式設定中斷點呢?\n\n## Guidline \n- 限制 Inline 使用的時機: 它有絕對的理由必須是 inline (template 規定?) [[Item46 需要型別轉換時請為模板定義非成員函式]]\n- 十分平淡無奇，像是 `return m_size` 這般無聊。\n\n## Library Provider 必須謹慎評估是否宣告函式為 Inline \n有關 Inline 帶來的壞處，敘述於 [[建構和解構式是 inline 的糟糕人選]]。\n\n要注意，inline 無法隨著函式庫升級而升級，一旦 inline funciton 內容有變更，Client 端所有有用到該 function 的程式都需要重新編譯。\n而若不用 inline，Client 端只需要重新 Link 即可。\n\n## Template and Inline\n\ninline function 通常一定放在 header file 裡面，因為大多數的建置環境會在編譯中做 inlining，為了把 function call 換成「被呼叫函式」本體，必須知道被呼叫函式的內容。\n\nTemplate 也通常放在 header file，因為一旦使用，Compiler 為了具現化，同樣需要知道其內容。\n\n但 inline 具現化與 template 具現化無關，不過，如果 template 的作者**希望** function 為 inline，應該明確以關鍵字 `inline` 宣告。","lastmodified":"2023-05-07T06:09:55.529193552Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/%E5%B0%87%E6%AA%94%E6%A1%88%E7%9A%84%E7%B7%A8%E8%AD%AF%E4%BE%9D%E5%AD%98%E9%97%9C%E4%BF%82%E9%99%8D%E5%88%B0%E6%9C%80%E4%BD%8E":{"title":"將檔案的編譯依存關係降到最低","content":"\n首先清楚此內容: [[編譯依存-宣告式、定義式與實作細節]]。\n接著，需要分清楚「被 include 的對象」與「被前置宣告的對象」。\n\n## 被 include 的對象\n1. 當需要創建某類別的物件，例如 : 要創建 member data `m_date`，則需要 include Date.hpp。\n2. 有用到 STL 物件，則直接 include STL 函式庫。\n\n對於 STL 函式庫，應該用 `#include`，而不是使用前置宣告。include 標準函式庫的 header file 幾乎不會造成編譯瓶頸。\n\n```c++\n// 正確做法\n#include \u003cstring\u003e\n\n// 錯誤作法\nnamespace std {\n\tclass string;\n}\n```\n\n## 被前置宣告的對象\n只要不是要創建物件，不是 STL 物件，就可以使用前置宣告解決需求!! \nSTL 物件已經經過優化，不用擔心 include 負擔。\n\n## 降低編譯依存的手法: Pimpl Idiom\n\n[[pimpl idiom (pointer to implementation)]]\n","lastmodified":"2023-05-07T06:09:55.529193552Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/%E5%B0%91%E5%81%9A%E8%BD%89%E5%9E%8B%E5%8B%95%E4%BD%9CMinimize-casting":{"title":"Item27  Minimize casting","content":"## 常見的轉型語法\n\n```cpp\n// 舊式轉型\n(T) expr; // C-style\nT(expr);  // func style\n\n// New-style/ C++ Style  casting \nconst_cast\u003cT\u003e(expr);\nstatic_cast\u003cT\u003e(expr);\nreinterpret_cast\u003cT\u003e(expr);\ndynamic_cast\u003cT\u003e(expr);\n```\n\n- `dynamic_cast`: 安全向下轉型 (safe downcasting)，是一個可能耗費重大執行成本的轉型動作\n- `static_cast`: 強迫隱式轉換，像是 non-const to const, int to double...，但不能做 const to non-const.\n- `const_cast`: 唯一可以做到 const to non-const.\n\n即使舊式轉型依然有用，通常建議用新式，好處是\n1. 容易在程式碼中被搜尋\n2. 意圖窄化，像是如果想移除 constness，則必須使用 const_cast，其他都不會通過編譯。\n```cpp\nconst int a = 1;\nint b = static_cast\u003cint\u003e(a); // fail\nint b = const_cast\u003cint\u003e(a); // ok\n```\n\n\n## 不是圖臆測轉型的 Pointer 如何實作\n\n在某些語言中，Drived Class 轉成 Base Class 在 Pointer 上只是一個 Offset。但在 C++ 中，Pointer 是怎麼「算」出來的取決於 Compiler。不要試圖「猜」要抓哪個 Address，相當於 Casting，該用 `static_cast` 就乖乖用。\n\n\n## 常見的轉型誤用: 試圖使用 Casting 以呼叫 Base Class 方法\n有些框架要求 Drived Classes 的 Virtual func 實作時，要先呼叫 Base Class 的對應函式。\n在 Python 中，呼叫 Parent 的方法可以使用 `super()`，在 C++ 中，直接在 Drived Class 當中，使用 Base Class 的名稱空間以呼叫 Base Class 方法! \n\nExample: \n```cpp\nclass Window {\npublic:\n\tvirtual void onResize;\n}\n\nclass SpecicalWindow: public Window {\npublic: \n\tvirtual void onResize() {\n\t\t// 錯誤作法\n\t\tstatic_cast\u003cWindow\u003e(*this).onResize();\n\t\t// 正確做法\n\t\tWindow::onResize();\n}\n```\n\n錯誤方法的呼叫，相當於\n```cpp\nWindow tmp = static_cast\u003cWindow\u003e(*this);\ntmp.onResize();\n```\n\n## Dynamic Cast\n\n### 效率問題\n`dynamic_cast` 有嚴重的效率問題，多重繼承/深度繼承越多，效率成本越大。\n某些時候採用它有必要的原因: 需要支援動態連結。\n\n## 如何避免使用?\n### Dynamic Cast 的使用場合\n手上握有一個 base class pointer/reference，但你認定這個 base class pointer 所指向的對象是某一個 dirved classs。\n\n### Solution1 使用 Type-Safe Container\n同樣接續上例的 `Window`\n\n```cpp\n\nstd::vector\u003cWindow\u003e winPtrs;\n\ntypedef std::shared_ptr\u003cSpecialWindow\u003e SPW;\nSPW sp_ptr;\nsp_ptr = *winPtrs.begin();\n```\n\n\u003e [!question] \n\u003e 1. 這裡本質不還是 static cast?\n\u003e 2. 如何保證 type 正確?? container 有測試?\n\n### Solution2 在 Base Class 撰寫對應的 Virtual Func\n[[Item34 Differentiate between inheritance of interface and inheritance of implementation]]\n\n```cpp\nclass Window {\npublic:\n\tvirtual void onResize;\n\tvirtual void blink() {};\n}\n\nclass SpecicalWindow: public Window {\npublic: \n\tvirtual void onResize() {...};\n\tvirtual void blink() {\n\t\t// implement!!\n\t};\n}\n```\n\n","lastmodified":"2023-05-07T06:09:55.529193552Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/%E5%B7%A5%E5%BB%A0%E5%87%BD%E5%BC%8F-Factory-Function":{"title":"工廠函式 (Factory Function)","content":"\u003e Factory method pattern enables us to create an object without exposing the creation logic to the client and refer to the newly-created object using a common interface. It is one of the most widely used creational patterns.\n\u003e This pattern is also known as the Virtual Constructor.\n\n\nhttps://dzone.com/articles/factory-method-design-pattern","lastmodified":"2023-05-07T06:09:55.529193552Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/%E5%BB%BA%E6%A7%8B%E5%92%8C%E8%A7%A3%E6%A7%8B%E5%BC%8F%E6%98%AF-inline-%E7%9A%84%E7%B3%9F%E7%B3%95%E4%BA%BA%E9%81%B8":{"title":"建構和解構式是 inline 的糟糕人選","content":"\n考量以下例子:\n```cpp\nclass Base {\npublic:\n...\nprivate:\n\tstd::string bm1, bm2; // base members 1 and 2\n};\nclass Derived: public Base {\npublic:\n\tDerived() {} // Derived’s ctor is empty — or is it?\n...\nprivate:\n\tstd::string dm1, dm2, dm3; // derived members 1–3\n};\n```\n建構式 `Derived::Derived` 乍看內容是「空的」很適合 inlining?\n\n別忘了，物件產生的時候，每一個 Base Class、每一個成員變數的 constructor 都會被呼叫，反之，物件被銷毀時，destructor 也會依序呼叫。\n\n這些動作並非憑空發生，Compiler 在編譯期間會代為產生，並安插到程式碼中，彷彿以下內容就是 Compiler 代為成生的 (這並非實際會生成的，編譯器會更精巧的處理 exception)。\n\n```cpp\nDerived::Derived() // conceptual implementation of\n{ // “empty” Derived ctor\n\tBase::Base(); // initialize Base part\n\ttry { dm1.std::string::string(); } // try to construct dm1\n\tcatch (...) { // if it throws,\n\tBase::~Base(); // destroy base class part and\n\tthrow; // propagate the exception\n}\ntry { dm2.std::string::string(); } // try to construct dm2\ncatch(...) { // if it throws,\n\tdm1.std::string::~string(); // destroy dm1,\n\tBase::~Base(); // destroy base class part, and\n\tthrow; // propagate the exception\n}\ntry { dm3.std::string::string(); } // construct dm3\ncatch(...) { // if it throws,\n\tdm2.std::string::~string(); // destroy dm2,\n\tdm1.std::string::~string(); // destroy dm1, \n\tBase::~Base(); // destroy base class part, and\n\tthrow; // propagate the exception\n}\n}\n```\n\n但從本例我們可以看到，`Derived::Derived` 會去呼叫 `Base::Base` ，如果試圖對 `Derived::Derived` 做 `inline`，Compiler 會檢視 `Derived::Derived` 所呼叫的 funciton，決定 `Derived::Derived` 是否有被 `inline` 的資格。\n\n如果每一個在 `Derived::Derived` 當中被呼叫的都是 inlined function .... 讓我們一一檢視這件事\n\n- 假設 std::string constructor 是 inline function。\n- `Base::Base` 被宣告 inline ，它要呼叫 `bm1`, `bm2` 兩次 std::string constructor。\n- `Derived::Derived`: 被宣告 inline ，光是自己的 member data (不含 base) 要呼叫 `dm1`, `dm2`, `dm3` 三次 std::string constructor。\n\n`Derived::Derived` 總共要呼叫 5次 std::string constructor，一旦宣告成 inline，std::string constructor code 會插入**5份**在 `Derived::Derived` !!\n\n\n\n","lastmodified":"2023-05-07T06:09:55.529193552Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/%E6%80%9D%E7%B6%AD%E8%AA%A4%E5%8D%80-%E7%89%A9%E4%BB%B6%E5%BE%88%E5%B0%8F%E5%B0%B1%E5%8F%AF%E4%BB%A5-Pass-By-value":{"title":"思維誤區-物件很小就可以 Pass By value","content":"有三個主因: \n1. 並非「該物件/container」**看起來**很小，用 Pass by value 就沒有問題。許多  STL Container 在實作上的大小也就一個 Pointer 大一點，但 Copy Container 卻有「複製每一個 Pointer 所指向的物件」的風險在。\n2. 視 Compiler 而定，有些 Compiler 對待 Custom class 跟 built-in class 的態度大不相同，即使底層表述(underlying representation) 相同，仍可能以不同的操作對待，導致 Copy 在 Custom Class 就是比較慢。\n3. Type 實作可能發生改變，現在 Copy 的代價不昂貴，不代表以後不會。\n\n## Pass By Value 的代價\n[[The Copying in Pass by value]]\n","lastmodified":"2023-05-07T06:09:55.529193552Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/%E6%89%93%E7%A0%B4-Constness-%E9%99%90%E5%88%B6":{"title":"打破 Constness 限制","content":"\n### Physical Constness\n\u003e 編譯器堅守的觀點: Physical Constness，又稱 Bitwise constness。Const member function 不可以修改任何 non-static member data。\n\n然而，請看下例: `operator[]` 確實不會更動到 member data，可以通過 Bitwise Testing，卻把「改動權」暴露給 Client 端，造成不應該的賦值行為。\n- [[避免傳回 Handles 指向物件的 Private \u0026 Protected Member Data]]\n\n```cpp\nclass CTextBlock {\n\npublic:\n    // inappropriate (but bitwise const) declaration of operator[]\n    char\u0026 operator[](std::size_t position) const\n    { return pText[position]; }\n    \nprivate:\n    char *pText;\n}\n\nconst CTextBlock ctb(\"World\");\nctb[0]='F'; // Become \"Forld\"\n```\n此例應該將回傳型態修改為 `const char\u0026`。\n\n編譯器堅守的 Bitwise constness 觀念，造成 Const Function 作用過於綁手綁腳，甚至在 Const \u0026 Non-Const function 之間我們可能需要 Own 兩份相似的 Code! \n接下來將說明 `mutable` 與 const cast，他們將幫助我們破除 const 的限制，使程式設計更加靈活。\n\n### Logical Constness\n\u003e 概念上的常數性 (Conceptual Constness)\n\n我對這個論點的解讀是，某些 data 是藏於封裝底下，沒有暴露給 User 修改的。這種 member data 在 logical constness 的觀念下是可被修改的。\n書中舉例，若我們在 `CTextBlock` 當中有一個快取 (cache) 的 member data ，用來記當前字串的長度。當字串沒有修改長度的行為(增加/減少)時，此快取都是有效的。但若有修改行為，則在 `length()` 被 Query 時，我們會需要更新這個快取。\n\n在 Bitwise Constness 的觀念下，修改這個快取用途的 member data 是不合法的，且這也是 Compiler 的觀點。\n解決辦法是，使用關鍵字 `mutable` 宣告這些有資格在 const function 內被改動的 data，`mutable` 使得 const function 在實踐上有討價還價的空間。\n\n\u003e `mutable` 釋放 non-static member data 的 bitwise constness 約束 (釋放 member data 的不可變動性)。\n\n\n### Avoiding Duplication in const and Non-const Member Functions\n\u003e 當 const 和 non-const member function 有等價的實作時，讓 non-const 呼叫 const 可以避免 duplicated code。\n\n若我們在 const \u0026 non-const function 當中，都有相同的程序要做: 邊界檢查、write log、verty data...，即使子步驟都可以抽出來，還是造成「走 flow 的流程」會重複在兩個 function 當中。\n\n```cpp\nclass TextBlock \n{\n\tconst char\u0026 operator[](std::size_t position) const;\n\tchar\u0026 operator[](std::size_t position);\n}\n```\n\n我們該做的是，把所有的東西寫在其中一個，而另一個去呼叫寫著 flow 的 function。這說明了我們的一個需求: 去除 Constness!\n\n我懷疑這個手法在 C++11 \u0026 14 可能有其他解，這裡先跳過細究。簡單來說就是透過 `const_cast` 將 const function 的結果再轉成非 const。\n\n```cpp\nclass TextBlock {\npublic:  \n\t// same as before\n    const char\u0026 operator[](std::size_t position) const {\n        return text[position];\n    }\n\t// now just calls const op[]\n    char\u0026 operator[](std::size_t position) \n    {\n        // cast away const on op[]’s return type\n        // add const to *this's type, call const version of op[]\n        return const_cast\u003cchar\u0026\u003e(\\\n\t        static_cast\u003cconst TextBlock\u0026\u003e(*this)[position]\n\t\t);\n    }\n};\n```\n ","lastmodified":"2023-05-07T06:09:55.529193552Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/%E7%82%BA%E4%BB%80%E9%BA%BC%E8%A6%81%E7%94%A8%E7%8D%A8%E7%AB%8B%E5%8F%A5%E5%B0%87%E7%89%A9%E4%BB%B6%E6%94%BE%E5%85%A5-Smart-Pointer":{"title":"為什麼要用獨立句將物件放入 Smart Pointer","content":"\u003e 盡可能確保 `new` 出來的物件，可以立即被放入 smart pointer 裡面，避免任何額外的步驟。只要有多餘的步驟，就可能因為意外而使得 smart pointer 沒有真正掌控到資源。\n\n以獨立一句話將 newed 物件加入 smart pointer，格式如下\n\n```cpp\nstd::shared_ptr\u003cWidget\u003e pw(new Widget);\nprocessWidget(pw, priority());\n```\n\n---\n\n其原因是，如果像以下寫法\n```cpp\nprocessWidget(std::shared_ptr\u003cWidget\u003e pw(new Widget), priority());\n```\n\n編譯器要做的有三件事\n1. 呼叫 `priority`\n2. 執行 `new` \n3. 呼叫 smart pointer constructor\n\n而我們無法確保這三件事的最終順序為何，必然的關係只有 「會先 `new` ，再執行 smart pointer constructor」。而 `priority` 是**可能**安插於 new 之後的。\n\n1. `new` \n2. `priority` (發生錯誤)\n3. smart pointer constructor\n\n如果不幸的，編譯器選擇這種順序，並且在把物件放入 smart pointer 之前發生了錯誤，這塊記憶體將沒有 smart pointer 協助銷毀! \n","lastmodified":"2023-05-07T06:09:55.529193552Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/%E7%82%BA%E5%A4%9A%E5%9E%8B%E7%94%A8%E9%80%94%E7%9A%84%E5%9F%BA%E7%A4%8E%E9%A1%9E%E5%88%A5%E5%AE%A3%E5%91%8A-virtual-%E8%A7%A3%E6%A7%8B%E5%BC%8F":{"title":"為多型用途的基礎類別宣告 virtual 解構式","content":"\n## 多型\n多型有個特點: Base Class 的存在是為了「經由 Base Class Interface 處置 Drived Class Object」，以下例來說， `TimeKeeper` 是一個 Polymorphic Base Class，所以持有一個 `TimeKeeper` Pointer 就可以處理 `WaterClock`, `WristWatch` 物件，這就是上面那句話的意思。\n\n```cpp\nclass TimeKeeper {\npublic:\n\tTimeKeeper();\n\tvirtural ~TimeKeeper();\n};\nclass AtomicClock: public TimeKeeper { ... };\nclass WaterClock: public TimeKeeper { ... };\nclass WristWatch: public TimeKeeper { ... };\n\nTimeKeeper* getTimeKeeper(); \n// Returned pointer may be AtomicClock, WaterClock, WristWatch\n// But they can be owned by base class \"TimeKeeper\"\n// This is polymorphy.\n```\n\n繼承與多型之間並非充分必要條件，**非所有的 Base Class 都是作為多型使用**。\n像是 [[Item47 Use traits classes for information about types]] 的 `input_iterator_tag`，繼承更像是 \"enable 某種特性\" 的用途。 \n\n\n## 多型的 Base Class 沒有 Virtural Destructor 又如何\n多型 (polymorphic) 的手法使我們可以持有 base class 的 Pointer 指向各種 child class 的實作。[[工廠函式 (Factory Function)]]  就是典型的實作。\n\n\u003e [!question]\n\u003e 為了遵守 factory function 的規矩，哪來的規矩?\n\n為了遵守 factory function 的規矩，factory function 回傳的物件必須位於 heap (在 function 中被 `new` 出來的)，被 `new` 出來的物件必須手動刪除它。\n```cpp\nTimeKeeper* ptk = getTimeKeeper();\ndelete ptk;\n```\n\n儘管 [[Smart Pointer|條款13 使用資源管理器]] 和 [[讓介面容易被使用]] 說明了依賴 client 做 `delete` 有潛在的危險跟不確定，這裡要說明的是更嚴重、更根本性的問題。\n- 我們宣告的是 **Base class pointer**，指向的是 **child class 物件**。\n- Base class 擁有一個 non-virtural 的 destructor\n- C++ 明白的告訴我們，當 child 物件經由擁有 non-virtural destructor 的 Base class pointer 持有，而這個 pointer 被刪除時，屬於 **Undefined behavior**\n\n此 Undefined Behavior **通常**會發生的是，屬於 Base class 部分成功銷毀，只屬於 Child Class 的 member data **沒有被銷毀**，造成**部分銷毀**的詭異狀況。\n\n要消除這種作法的解答就是，給 Base class 的 destructor 設置 `virtural`。\n\n\u003e 一個 Class 若有帶有 `virtural` 的函式，幾乎可以確定**該有**會帶有 `virtural` 的 destructor。如果一個 class 不帶有 `virtural` function，通常代表它不意圖被當作 base class。\n\n (實作都寫完在 base 了，還特意搞繼承 override 幹嘛?)。然而，`virtural` 也不應該亂用: [[Do not Declare Virtural Function in Non-polymorphic Base Class]]。\n\n## 企圖以多型設計架構前，檢查 Base Class 的 Destructor 是否為 Virtual\n\n如果不是 virtural destructor，請想別的辦法!! \n接續前面章節，**並非** class 中沒有 `virtural` function，**就不需要** 考慮 non-virtural destructor 的問題。\n\n以例子來說，若有個 `SpecialString` 繼承 `std::string` (non-virtural destructor)，在 `new` 一個 `SpecialString` 之後指給 `std::string` pointer 之後就會遇到 Undefined Behavior 的問題! \n\n```cpp\nSpecialString *pss = new SpecialString(\"Impending Doom\");\nstd::string *ps;\n\nps = pss;\ndelete ps; // undefined behavior\n```\n\n同樣需要注意的如 `std::vector`, `std::list`, `tr1::unordered_map` ([[Item55 Familiarize yourself with Boost]]) 等。如果你想繼承一個 STL container，但它沒有 virtural destructor，請千萬不要嘗試繼承它! 這只會帶來災難。\n\n## 想要一個抽象類嗎\n想要一個抽象類，卻苦於沒有人選(function)「被 virtural」? 考慮 Destructor 吧: [[Pure Virtual Destructor]]\n\n\n","lastmodified":"2023-05-07T06:09:55.529193552Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/%E7%82%BA%E7%95%B0%E5%B8%B8%E5%AE%89%E5%85%A8-Exception-safe-%E8%80%8C%E5%8A%AA%E5%8A%9B%E6%98%AF%E5%80%BC%E5%BE%97%E7%9A%84":{"title":"為異常安全 (Exception-safe) 而努力是值得的","content":"\n## 異常安全的條件\n1. 不洩漏任何資源\n2. 不允許資料敗壞\n\n## Bad Case\n\n先看一個很糟糕的例子: \n```cpp\nclass PrettyMenu {\npublic:\n...\nvoid changeBackground(std::istream\u0026 imgSrc); // change background\n... // image\nprivate:\n Mutex mutex; // mutex for this object \nImage *bgImage; // current background image\nint imageChanges; // # of times image has been changed\n};\n\nvoid PrettyMenu::changeBackground(std::istream\u0026 imgSrc)\n{\nlock(\u0026mutex); // acquire mutex (as in Item 14)\ndelete bgImage; // get rid of old background\n++imageChanges; // update image change count\nbgImage = new Image(imgSrc); // install new background\nunlock(\u0026mutex); // release mutex\n}\n```\n\n1. 不洩漏任何資源: 第 17 行，一旦 `new` 過程中拋出 exception，第 18 行就不會執行，mutex 永遠不會 unlock。\n\t- 可透過 smart pointer 管理 heap-based 資源 (created by `new` ) 洩漏問題。\n\t- 使用 [[Mutex]] 的 `Lock` 確保離開 `changeBackground` 之後，mutex 就會自動解鎖。\n```cpp\nvoid PrettyMenu::changeBackground(std::istream\u0026 imgSrc)\n{\nLock ml(\u0026mutex); // from Item 14: acquire mutex and ensure its later release\ndelete bgImage;\n++imageChanges;\nbgImage = new Image(imgSrc);\n}\n```\n\n2. 不允許資料敗壞: 一旦 `new Image(imgSrc)` 的過程拋出 exception\n\t1. `bgImage` 會指向一個已經刪除的物件\n\t2. image 沒有創建成功，`imageChanges` 記數卻已經加上去。\n在解決資料敗壞問題之前，先導入 exception safe 的保證\n\n## Exception-Safe Functions\n必須提供三者之一\n1. 基本承諾: \n\t- 如果異常被拋出，程式的任何資料都處於有效的狀態 (只要有效即可，不保證是哪一個 status)。\n\t- 程式內任何的資料、狀態仍處於前後一致的狀態 -- 但現實中有些不可能，舉例上面的程式，當 `changeBackground` 拋出 exception 時，`PrettyMenu` 物件要使用哪一種背景? 預設背景? 原背景? Client 端需要 query 才知道。\n2. 強烈保證: 如果異常被拋出，呼叫者的程式狀態不改變。呼叫異常安全函式者會知道: 函式成功則完全成功，失敗則程式回到「呼叫函式」之前。\n\t- 這種保證比基本承諾好，Client 不用猜測「合法狀態」是哪一種狀態。\n3. 不拋擲 (nothrow) 保證: 承諾決不拋出異常，內建型別 (int, pointer) 身上的所有操作都屬於此類。\n\t- 要注意，Empty exception specification 不是 nothrow 函式，而是如果此函式拋出異常，將是嚴重的錯誤，會有意想不到的函式 (搜尋 C++ 文件 `set_unexpected`) 被喚起。\n\t- [[Modern C++ nothrow]]\n```cpp\nint doSomething() thorw(); // empty exception specification\n```\n\n\u003e [!todo]\n\u003e P132\n\n\n\n\n\n\n\n\n\n\n","lastmodified":"2023-05-07T06:09:55.529193552Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/%E7%95%B6%E6%89%80%E5%87%BD%E5%BC%8F%E6%89%80%E6%9C%89%E7%9A%84%E5%8F%83%E6%95%B8%E9%83%BD%E9%9C%80%E8%A6%81%E5%9E%8B%E5%88%A5%E8%BD%89%E6%8F%9B%E6%8E%A1%E7%94%A8-Non-member-Function":{"title":"當所函式所有的參數都需要型別轉換，採用 Non-member Function","content":"\n讓 Class 支援隱式轉換通常不是好事 -- 但也有例外，最常見的就是數值型別。書中以有理數 `Rational` 為例，他設計了一個允許 Int 隱式轉換成 Rational 的 Constructor。\n```cpp\nclass Rational {\n    public:\n        Rational(int numerator=0, int denominator=1); \n        // 允許 int-to-Rational 的隱式轉換\n\n        int numerator(); // 分子\n        int denominator(); // 分母\n        const Rational operator*(const Rational rhs) const;\n}\n```\n\n當實作乘法運算時，若兩個數字都是有理數沒有問題。與 Int 相乘，Int 在前項卻出了問題。\n```cpp\nRational oneEight(1, 8);\nRational oneHalf(1, 2);\n\nRational res = oneEight*oneHalf; // OK\nres = res*oneEight; // OK\n\n# eq3\nres = oneHalf*2; // OK: oneHalf.operator*(2)\n# eq4\nres = 2*oneHalf; // Error: 2.operator*(oneHalf)\n```\n在 eq4 會錯誤是因為，乘法隱含的是\n1. 尋找 `2` 的 `operator*`，但這不存在 (2 沒有對應的 class)\n2. Compiler 嘗試尋找 Namespace 下或 global scrope 下， Signature 能相配合的 `operator*`，也就是嘗試 `res = operator*(2, oneHalf)` 能否成立。但這也找不到而\n3. 沒招了，引發 error。\n\n而 eq3 能成功是因為 Compiler 嘗試先呼叫 `oneHalf.operator*`，2 在傳進去時會因為 Rational 接受隱式轉換 (implicit type conversion)，而若 constructor 限定要 explicit type conversion，甚至會連 eq3 都不過! \n\n## 只有列於參數列 (Parameter List) 才能參與隱式轉換\n\n綜合 eq3, eq4 所述，只有當 `int` 列在 `Rational` 物件後面，也就是成為 `Rational::operator*`  的 Parameter List，才是隱式轉換的合格參與者。\n\n## 解法:以 Non-member Function 定義 operator*\n只要將 `operator*` 拆離 class `Rational`，讓 operator 的兩個參數 `lhs` \u0026 `rhs` 都有參與隱式轉換的資格，那麼 eq3 和 eq4 就都可以通過了!\n甚至，這個 non-member function 也不需要定義為 friend，因為光透過 Rational 的 Public interface 就可滿足一切需求了! \n\n```cpp\n\nclass Rational {\n    ...\n};\n\nconst Rational operator*(const Rational\u0026 lhs, const Rational\u0026 rhs) {\n    return Rational(lhs.numerator()*rhs.numerator(), \\\n\t\t\t\t\tlhs.denominator()*rhs.denominator());\n}\n```\n\t\n","lastmodified":"2023-05-07T06:09:55.529193552Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/%E7%9B%A1%E5%8F%AF%E8%83%BD%E5%BB%B6%E5%BE%8C%E8%AE%8A%E6%95%B8%E5%AE%9A%E7%BE%A9%E5%BC%8F%E7%9A%84%E5%87%BA%E7%8F%BE%E6%99%82%E9%96%93":{"title":"盡可能延後變數定義式的出現時間","content":"\n\u003e 不只延後變數的定義式的出現，甚至該嘗試延後這份定義直到能夠給它初始值引數為止。\n\n- 盡可能延後參數的定義，直到它被使用的前一刻再定義。\n\t- 過早的定義它，有可能根本沒用到就先 return 了，無謂的承受了該變數的 construct \u0026 destruct 成本。\n- 「前一刻」甚至是指: 得到初始值了再一口氣「建構並指定初始值」\n\n```cpp\nstd::string worstCase(const std::string\u0026 password) {\n\tstd::string encrypted;  // 過早宣告: 承受建構成本\n\tif (password.length() \u003c 8 ) {\n\t\treturn;  // 沒用到卻承受解構成本\n\t}\n\treturn encrypted(password); \n}\n\n// worse: 先定義、再給值\nstd::string encrypted;  // default constructor\nencrypted = password;   // copy assignment.\n\n// better: 最好在定義時就給值，只要呼叫一次 constructor\nstd::string encrypted(password); \n\n\n```\n\n## 迴圈怎麼辦\n\n採取方法 A 或 B 取決於\n1. 知道賦值成本 \u003c (建構+解構)\n2. 程式碼 Performance-sensitive\n否則，通常選 B 比較好。\n\n- 方法A: 先宣告，在迴圈中賦值\n\t- 1 ctor + 1 dtor + n 個賦值\n\t- 優點: 當 Class 賦值成本低於建構+解構，A方法比較高效，特別是 n 很大時。\n\t- 缺點: Variable Name Scope 比較大\n\n- 方法B: 在迴圈中創建\n\t- n ctor + n dtor\n\t- 除非滿足上述的兩個條件，否則通常此方法比較好，變數名稱影響的範圍只在 For Loop 當中。\n\n```cpp\n// Method A\nWidget w;\nfor (int i=0; i \u003c n; ++i) {\n\tw = ...;\n}\n\n// Method B\nfor (int i=0; i \u003c n; ++i) {\n\tWidget w(...);\n}\n```","lastmodified":"2023-05-07T06:09:55.529193552Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/%E7%B7%A8%E8%AD%AF%E4%BE%9D%E5%AD%98-%E5%AE%A3%E5%91%8A%E5%BC%8F%E5%AE%9A%E7%BE%A9%E5%BC%8F%E8%88%87%E5%AF%A6%E4%BD%9C%E7%B4%B0%E7%AF%80":{"title":"編譯依存-宣告式、定義式與實作細節","content":"\n分辨以下三個名詞\n- 宣告式: 僅僅宣告某個類別名稱(?)\n- 定義式: 定義物件的 member data、function，透過定義式可以得知物件的大小\n- 實踐細節: 演算法細節。\n\n```cpp\nclass Date; // 宣告式\nclass Person {\npublic:\n\tPerson(const std::string\u0026 name, const Date\u0026 birthday,\n\tconst Address\u0026 addr);\n\nprivate: // ptr to implementation;\n\tstd::tr1::shared_ptr\u003cPersonImpl\u003e pImpl; // see Item 13 for info on\n};\n```\n\nCompiler 在編譯期間需要知道物件的大小，如下例。Compiler 可以輕鬆知道 built in type `int`的大小，但 `Person` 呢? 這得向它的定義式詢問要配多少空間。因此，會需要 `include person.hpp` \n```cpp\n#include \u003cperson.hpp\u003e\n\nint main()\n{\n\tint x; // 定義一個 int object\n\tPerson p(params) // 定義一個 Person object\n}\n```\n\n### 能用 object reference/pointer 就不要 own 一個 object。\nReference \u0026 Pointer 都可以 forward declare，宣告一個 object 卻必須 include header file (取得物件的定義式)。\n\n### 以宣告式取代定義式\n\n宣告一個 Function。而它要用到某個 Class的時候，都不需要該 Class 的定義。即使 Pass by value 也是!!! \n\n```cpp\nclass Date; // forward declare\n\nDate today(); // declare a function which return Date object. OK!!\nvoid clearAppointments(Date d); // Pass by value. OK!!\n```\n\n#### 即使回傳一個 object 也不需要定義式?\n在上例中，`today()` 函式回傳一個 `Date` 物件，卻不需要 include Date 的 header file? 聽起來很奇怪，但原理也極簡單。\n\n一旦有人試圖呼叫 `today()`，`Date` 的定義式需要先被曝光: 呼叫者需要先創建一個 Date 物件來接住 `today()` 的回傳值! 這個 include 的責任交給呼叫者就好。\n\n試想，這份 header file 並非每個人都要用到 `today()` 函式，導入 `Date.hpp` 就會增加依賴性。但，要呼叫 `today()` 的人**必須**導入 `Date` 的定義式 (hpp)，所以 include 可以交給 Client 端就好! \n\n### 為宣告式與定義式提供不同的 header file\n程式庫的提供者應該把宣告式和定義式分開，讓客戶端導入要用到的 header file 即可。\n接續前面的例子，當 Client 端想宣告 `today` 時，應該 `include  \"datefwd.h\"`，而非手動作 forward declaration，這是 Provider 必須提供的。而 `datefwd.h` 這個命名方式，則是跟 STL 的 [`iosfwd`](https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/std/iosfwd) 相同。\n\n```cpp\n#include \"datefwd.h\"\n\nDate today(); // declare a function which return Date object. OK!!\nvoid clearAppointments(Date d); // Pass by value. OK!\n```\n\nSTL 所提供的 `iosfwd` 包含了來自 `sstream, iostream, fstream ...` 多個 header file 的 forward declaration，也就是說，他們的定義式實際散在多個 header file ，但  forward declaration 集中放在同一個 header file。\n\n\n\n\n\n\n","lastmodified":"2023-05-07T06:09:55.529193552Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/%E8%A7%A3%E6%A7%8B%E5%BC%8F%E8%88%87%E7%95%B0%E5%B8%B8":{"title":"解構式與異常","content":"\n## 情境: 當Destructor 必須執行某項會丟Exception 的程序\n舉例，我們有一個資料庫連線的 class `DBConnection`，這類資源管理的 Class 在 [[Chapter3]] 中會有更詳細的探討。\n```cpp\nclass DBConnection {\npublic:\n...\nstatic DBConnection create();   // function to return DBConnection objects; params omitted for simplicity\nvoid close(); \n// close connection; throw an exception if closing fails\n};  \n```\n\n\n### 直接 Catch Exception\n為了防止 client 沒有 close connection 就直接刪除物件，我們需要在 destructor 呼叫 `close`，然而這個 function 有丟出 exception 的風險。\n有兩種做法可以簡單的解決\n1. 使用 `std::abort` 提前中止程式，它可以搶在 Exception 傳出去之前，也就是 Undefined Behavior 傳出去之前，強迫程式結束。\n\t```cpp\nDBConn::~DBConn() {\n\ttry { db.close(); }\n\tcatch (...) {\n\t\t// make log entry that the call to close failed;\n\t\tstd::abort();\n\t}\n}\n\t```\n2. 吞下異常。一般來說，這是個壞主意，它抑制了錯誤被知道的機會。\n\t```cpp\nDBConn::~DBConn() {\n\ttry { db.close(); }\n\tcatch (...) {\n\t\t// make log entry that the call to close failed;\n\t}\n}\n\t```\n\n哪種方法好，端看情境如何取捨。不過此兩者做法都不是根本解決之道。\n\n## 解決方法: 讓 Cilent 自己接住 Exception\n更好的做法是重新設計 Interface，讓 client 端自己 `close`，對 Exception 做反應。並在 destructor 當中再設一道確保關閉的雙重保障 -- 如果客戶還是忘了關，再讓 destructor 動手吧! \n\n\n## 質疑\n- 轉移責任到 Client 身上的嫌疑? 並沒有，因為 destructor 中也是有一道 Check。\n- 違反[[讓介面容易被使用]]? \n\n如果某個操作有 raise exception 的風險，又必須處理該 exception，這個異常必須來自 destructor 之外的某個 function (此例: 來自 `close`)，而這有讓 client 端接手的必要性，將它轉移出 destructor 能避免 undefined behavior 的發生有更大的價值。\n","lastmodified":"2023-05-07T06:09:55.529193552Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/%E8%A8%AD%E8%A8%88%E6%96%B0-Class-%E7%9A%84%E6%BA%96%E5%89%87":{"title":"設計新 Class 的準則","content":"在設計 class 之前，思考以下問題\n- 記憶體如何產生跟銷毀? (參見第八章)\n- 物件初始化與賦值的差別? Constructor \u0026 Assignment\n\t-  [[Effective C++ Outline#條款4 確定物件在使用前已經初始化 |條款4 確定物件在使用前已經初始化]]\n- Pass by value 對它代表甚麼? Copy constructor\n- Member data 的合法值?\n\t- 在不管是 constructor, assignment, setter function 在設 data 時，都需要進行錯誤檢查。\n\t- 這意味著你需要考量函式拋出的意外。\n- 它需要配合某個繼承圖系(inheritance graph) 嗎?\n\t- 會受到父輩們的約束，特別是函式是 virtural or non-virtual [[Item34 Differentiate between inheritance of interface and inheritance of implementation]]、[[Item36 Never redefine an inherited non-virtual function]]。\n\t- 如果允許其他類別繼承此 class，請將必要的函式宣告為 virtual，特別是 destructor。\n\t\t- [[Effective C++ Outline#條款7 為多型用途的基礎類別宣告 virtual 解構式|條款7 為多型用途的基礎類別宣告 virtual 解構式]]\n- 需要考量轉換嗎? 隱性轉換與顯性轉換?\n- 甚麼運算子與函式對此新類別式合理的?\n\t- [[Non-member \u0026\u0026 Non-friend Function 的封裝度優於 Member Function]]\n\t- [[當所函式所有的參數都需要型別轉換，採用 Non-member Function]]\n\t- [[盡可能延後變數定義式的出現時間]]\n- 什麼標準宣告式是需要駁回的? 請用 `delete` 明確刪除它。\n- 哪些 member 需要暴露出來? (public/private/protected)\n- 什麼是它的未宣告介面(undeclared interface)?\n\t- 這我看不懂。\n- 這個新的 class 有多一般化? 若要定義的是 type family (一堆 type) ，是否該採用 class template?\n- ","lastmodified":"2023-05-07T06:09:55.529193552Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/%E8%AE%93%E4%BB%8B%E9%9D%A2%E5%AE%B9%E6%98%93%E8%A2%AB%E4%BD%BF%E7%94%A8":{"title":"Item 18 Make interfaces easy to use correctly and hard to use incorrectly","content":"\n## 用 `struct` 包覆簡單的資料結構可以帶來可讀性\n\n考量下面的例子: \n\n```cpp\nclass Date {\npublic:\n\tDate(int month, int day, int year);\n}\nDate(3, 31, 1999); // 正確\nDate(30, 3, 1999); // 可能會誤打\nDate(3, 40, 1999); // 可能有無效值\n```\n\n如果我們改以 `struct`如下，你幾乎不會犯下寫錯格的錯，Compiler 會自動提醒! 甚至可以在 Struct 內簡單的做數值檢驗。\n\n```cpp\nstruct Month;\nstruct Day;\nstruct Year;\n\nclass Date {\npublic:\n\tDate(Month m, Day d, Year y);\n}\n\nDate(Month(3), Day(31), Year(1999)); // 正確\nDate(Day(3), Month(31), Year(1999)); // 型別錯誤\n```\n\n\n## 以函式取代物件\n\n像是月份這樣有一定的範圍，甚至可以直接列舉 12 月份，Client 端透過介面得到月份物件，幾乎沒有錯誤數值的問題!!\n\n類似用法可以參見 [[Static Object]] 當中的 non-local static object 初始化問題。\n\n```cpp\nclass Month {\npublic:\n\tstatic Month Jan() {return Month(1)};\n\tstatic Month Feb() {return Month(2)};\n\t...\nprivate:\n\texplicit Month(int m);\n}\nDate(Month::Jan(), Day(30), Year(1999));\n```\n\n## 和內建型別的行為一致，不要搞怪\n\n當有和 STL lib 相似的屬性時，盡量用一樣的形式。\n\n## 任何介面如果有要求客戶「記得做」某件事，就有「不正確使用」的傾向，因為客戶可能會忘記。\n\n例如: 比起回傳一個 raw pointer 並期許客戶端記得刪除記憶體，回傳 smart pointer 能解決問題。\n\n防範客戶端可能發生的錯誤是有代價的，像是 Shared pointer，它比原本的體積更大、且更慢。但在許多程式中這些成本的影響並不顯著，防範客戶端愚蠢行為帶來的益處卻極為顯著。\n\n\n## Return Const Value\n避免回傳值被修改，如此例中，類別 `Rational` (有理數) 的乘積符號禁止其回傳值被賦予值 (assignment)。\n\n```cpp\nclass Rational { ... }; \nconst Rational operator*(const Rational\u0026 lhs, const Rational\u0026 rhs);\n```\n\n聽起來有點怪，但它可以預防 client 端寫出這種 code: \n```cpp\nRational a, b, c;\n(a*b) = c;\n\nif (a*b = c) { ... };\n```\n\n我想，作者的舉這個例子有 Defensive programming 的概念在。如若這些變數是內建型別 (ex. int)，這種寫法直接就會被擋掉。但像此例，它們是 User-defined 的型別，對於設計 class 的 designer 而言，最好將這種無意義的行為擋掉。","lastmodified":"2023-05-07T06:09:55.529193552Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/%E9%81%BF%E5%85%8D%E5%82%B3%E5%9B%9E-Handles-%E6%8C%87%E5%90%91%E7%89%A9%E4%BB%B6%E7%9A%84-Private-Protected-Member-Data":{"title":"避免傳回 Handles 指向物件的 Private \u0026 Protected Member Data","content":"\n\u003e 消滅 handles 的暴露可能\n\n\n## 大忌: 回傳一個 Non-Const handles \n在 [[打破 Constness 限制#Physical Constness]] 當中，我們探討過 Physical (bitwise) Constness 的問題。\n讓 Getter 回傳一個 non-const reference 指向 member data，會出現讓 private data 暴露在外 (等同於 public) 的詭異現象。\n此問題不限於 ref，pointer、iterator 這些 handles (用以取得某個物件)，都有相同的風險。\n\n## 回傳一個 Const Handles 就沒問題了嗎?\n\n```cpp\nstruct RecData {\n\tPoint ulhc;\n\tPoint lrhc;\n}\n\nclass Rectangle {\npublic:\n\tconst Point\u0026 upperLeft() const {return pData-\u003eulhc;}\n}\n\nclass GUIObj;\nconst Rectangle bbox (cosnt GUIObj\u0026 obj);\n\nGUIObj* pgo;\nconst Point* pUpperLeft = \u0026(bbox(*pgo).upperLeft()); // dangling\n```\n\n此例的第 15 行，\n1. 相當於先創建了 `tmp = bbox(*pgo*)`\n2. 對 `tmp.upperLeft()`取得一個 `const Point\u0026` 內部資料 ``\n3. 對此內部資料取 address，傳給 `pUpperLeft`\n4. 15 行執行完畢，`pUpperLeft` 直接變成 dangling pointer\n\n最大的問題是，**handles 比其所屬的物件更長壽**!! 最簡單的就是消滅 handles 的暴露可能。\n\n但並不意味不能回傳 handles，有時是必須的，像是 `operator[]` 就必須回傳 reference 指向 container 內部元素。\n\n\n\n\n\n[[Effective C++ Outline#條款3 盡可能使用 const]]\n","lastmodified":"2023-05-07T06:09:55.529193552Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/Const-in-C++":{"title":"Const in C++","content":"\n#### Const Iterator\n同理上述，宣告一個 iterator 為 `const` 表示這個 iterator 不能改變指向的對象，但是指向的對象之內容本身可以變。 \n```cpp\nconst std::vector\u003cint\u003e::iterator iter = vec.bgein();\n```\n如果想要指向一個不可被改變內容的物件，需要使用 `const_iterator`\n```cpp\nstd::vector\u003cint\u003e::const_iterator citer = vec.bgein();\n```\n\n#### Return Const Value\n[[讓介面容易被使用#Return Const Value]]\n\n#### Const member function\n[[Const member function]]\n\n#### Const Argument\n在真實的程式設計中，比較多用於 function argument 是 const pointer / const referecne。\n如下例: `print` function 定義了一個 const reference 的 argument，當它在調用 operator `[]` 的時候，就會用到上面的 API。且定義 const return value 可以避免錯誤的寫入值，達成 const object 的目的。\n```cpp\nvoid print(const TextBlock\u0026 ctb) // in this function, ctb is const \n{ \n\tstd::cout \u003c\u003c ctb[0]; // calls const TextBlock::operator[] \n\tctb[1] = 'x';        // raise error!!!\n}\n```\n\n#### 打破 Constness 限制\n前面說的是對於 Client 端，我們須保持資料的不可變動性。\n\n然而在類別內部的設計中，基於維護性、或某些理念，我們希望它不要那麼死板，比起 Compiler 所堅持的 Constness，或許邏輯上的 Constness 更加重要。接下來，將說明 Compiler 認知 Constness 為何 ，與如何「部分的」打破 Const 限制。\n[[打破 Constness 限制]]\n","lastmodified":"2023-05-07T06:09:55.529193552Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/Const-member-function":{"title":"Const member function","content":"\n\u003e The purpose of const on member functions is to identify which member functions may be invoked on const object.\n\n使 Interface 意圖更加清楚，有兩個重要的優點\n1. 可知道哪個 function 會更動到物件\n2. 改善 C++ 程式效率與 \"pass by reference to const\" 息息相關，使 function 可操作 Const Object 。\n\n直接看例子: 我們定義了如下的 Interface。\n\n```cpp\nclass TextBlock\n{\npublic:\n\t// operator[] for const objects\n\tconst char\u0026 operator[](std::size_t position) const\n\t{ return text[position]; }\n\t\n\t// operator[] for non-const objects\n\tchar\u0026 operator[](std::size_t position) \n\t{ return text[position]; }\nprivate:\n\tstd::string text;\n};\n```\n\n在 Client 端，`const TextBlock` 與 `TextBlock` 物件會 call 到的  `TextBlock::operator[]` **是不同的**!! 有宣告 Interface 的第一條 (const function)，才有辦法操作 `const TextBlock` 的物件。\n```cpp\nconst TextBlock ctb(\"World\");\nstd::cout \u003c\u003c ctb[0]; // calls const TextBlock::operator[]\n\nTextBlock tb(\"Hello\");\nstd::cout \u003c\u003c tb[0]; // calls non-const TextBlock::operator[]\n```\n\n\n\u003e [!question] \n\u003e 如果宣告 Const 但是不定義 const TextBlock 會怎樣?\n","lastmodified":"2023-05-07T06:09:55.529193552Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/Copying-Function":{"title":"Copying Function","content":"\n\u003e Effective C++ 中，Copying Function 指的是 Copy construcot \u0026 Copy Assignment\n\n1. 當 Programmer 自己定義 Copying function 時，Compiler 不會警告你出錯!\n2. 在繼承的架構中\n\t1. 不只屬於 Child Class 的 member data 要全部 copy\n\t2. 還要記得 call Parent Class 的 copying function。\n\n    ```cpp\n    // Copy Construcotr \n    PriorityCustomer::PriorityCustomer(const PriorityCustomer\u0026 rhs)\n    : Customer(rhs), // invoke base class copy ctor\n    priority(rhs.priority)\n    {\n\t    logCall(\"PriorityCustomer copy constructor\");\n    }\n   \n    // Copy Assignment\n    PriorityCustomer\u0026\n    PriorityCustomer::operator=(const PriorityCustomer\u0026 rhs)\n    {\n        logCall(\"PriorityCustomer copy assignment operator\");\n        Customer::operator=(rhs); // assign base class parts\n        priority = rhs.priority;\n        return *this;\n    }\n\t\n\t ```\n\n3. Copy Constructor 與 Copy Assignment 不應該 Call 彼此，如果有 Reusable Code，應該另外抽一個 private function 去共用。","lastmodified":"2023-05-07T06:09:55.529193552Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/Default-Generated-Functions":{"title":"Default Generated Functions","content":"\n```cpp\nclass Empty; // you declare, but implement nothing. \n\n// Compiler silently create.\nclass Empty {\npublic:\n\n    Empty() { ... } // default constructor\n    Empty(const Empty\u0026 rhs) { ... } // copy constructor\n    ~Empty() { ... } // destructor — see below for whether it's virtual\n    Empty\u0026 operator=(const Empty\u0026 rhs) { ... } // copy assignment operator\n}\n\nEmpty e1;      // default constructor\n\t\t\t   // destructor\nEmpty e2(e1);  // copy constructor\ne2 = e1;       // copy assignment\n```\n\n\n- Default constructor (without parameter) \u0026 destructor\n\t- 給編譯器放一些喚起 base class, non-static member data constructor \u0026 destructor 的地方。\n\t- Compiler 生成的 destructor 是一個 non-virtural\n\t  [[為多型用途的基礎類別宣告 virtual 解構式]]\n\t- 只要有宣告 Constructor，編譯器就不會幫我們多掛 default constructor 上去。\n- Copy Constructor \u0026 Copy Assignment: 將 source 物件的每一個 non-static member data copy 過去。\n\n## Default Copy Assignment\n儘管 Copy Assignment `operator=` 也可以自動生成，卻是有條件的自動生成，只有當自動生成的代碼合法時才會生成。\n\n但 default copy assignment 常很有機會變得幾乎無用武之地。\n1. 當 User-defined Class 有 member data 是 Reference 或 `const`，自動生成的 code 會不合法。\n2. 當 base class 把 copy assignment 宣告成 private，compiler 無法喚起 parent 的 private function，直接裝死。\n\n在 C++ 當中，一旦 Reference 被宣告，是不允許改指向不同物件的，而 Compiler 更不會自動去修改 \"被 Reference 物件\" 的內容。這種情況，Compiler 會直接拒絕生成 Copy assignment。\n如果想讓一個有 reference member data 的 class 有 Copy assignment，需要自行實作。相似的，更改 `const` 成員是不合法的，需自行實作。","lastmodified":"2023-05-07T06:09:55.529193552Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/Deleted-Function":{"title":"Deleted Function","content":"\n\n```cpp\nclass A{    \npublic:\n  A(int x) : m(x) {}\n  A\u0026 operator = (const A \u0026) = delete;  // Declare the copy assignment operator\n                                       // as a deleted function.\n  A(const A\u0026) = delete;                // Declare the copy constructor\n                                       // as a deleted function.\n\nprivate:\n  int m;\n};\n\nint main(){\n  A a1(1), a2(2), a3(3);\n  a1 = a2;     // Error, the usage of the copy assignment operator is disabled.\n  a3 = A(a2);  // Error, the usage of the copy constructor is disabled.\n}\n```\n\n\n## 舊的做法\n以 C++11 為分水嶺，C++98 只能透過宣告 private 藏住不要 Compiler 生成的 function。\n確實 client code 會無法呼叫。但這並不絕對安全，因為 member function 跟 frient function 還是可以呼叫 private function。更安全的做法是，宣告 private 後故意不實作。\n","lastmodified":"2023-05-07T06:09:55.529193552Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/Do-not-Declare-Virtural-Function-in-Non-polymorphic-Base-Class":{"title":"Do not Declare Virtural Function in Non-polymorphic Base Class","content":"\n\u003e 無端將不該擁有 `virtual` 的 class 宣告 virtual，與無端將所有的 function 宣告成 virtual，都是有毒的。 \n\n當類別不作為 Base Class，或是不作為多型時的基本 Class 時，不應該使用 virtual。\n原因是，`virtual` 背後是以 vptr (virtual table pointer) 和 vtbl (virtual table) 實作 virtual，需要耗費額外的記憶體。\n1. 將不能把資料結構式傳給其他語言 (C, FORTRAN) 撰寫的 function，因為它們沒有 vptr 的對應內容\n2. 增加物件大小，書中舉例一個 `Point` 物件，其中擁有兩個 int (64bits, in 32 bits system)，增加一個 `virtual` (一個 vptr) 將使 memory 達到 96 bits，相當其物件大小的 50%，在 64bits system 甚至達到增加 100%。\n","lastmodified":"2023-05-07T06:09:55.529193552Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/Effective-C++-Outline":{"title":"Effective C++ Outline","content":"## Chapter 1\n\n### 條款1 C++ 是一個語言聯邦\nC++ 融合了多種形式的 programming 手法，物件導向、procedural、generic、metaprogramming、functional...。\n\n### 條款2 盡量以 `const` , `enum`, `inline` 取代 `#define`\n- 以 const, enum, inline 取代 `#define`， 寧可以編譯器 (compiler) 取代前處理器 (pre-processor)。 \n- 對於單純的常數，以 `const` 或 `enum` 取代\n- 對於形似 function 的巨集(macro)，用 `inline` 取代。\n#### Const\n- [[Replace define with const]]\n- [[The definition and declaration of static const]] P14\n#### Enum\n- [[enum hack]]\n#### Inline\n\n\n### 條款3 盡可能使用 const\n盡可能的使用 `const`，它可以確保物件不被改變。特別是 custom class designer 更加需要注意 operator 的 constness。\n\n- `const` 在星號左邊: 被 point 的物件是常數\n- `const` 在星號右邊: pointer 自身是常數\n```c++\nchar greeting[] = \"Hello\";\nchar* p greeting;\n\nconst char* p = gretting; // non-const ptr, const data\nchar const* p = gretting; // same \n\nchar* const p = greeting; // const ptr, non-const data\nconst char* const p = greeting; // const ptr, const data\n```\n\n當 `const` 在 `*` 前，不管是先寫 const 修飾的類、或是先寫 const 都是一樣的，就是在修飾 `char` 物件具有常數性。\n- [[Const in C++]]\n\n\n### 條款4 確定物件在使用前已經初始化\n不是所有的物件宣告時自帶初始化，它的規則過於複雜，只需要謹記: 宣告時就要初始化!\n(通常是 C-style 的，像是 array 不保證會發生初始化)，而 non-C part 的 (like `std::vector`) 有其他規則，就自帶初始化)\n\n對於內建型別 (int, char, double)，初始化就是手動給值。對於內建型別之外的，則要寫 constructor。\n\n為了避免沒有初始化帶來的不確定性，確保三件事\n1. 對於不是 member data 的 built-in type object，手動初始化。C++ 並不保證會初始化所有的 Built-in type Object (ex. array)。\n2. 對於 Custom Class，使用 [[Member Initialization List]] 初始化 member data。原因參見 [[Identify Initialization and Assignment]]\n3. 若初始化順序具有不確定性，想辦法加強 design，確保不會發生 circle (兩個變數相互依賴) 或競速問題。\n4. 當 static object 之間有依賴關係時，local static objects 勝過 non-local static objects。參見 [[Static Object]]\n\n## Chapter2 建構、解構、賦值運算\n\n### 條款5 了解 C++默默編寫並呼叫哪些函式\n\n當我們宣告了一個 Class，而不去實踐任何細節，Compiler 會偷偷地幫我們生成一些 function，他們分別是\n- default constructor, destructor\n```cpp\nEmpty() { ... } // default constructor\n~Empty() { ... }\n```\n- copy constructor, copy assignment\n```cpp\nEmpty(const Empty\u0026 rhs) { ... } // copy constructor\nEmpty\u0026 operator=(const Empty\u0026 rhs) { ... } // copy assignment \n```\n\n並且，都是 public inline function!! 關於這些 function 被 inline 會帶來什麼危害，見 [[建構和解構式是 inline 的糟糕人選]]。\n\n更確切來說，是當這些 function 被需要 (被呼叫) 時產生: [[Default Generated Functions]]\n\n### 條款6 明確拒絕不要編譯器自動生成的函式\n在 C++11 引入了新的概念 [Deleted functions](https://www.ibm.com/docs/en/zos/2.4.0?topic=definitions-deleted-functions-c11)，書中教的方法依然有其壞處。直接在 declaration 後面接著 `=delete` 就可以阻止 copmiler 生成它。\n\n```cpp\nA(const A\u0026) = delete;\n```\n\n[[Deleted Function]]\n\n### 條款7 為多型用途的基礎類別宣告 virtual 解構式\n申明，這條規則**只針對**多型的 Base Class\n- 首先就先說明多型的用意: [[為多型用途的基礎類別宣告 virtual 解構式]]\n\n### 條款8 不讓異常逃離解構式\nC++ 不會禁止 Exception 發生於 Destructor，但這麼做具有相當的風險。一旦 Exception 發生而跳出了 Destructor，會中止銷毀物件的程序。\n特別是 STL Container 或 Array 這種資料結構中，若前面有某個 element 在銷毀過程中 thorw Exception 使得 Container 的 Destructor 被中斷，則後面的 elements 有可能不被銷毀，而導致記憶體洩漏! \n\n[[解構式與異常]]\n\n### 條款9 不在建構與解構中呼叫 virtual 函式\n\n不要在 Constructor 與 Destructor 中呼叫 virtural 函式。這和 Java 與 C# 不同!!!\n\n[[Virtual Function]]\n\n\n### 條款10 讓 operator= 回傳自身的 reference\n讓 `operator=`, `operator+=` 等 assignment 符號回傳自身的 Reference。\n這是一項協議，並非強制規定。但在 STL 提供的型別，或是即將 support 的 type ([[Item54 Familiarize yourself with the standard library including TR1]])，都會遵守這個協定，請從眾。\n\n### 條款11 在 operator= 處理自我賦值\n\n在撰寫 `operator=` 時，需要考量當 `rhs==this` 的狀況。\n即使不是如下面的方式 handle 自我賦值，記住，不要讓這個函式 raise exception (exception safety) 就對了。\n\n```cpp\nWidget\u0026 Widget::operator=(const Widget\u0026 rhs)\n{\n\tif (this == \u0026rhs) return *this; // assignment to self\n\tdelete pb;\n\tpb = new Bitmap(*rhs.pb);\n\treturn *this;\n}\n```\n\n### 條款12 複製物件時記得每一個部分\n\n當 Programmer 自己定義 [[Copying function]] 時，Compiler 不會警告你出錯! 你需要自己注意!!\n\n## Chapter3 資源管理\n\n### 條款13 使用資源管理器\n\n- 資源取得的時機就是初始化的時機 (Resource Acquisition Is Initialization, [RAII](https://zh.wikipedia.org/zh-tw/RAII))\n- [[Smart Pointer]] 是個好選擇\n\n### 條款14 仔細考慮資源管理類別的 Copy 行為\n- Smart Pointer 那類的資源管理器，適合用來掌握 heap-based resource 的生命週期。\n- 並非所有的資源物件，都適合用 Smart Pointer 管理。\n- 書中以 [[Mutex]] (互斥鎖) 舉例。\n\n\u003e [!Todo]\n\u003e 1. 查一查 RAII，這整個章節我看不太懂。\n\u003e 2. 看到 P67，面對複製的問題還沒看。\n\n\n\u003e [!question]\n\u003e (此處是舊版，新版有對應的東西嗎?\n\n### 條款15 在資源管理類中提供對原始資源的存取\n\n儘管使用 [[Smart Pointer]] 管理資源很方便，我們仍有機會需要取得原始的 Pointer。Smart Pointer 同時有提供顯示介面 (explicit) 與隱式介面: \n- explicit : 以 `get` 取得 Raw Pointer。\n- implicit : `operator*`, `operator-\u003e`。\n\n### 條款16 成對的使用 `new` 和 `delete` 並採用相同型式\n1. 盡可能不要用 C-style Array\n2. STL所提供的 vector, string 等 templates 可以降低對 Array 的需求，減少錯誤的發生。\n\n\n### 條款17 以獨立的語句將物件放入 Smart Pointer\n\n```c++\nstd::shared_ptr\u003cWidget\u003e pw(new Widget);\nprocessWidget(pw, priority());\n```\n\n[[為什麼要用獨立句將物件放入 Smart Pointer]]\n\n## Chapter 4 設計與宣告\n### 條款18 讓介面容易被使用、防範誤用\n\n[[讓介面容易被使用]]\n\n### 條款19 設計 Class 猶如設計 Type\n設計 Class 請遵守準則想過一遍: [[設計新 Class 的準則]]\n\n### 條款20 以 Pass by const ref 取代 Pass by value \n\n合理的 Pass by value 幾乎只有下面三種選擇\n1. 內建型態\n2. STL Iterator \n3. Function Object\n\n除此之外，包含 STL Container 應盡可能用 Pass by const reference !\n- [[思維誤區-物件很小就可以 Pass By Value]]\n\n### 條款21 當必須回傳物件時，不要考慮回傳 Reference \n\n絕對不要\n 1. 將 Pointer 或 Reference 指向一個 local 物件回傳。\n 2. 讓 Reference 指向 heap-based object (`new`)\n 3. 當設計出「回傳 ptr/ref 指向 local static」，並且有很多個物件都採用這種形式時提高警覺，很有可能走入了 Bad design。對於怎麼樣是「合理」使用 Local static object : 參見 [[Static Object]]。\n\n\n### 條款22 將成員變數宣告成 Private\n\n- 只提供必要的 Getter 給客戶端，隱藏你的實作有絕佳的好處。\n\n思維誤區: Protected 不比 Public 具有更好的封裝性\n- 取消一個 Public Member Data 的成本: 所有使用他的客戶端\n- 取消一個 Protected Member Data 的成本 : 所有繼承他的 Derived Class\n這兩種 Access Level 的封裝性都不佳，仍該盡可能的使用 Private。\n\n### 條款23 寧以non-member, non-friend替換 member函數\n\n這條是針對 Object-Oriented C++ 的法則，站在 Template C++ 又有其他需要考慮的地方，形成了 [[Item46 需要型別轉換時請為模板定義非成員函式]]\n\n[[Non-member \u0026\u0026 Non-friend Function 的封裝度優於 Member Function]]\n\n\n\n### 條款24 如果所有的參數都需要型別轉換，請為此採用 non-member 函式\n[[當所函式所有的參數都需要型別轉換，採用 Non-member Function]]\n\n\n### 條款25 考慮寫出一個不拋異常的 Swap 函式\n[[Swap and pimpl]]\n\n\u003e [!danger]\n\u003e 讀到 P111，我懷疑 C++11 之後有不同的做法，先不細看。\n\n\n## Ch5 Implementation\n### 條款26 盡可能延後變數定義式的出現時間\n盡可能等到已經擁有初始值了，再一口氣定義+賦予初始值。如此不必調用多餘的 constructor ! \n- [[盡可能延後變數定義式的出現時間]]\n\n----\n\n### 條款27 少做轉型動作 (Minimize Casting)\n- 如果轉型是必要的，試圖把它隱藏在函式之後，不讓 User 在他們的程式中轉型。\n- 作為 Client，如果需要轉型，考慮使用新式的轉型，即使用舊式看起來也合情合理。\n[[少做轉型動作(Minimize casting)]]\n\n### 條款28 避免傳回 Handles 指向物件內部成分\n[[避免傳回 Handles 指向物件的 Private \u0026 Protected Member Data]]，目的是盡可能消滅 dangling handles 出現的可能。\n\n\n### 條款29 為異常安全 (Exception-safe) 而努力是值得的\n\n[[為異常安全 (Exception-safe) 而努力是值得的]]\n\n\u003e [!Todo]\n\u003e Read to P132\n \n### 條款30 透徹了解 Inline\n\n宣告 inline 前，先透徹讀完: [[了解 Inline 的裡裡外外]]\n\n### 條款31 將檔案間的編譯依存降到最低\n[[將檔案的編譯依存關係降到最低]]\n\n## Ch6 繼承與物件導向\n\n### 條款32 確定你的 Public 繼承塑出 is-a 關係\n\n\n### 條款33 避免遮掩繼承而來的名稱\n\n\n### 條款34 區分介面繼承與實作繼承\n[[Item34 Differentiate between inheritance of interface and inheritance of implementation]]\n\n### 條款35 考慮 Virtual 函式以外的其他選擇\n\n### 條款36 絕不重新定義繼承來的 Non-virtual Function\n\n### 條款37 絕不重新定義繼承來的預設參數值\n\n### 條款38 透過複合模塑出 Has-a 或 根據某物實作出\nModel \"has-a\" or \"is-implemented in terms of \" through composition.\n\n### 條款39 明智審慎的使用 Private 繼承\n\n### 條款40 明智審慎的使用多重繼承\n\n## Ch7 Template and Generic Programming\n### 條款41 了解隱式介面和編譯多型\n\n### 條款42 了解 typename 的雙重意義\n\n### 條款43 學習處理模板化基礎類別內的名稱\n\n### 條款44 將與參數無關的程式碼抽離 Templates\n\n\n### 條款45 運用成員函式模板接受所有相容型別\n\n\n### 條款46 需要型別轉換時請為模板定義非成員函式\n\n\n- [[Item46 需要型別轉換時請為模板定義非成員函式]]\n\n### 條款47 請使用 Traits Classes 表現型別資訊\n\n### 條款48 認識 Template 超編程\n\n## Ch8 自訂 new 和 delete\n\n### 條款49 了解 new-handler 的行為\n\n### 條款50 了解 new 和 delete 的合理替換時機\n\n### 條款51 編寫 new 和 delete 時需固守常規\n\n### 條款52 寫了 placement new 也要寫 placement delete\n\n\n\n## Ch9 雜項討論\n### 條款53 不要輕忽邊義器的警告\n\n### 條款54 讓自己熟悉包刮 TR1 在內的標準函式庫\n[[Item54 Familiarize yourself with the standard library including TR1]]\n\n### 條款55 讓自己熟悉 Boost\n\n[[Item55 Familiarize yourself with Boost]]\n\n\n簡體目錄: https://blog.csdn.net/weixin_45926547/article/details/121276226\n","lastmodified":"2023-05-07T06:09:55.529193552Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/Friend-Function":{"title":"Friend Function","content":"\n\u003e 提供私用成員給某些外部函式來存取，這個有權調用某類別私有成員的函式就稱為 Friend Function \n\nFriend Function 實質上定義在外面，但是在 Class 內部需要用 keyword `friend` 再提及一次該 function。因此，Friend Function 是 Non-member function !\n\n```cpp\nclass Ball;\n\nint compare(Ball \u0026b1, Ball \u0026b2) {\n    // 可直接存取私用成員\n    if(b1._radius == b2._radius)\n        return 0;\n    else if(b1._radius \u003e b2._radius)\n        return 1;\n    else\n        return -1;\n}\n\nclass Ball { \npublic: \n    Ball(double, char*); \n    void radius(double radius) {\n        _radius = radius;\n    } \n    // 宣告朋友函式 \n    friend int compare(Ball\u0026, Ball\u0026);\n \nprivate:\n    double _radius; // 半徑\n};\n```\n\n\n\n\n\n\n\n## Resource\n\n[friend 函式、friend 類別](https://openhome.cc/Gossip/CppGossip/friendFunctionClass.html)\n","lastmodified":"2023-05-07T06:09:55.529193552Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/Identify-Initialization-and-Assignment":{"title":"Identify Initialization and Assignment","content":"\n\u003e C++ 規定，member data initialization 發生在**進入 Constructor 之前**。在 Constructor 賦值屬於 assignment。 正確的 initialization 是使用 member initialization list (成員初值列)，取代賦值 (assignment)。\n\n此例中，第一種的做法效率好: \n- 第一種作法使用  member initialization list 是對 member data 做 Copy Construct。\n- 第二種作法 `m_name`會隱含的 call 一次 `std::string` 的 default constructor，再以 Copy assignment 被賦予值\n\n```cpp\nclass Book {\n    private:\n        std::string m_name;\n    public:\n        // good way\n        Book(const std::string\u0026 name): m_name { // copy construct\n        }\n        // bad way\n        Book(const std::string\u0026 name) {\n            m_name = name;  // copy assignment\n        }\n}\n```\n","lastmodified":"2023-05-07T06:09:55.529193552Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/Implicit-TemplateInstantiation":{"title":"Implicit TemplateInstantiation","content":"\u003e Occurs when a template is used to declare a pointer variable or a variable with the provided arguments","lastmodified":"2023-05-07T06:09:55.529193552Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/Item34-Differentiate-between-inheritance-of-interface-and-inheritance-of-implementation":{"title":"Item34 Differentiate between inheritance of interface and inheritance of implementation","content":"","lastmodified":"2023-05-07T06:09:55.529193552Z","tags":["empty"]},"/notes/Project/Effective-C++-Series/Item46-%E9%9C%80%E8%A6%81%E5%9E%8B%E5%88%A5%E8%BD%89%E6%8F%9B%E6%99%82%E8%AB%8B%E7%82%BA%E6%A8%A1%E6%9D%BF%E5%AE%9A%E7%BE%A9%E9%9D%9E%E6%88%90%E5%93%A1%E5%87%BD%E5%BC%8F":{"title":"Item46 需要型別轉換時請為模板定義非成員函式","content":"","lastmodified":"2023-05-07T06:09:55.529193552Z","tags":["empty"]},"/notes/Project/Effective-C++-Series/Item47-Use-traits-classes-for-information-about-types":{"title":"Item47 Use traits classes for information about types","content":"","lastmodified":"2023-05-07T06:09:55.529193552Z","tags":["empty"]},"/notes/Project/Effective-C++-Series/Item54-Familiarize-yourself-with-the-standard-library-including-TR1":{"title":"Item54 Familiarize yourself with the standard library including TR1","content":"","lastmodified":"2023-05-07T06:09:55.529193552Z","tags":["empty"]},"/notes/Project/Effective-C++-Series/Item55-Familiarize-yourself-with-Boost":{"title":"Item55 Familiarize yourself with Boost","content":"","lastmodified":"2023-05-07T06:09:55.529193552Z","tags":["empty"]},"/notes/Project/Effective-C++-Series/Member-Initialization-List":{"title":"Member Initialization List","content":"\n\u003e 無論如何，使用 member initializer list 對 member data 初始化是最好的。儘管這麼做對內建型別的資料沒差，對非內建型別卻有巨大的意義。\n\n如果你就是想要 call member data 的 default constructor，依然可以透過 member initializer list 達成。只要給予空括號，不填內容即可。\n這樣的好處是明白地列出所有 member data，避免有 data 忘記給初始值，特別是對**非內建型別**的member data，沒有初始化的結果是災難的。\n\n對於內建型別的 Reference \u0026 const，他們**不能被賦值**，**必須透過 member initializer list 初始化**。\n- Related: [[Effective C++ Outline#條款5 了解 C++默默編寫並呼叫哪些函式]]\n\n\n## 合理的使用 Assignment\n某些時候，類別擁有多個 Constructor，每個 Constructor 都需要有自己的 Member initializer list，這又會導致 dumplicated。\n這時候可以是當地將一些 Assignment 和 Initialize 效率差不多的 member data (通常是內建型別)，移到一個 \"統一初始化\" 的 private function，供所有的 Constructor 呼叫。\n這種作法 (pseudo-initialization, 偽初始化) 特別在數值是由讀檔得到的時候特別有用，但可以的話，盡可能使用 member initializer list。\n","lastmodified":"2023-05-07T06:09:55.529193552Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/Modern-C++-nothrow":{"title":"Modern C++ nothrow","content":"","lastmodified":"2023-05-07T06:09:55.529193552Z","tags":["empty"]},"/notes/Project/Effective-C++-Series/Mutex":{"title":"Item14","content":"假設我們用 C API 處理 `Mutex` 物件\n```cpp\nvoid lock(Mutex *pm); // lock mutex pointed to by pm\nvoid unlock(Mutex *pm); // unlock the mutex\n```\n\n使用者需要自己手動分別呼叫 `lock` 與 `unlock`。為了確保不會忘記幫 Mutex 解鎖，可以建立一個由 RAII 守則支配的 Class --資源在建構期間獲得(lock)，在解構期間釋放(unlock)--來管理資源「Mutex 物件」。\n\n```cpp\nclass Lock {\npublic:\nexplicit Lock(Mutex *pm) : mutexPtr(pm) \n\t{ lock(mutexPtr); } // acquire resource\n~Lock() { unlock(mutexPtr); } // release resource\n\nprivate:\nMutex *mutexPtr;\n};\n\n```\n而客戶端調用，也符合 RAII 方式\n```cpp\nMutex m;     // define the mutex you need to use\n...\n{            // create block to define critical section\nLock ml(\u0026m); // lock the mutex\n...          // perform critical section operations\n}            // automatically unlock mutex at end of block\n```\n現在，客戶在也不會因忘記為  `unlock(Mutex)` 而出問題!\n\n## 如果有人試圖複製 `Lock` ?","lastmodified":"2023-05-07T06:09:55.529193552Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/Non-member-Non-friend-Function-%E7%9A%84%E5%B0%81%E8%A3%9D%E5%BA%A6%E5%84%AA%E6%96%BC-Member-Function":{"title":"Non-member \u0026\u0026 Non-friend Function 的封裝度優於 Member Function","content":"\n\u003e Non-member function 帶來更佳的封裝度、與 Packaging 彈性。\n\n\n這邊說的是 Non-member 且(AND) Non-friend function (Pure function) vs. Member Function。(關於 [[Friend Function]] )\n\n物件導向要求，資料(data) 以及操作資料的函式應該盡量綁在一起，不代表物件導向推崇 member function 是比較好的選擇。\n\n物件導向要求資料應該盡可能地被封裝，卻與直觀相反的，non-member function 的封裝性優於  member function。為什麼? \n\n## 封裝為什麼封裝被推崇? \n\u003e 封裝使得我們在改變事物時，只影響有限的客戶。\n\n- 被封裝的東西變得不可見 -\u003e 越多封裝就越少 client 可以 access -\u003e 對實作方而言，有更大的彈性改變它，因為能 access 它的客戶有限，改變的影響力小。\n- 還有另一個優點是: 帶來包裹彈性 (packaging flexibility)，這與 Namespace \u0026 header file 相關，後面會提及。\n\n## 如何衡量封裝程度\n這個問句可以換句話說，如何量測「有多少 function 可以看到某一塊資料?」。\n\n\u003e 計算能夠存取該資料的函式，越多函式存取則封裝度越低。\n\n對於 Private Member data 而言，能存取它的就是所有的 member function。\nFriend function 雖然不是 non-member function，但他和 member function 同樣擁有 access private data 的能力，所以兩者的封裝度是同樣低的。 \n\n## 將有編譯相依的函式放在同一個 Header File\n當我們遵守本頁的守則，拆出許多 Utility Function (工具箱) 之後，該考慮將 Function 依照編譯相依性拆分到不同的 Header file，在不同的 Header file 間共用同一個 namespace 即可。\n\n書中以 `WebBrowser` 舉例，Utility Function 可能有 cookie, bookmark, core funcion (幾乎每個客戶都要的 non-member function)，cookie functions 之間有編譯相依性，放在一塊以此類推。\n\n```cpp\n// web_browser_core.hpp\nnamespace WebBrowserStuff {\n\t// core function\n\tclass WebBrowser;\n}\n\n// cookie.hpp\nnamespace WebBrowserStuff {\n\t// cookie functions\n}\n\n// bookmark.hpp\nnamespace WebBrowserStuff {\n\t// bookmark functions\n}\n```\n\n這也是 STL 的組織方式，當 User 要用 std::list 時不會去 Include 到 `\u003cvector\u003e` 這個 header file。\n\nNamespace 提供一個比較寬鬆的組織方式，即使跨越 header file 仍能隸屬相同的 namespace。\n\n甚至對 Client 而言，擴展 Utility Function 也同樣容易，只要共用 namespace 、在自己的 header file 增加客製化的 utility function 即可 -- 畢竟 Namespace 可以跨 header file! \n\n這是以 Namespace 組織，優於以 class 組織的另一個好處 : 對 Client 端而言，他們無法改變 Class 的定義式，但 namespace 他們可以自由共用。\n\n## 有著繼承也無法取代的優點\n\n當然，不能改變定義式，繼承是個解決方法。\n\n然而 C++ 的繼承中，Child 是不能取得 Parent 的 Private Data 的。繼承可以擴充 Public 方法，這點跟 non-member \u0026\u0026 non-friend function 如出一轍，沒有佔上風，卻在 package fexility 上輸了一截。\n\n這種程度的「擴展機能」相較共用 Namespace 能拆分 Header file 依賴度，就打了折扣。","lastmodified":"2023-05-07T06:09:55.529193552Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/Pure-Virtual-Destructor":{"title":"Pure Virtual Destructor","content":"現在的情境是，如果，你想要有一個抽象類 -- 抽象類的好處是自身無法被實例化。然而，抽象類的定義是，至少有一個 function 是 Pure Virtural Function。該選擇 \"誰\" 成為 Pure virtural function 呢? 洽巧手上沒有適合的人選! Destructor 會是個好選擇。因為\n1. Abstract Class 總是被當作 Base Class\n2. Base Class 作為多型用途時，應當帶有 virtural destructor\n3. Pure Virtural Function 可使該 Class 形成 Abstract\n三個點串起來--「讓 destructor 變成 Pure Virtural 吧」，這樣不會有不該被 virtural 的 function 遭殃! \n\n\u003e Abstruct Class 是不能被實例化的 Class，但可以持有 Abstruct Class 的 Pointer 去操控 Child instance。\n\n不過須記得一個技巧 -- 依然為這個 Base Class 的 Destructor 提供一個空的實作。\n這是因為 Destructor 的運作規則，在繼承架構中，most derived class (最 child 的) 的 destructor 會最先被呼叫，接著是每一個 Base Class 的 Destructor。即使 `AWOV` 作為抽象類沒有實例化的問題，其 destructor 依然會被呼叫，所以需要提供一個空的實作，Linker (編譯器的一部分?) 會報錯。\n```cpp\nclass AWOV {\npublic:\n\tvirtural ~AWOV() = 0;\n}\n\nAWOV::~AWOV() {}; // 依然為它提供一個實作\n```\n\n ","lastmodified":"2023-05-07T06:09:55.529193552Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/Replace-define-with-const":{"title":"Replace define with const","content":"\n## 以編譯器取代前處理器\n\n `#define` 的本質是 word replacement，如: `#define RATIO 1.653`，編譯器可能不認得 `RATIO` 並在錯誤訊息中從頭到尾以 1.653 取代 `RATIO`。\n```cpp\n const double Ratio=1.653; // Prefer\n```\n\n當以 `const` 取代 `#define` 時，有兩個需要注意的點\n1. 定義常數指標 (const pointer): 常數指標用於 「不允許此Pointer更改指向的對象」，因此需要對 pointer 宣告 const\n\n```cpp\nconst std::string = authorName(\"Scott\");\n ```\n\n2. Class 的專屬常數: 目的是限制常數的 Scope，因此要宣告在 class 內部。而為了使這個常數只有一個實體(所有 instance 共享同一個常數)，還需要宣告 `static`。\n\n```cpp\nclass Player {\nprivate:\n\tstatic const int num = 5;\n\tint scores[num];\n}\n ``` \n\n\n## 具有 Access Level\n第二點的用途，設置一個在某特定類別才生效的常數變是 `#define` 做不到的，`#deinfe` 不在乎 scope，不能帶來封裝性，更沒有 `private #deinfe` 這種東西。\n","lastmodified":"2023-05-07T06:09:55.529193552Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/Singleton":{"title":"Singleton","content":"","lastmodified":"2023-05-07T06:09:55.529193552Z","tags":["empty"]},"/notes/Project/Effective-C++-Series/Smart-Pointer":{"title":"Smart Pointer","content":"\n在[[為多型用途的基礎類別宣告 virtual 解構式]]文章中的 `TimeKeeper` 例子，我們提及了工廠函式 (factory function)，在該例子，我們把 delete `new` resource 的責任交給 Client。\n\n然而有很多情況--例如 main flow 中過早的 return，resource 可能沒有成功被銷毀。善用 Pointer-like 物件，並把銷毀資源的操作**確實**的寫在 Destructor 中可以避免這些問題。\n\nSmart Pointer 的原理是利用一個 object 去 own (or manage, 管理) 一個 heap-based 的資源，當 Smart Pointer Object 脫離 Scope，Compiler 試圖去 destructor 時，藉機呼叫手上 Object 的 destructor。\n\n## Smart Pointer 當中的顯式與隱式轉換\n1. Smart Pointer 的 `get` function 是一種顯式轉換 (explicit)，允許 client 取得原始物件的原始型別指標。\n2. Smart Pointer Override 了 `operation*` 和 `operator-\u003e`，因此 client 端可以直接對它做指標操作，有如對待 raw pointer，這隱含的是隱式轉換 (implicit)\n\n## 顯式/隱式轉換介面\n如上述， `get` function 是一種顯式轉換 (explicit)，它的優點是使用時意圖清楚，缺點是很醜。\n其實，亦可以提供個隱式轉換的介面，如此當這個物件被放到 base resource 的類別時，就不用特別透過 `get` 提取 base resource，缺點是會提升發生錯誤的風險。\n\n選擇何種，取決於使用情境，記住 [[讓介面容易被使用]]，不要讓你的介面容易被誤用，即可。","lastmodified":"2023-05-07T06:09:55.529193552Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/Static-Object":{"title":"Static Object","content":"\n\u003e 壽命從被建構出來，持續到程式結束為止。\n\n因此 Stack 和 Heap-based 物件都不是 static object。\n這種物件包含 Global Object，定義在 Namespace Scope 的物件，Class \u0026 Function \u0026 File 內宣告成 `static` 的物件。\n- Function 內的 static object 稱為 local static object (Scope 只在 function 內)\n- 其他被稱為 non-local static object\n它們的 deconstructor 會在 main 結束時被喚起。\n\n當我們有兩個編譯單元 ([[Translation Unit]])，通常表示兩份 Source Code。兩份 Source Code 中都有 non-local static object，且其中一份 static object 的初始化需要使用到另一份 source code 的 static object。\n\n問題在於，有可能要被使用的那個物件尚未被初始化! \n\u003e C++ 對於不同 [[Translation Unit]] 中 non-local Static object 初始化的順序並沒有明確的定義。\n\u003e The relative order of initialization of non-local static objects defined in different translation units is undefined.\n\n這是有原因的，因為決定這個順序非常困難，近乎無解，甚至不值得去找解。\n\n這種問題常見於[[Implicit TemplateInstantiation]] 模板隱式具現化。 (? 不確定翻譯)\n\n## Make Non-local Static Object become Local Static Object\n\n\u003e C++ 保證，函式內的 Local static object 會在該函式被呼叫期間，首次遇到該物件的定義式時初始化。\n\n我們可以利用此原則，解決 dependency of 2 non-local static object in 2 different translated units 的問題。\n\n\u003e 將每個 non-local static object 搬到專屬的 function 內，以 local static object 的方式存在。Design Pattern 中的 [[Singleton]] 就式常見的實作方式。\n\n其原理在於，所以比起直接呼叫 non-local static object，使用 function call 的做法更佳。更棒的是，若你從未呼叫「模擬該 non-local static object 的 function」，則 「那個 object 」根本**不會初始化**，有延遲初始化的功效在! 這是真正的 non-local static object 所不能及的。\n\n`static` 可以確保唯一性，Singleton 本身就常常與 Static 搭配使用。\n\n```cpp\nclass FileSystem { ... };\n\nFileSystem\u0026 tfs()\n{\n    static FileSystem fs;\n    return fs;\n}\n\nclass Directory { ... };\nDirectory::Directory( params )\n{\n    std::size_t disks = tfs().numDisks();\n}  \n\n// The first call function.\nDirectory\u0026 tempDir()\n{\n    static Directory td( params );\n    return td;\n}\n```\n此種手法稱為 reference-returning。\n\n在此例子中，`tmpDir` 創建物件 `td`，在 call `Directory` Constructor 時，會再 call `tfs` ，此時才創建 static object `fs`。透過 function call，確保了物件初始化的順序，先初始化 `fs`，再創建 `td`。\n\n### 優點\n特別在頻繁呼叫的時候，搭配 [[了解 Inline 的裡裡外外]]。\n\n### 缺點\n在 multi-thread 中有不確定性。任何一種 non-const static 物件如果**依賴於其他事件的發生**，都很麻煩。常見的解決方法是，在 single-threaded startup portion 手動喚起所有 reference-returning function，手動解決 race conditions。\n","lastmodified":"2023-05-07T06:09:55.529193552Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/Swap-and-pimpl":{"title":"Swap and pimpl","content":"\n## std::swap\nSTL 的 swap 平凡無奇，涉及了三次的複製。\n```cpp\nnamespace std {\n    template\u003ctypename T\u003e\n    void swap (T\u0026 a, T\u0026 b) {\n        T tmp(a);\n        a = b;\n        b = tmp;\n    }\n}\n```\n\n但對於「某些型別」而言，他們滿足某些資格。因為有這種前提，`std::swap` 的標準做法(三次複製)是多餘的，他們有更快的解法。\n\n「以指標指向一個物件，那個物件含有真正的資料」的型別，就是那些特殊的、滿足資格的傢伙。常見的手法是 [[pimpl idiom (pointer to implementation)]] ，Pattern 如下: \n- `Widget` 的 Copy Assignment 實際上是複製 `rhs.pImpl` 所有內容到自己的 `pImpl` 複製一份過來。\n```cpp\nclass WidgetImpl {\nprivate:\n    int a, b, c; \n    ... // a lot of data\n}\n\nclass Widget {\npublic:\n    Widget(const Widget\u0026 rhs);\n    // copy assignment: 把 WidgetImpl 的每一個內容都複製一份過來\n    Widget\u0026 operator=(const Widget\u0026 rhs) {\n        *pImpl = *(rhs.pImpl); \n    }\n\nprivate:\n    WidgetImpl* pImpl;\n}\n```\n\n當 Widget 在 swap 時 Copy Assigment 會發生足足三次! 實際上卻是 -- 只要把 `lhs.pImpl` 和 `rhs.pImpl` 兩個 Pointer 互換即可。\n\n## 實作 Swap \n首先，需要用到 [[Total Template Specialization]] 。我們不被允許改變 STD 空間內的東西，但我們被允許用 STD Template 製造特異化版本，當 swap 用於 `Widget` 物件時自動使用特異化版本的 function。\n\n```cpp\nnamespace std {\n\ttemplate\u003c\u003e \n\tvoid swap\u003cWidget\u003e (Widget\u0026 a, Widget\u0026 b) {\n\t// 以上兩行表示 total template specialization: 當用在 Widget 時\n\t// 用這個特異化的 function!\n\t\t\n\t\t// swap(a.pImpl, b.pImpl); // 會失敗，因為 pImpl 是 private.\n\t\ta.swap(b);\n\t}\n}\n\nclass Widget {\npublic:\n\tvoid swap(Widget\u0026 other) {\n\t\tusing std::swap; // necessary.\n\t\tswap(pImpl, other.pImpl);\n\t}\n}\n```\n\n在 `Widget::swap` 裡指定 `using std::swap` 是必要的。\n\n\u003e [!danger]\n\u003e 讀到 P111，我懷疑 C++11 之後有不同的做法，先不細看。\n\n\n## Name Lookup Rules\n","lastmodified":"2023-05-07T06:09:55.529193552Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/The-Copying-in-Pass-by-value":{"title":"The Copying in Pass by value","content":"\n## Simple Pass By Value\n考量下面的程式 `validateStudent(s)` 執行的成本有什麼?\n\n```cpp\nclass Person;\nclass Student: public Person;\nbool validateStudent(Student s); // pass by value = copy\nStudent s = Student();\nvalidateStudent(s); \n```\n\n成本是\n- Student Copy Constructor\n- Person Copy Constructor\n一個 Copy Ctor 就意味著一次全部 member data 的 Copy，所以 data 越多呼叫越多 Copy Ctor!! \n\n## 多型函式\n當 Signature 是 Parent，傳入的是 Child，更糟糕的是會發生 Slicing! 只有 `Person` 部分的資料會被 Copy，`Worker` 的資料都被切割了。\n\n```cpp\nclass Worker: public Person;\nbool showName(Person s);\n\nWorker w = Worker();\nshowName(w);\n```","lastmodified":"2023-05-07T06:09:55.529193552Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/The-definition-and-declaration-of-static-const":{"title":"The definition and declaration of static const","content":"","lastmodified":"2023-05-07T06:09:55.529193552Z","tags":["empty"]},"/notes/Project/Effective-C++-Series/Total-Template-Specialization":{"title":"Total Template Specialization","content":"","lastmodified":"2023-05-07T06:09:55.529193552Z","tags":["empty"]},"/notes/Project/Effective-C++-Series/Translation-Unit":{"title":"Translation Unit","content":"\n\u003e A translation unit is the source code giving rise to a single object file. It's basically a single source file, plus all of its `#include` files.\n\n編譯單元指: 產出單一目的檔 (single object file) 的那些 source code，通常是 source code + included header file.","lastmodified":"2023-05-07T06:09:55.529193552Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/Virtual-Function":{"title":"Virtual Function","content":"\n## 在 Ctor / Dtor 呼叫 virtual function\n![[Itm10_TranscationUML.png]]\n\n在這裡，Transcation 的 Constructor 呼叫的會是 `Transcation::logTranscation`。\n又，該 function 為 Pure virtural function，若它沒被定義，則當編譯器呼叫時會引發錯誤，而若有.... 就會 Link 到該 base class function。\nRelated: [[Item34 Differentiate between inheritance of interface and inheritance of implementation]]\n\n一個不正式的講法: Base Calss 建構期間，所呼叫的 virtual function 不是 virtual function。  \n\n\u003e [!important] \n\u003e 在 Drived Class Object 執行 Based Class Constructor 期間，物件的型別實際上是 Base Class。\n\n這是根本的原因，由於在 Based Class Constructor 物件是 Base Class，呼叫 Base Class 的 function 也是自然的事。\n不只是 virtual function 會被決議(resolve to) 至 Base Class，如果使用 `dynamic_cast` (Runtime type infomation)，也會把物件視為 Base Class! [[少做轉型動作(Minimize casting)]]\n\n相同的問題也存在於 Destructor，在 Destructor 中 Drived Class 的部分會先被消滅，一旦進入 Base Class Destructor ，C++ 就會看待它為一個 Base Class。\n\n## 以傳遞參數給 non-virtual function，取代使用 Virtual function\n將 virtual function 從 con/desturctor 中移除! 說來容易，卻不易察覺。Constructor 可能 call 別的 function，而 virtual 可能藏身在其中! 並且，很難確保 Child Class 也會服從這項規定。\n\n替代方案是，使用 non-virtual function，把 Log 以 string 的方式傳給 Base Class 的 non-virtual Log function。\n","lastmodified":"2023-05-07T06:09:55.529193552Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/enum-hack":{"title":"enum hack","content":"","lastmodified":"2023-05-07T06:09:55.529193552Z","tags":["empty"]},"/notes/Project/Effective-C++-Series/pimpl-idiom-pointer-to-implementation":{"title":"pimpl idiom (pointer to implementation)","content":"\u003e 將物件的實作細目隱藏在一個指標背後\n\n此手法會把一個類別分成兩個 Class: \n- 一個是暴露給客戶端的接口 Handle Class (ex. `Person`)，它只會擁有一個 pointer 指向實作 class\n- 一個是實作類別 Implementation Class (ex. `Personimpl`) ，所有真正要存的資料都在這裡面。\n\n由於接口 `Person` 只 own 一個 smart pointer ，它不需要知道 `PersonImpl` 有多大，因此可以用 forward declare 解決。它還提供了一些 getter，但提供 getter 也都可以透過 forward declare 解決一切。\n\n客戶端在 `include person.hpp` 時，只會跟著 include 到 string 和 memory 兩個 header file 而已。至此，`PersonImpl` 做了什麼更動，直接跟客戶端脫鉤。\n\n\n```cpp\n#include \u003cstring\u003e // standard library components shouldn’t be forward-declared\n#include \u003cmemory\u003e // for tr1::shared_ptr; see below\nclass PersonImpl; // forward decl of Person impl. class\nclass Date; // forward decls of classes used in\nclass Address; // Person interface\nclass Person {\npublic:\n\tPerson(const std::string\u0026 name, const Date\u0026 birthday,\n\tconst Address\u0026 addr);\n\tstd::string name() const;\n\tstd::string birthDate() const;\n\tstd::string address() const;\n\t...\nprivate: // ptr to implementation;\n\tstd::tr1::shared_ptr\u003cPersonImpl\u003e pImpl; // 這是唯一的 member data\n}; // std::tr1::shared_ptr\n```\n\n[[編譯依存-宣告式、定義式與實作細節]]\n\n## Handle Class 的實作檔案 (CPP)\n實作檔案需要同時 include `Person.hpp` 和 `PersonImpl.hpp`\n-  `Person.hpp` : 為了實作 `Person`的 function\n-  `PersonImpl.hpp`: 才能 Call `PersonImpl` 的 function。\n\n```cpp\n#include \"Person.h\" \n#include \"PersonImpl.h\" \nPerson::Person(const std::string\u0026 name, const Date\u0026 birthday,\nconst Address\u0026 addr)\n: pImpl(new PersonImpl(name, birthday, addr))\n{}\nstd::string Person::name() const\n{\nreturn pImpl-\u003ename();\n}\n```\n## 實作 pimpl pattern 的方法有兩種\n\n1. Handle Class: 前面使用的方法，handle class 擁有一個指向 impl class 的 pointer。\n2. Interface Class\n\n\n## Interface Class 的設計方式\n暴露給客戶的是 Interface Class，這個類別本身會設計成一個 abstract base class (interface class)。[[Item34 Differentiate between inheritance of interface and inheritance of implementation]]\n\nInterface class 的用途是僅有敘述 drived class 的介面，它沒有 member data、也沒有 constructor，只有一個 virtual destructor，跟一堆 pure virtual function 來敘述介面。而 drived class 就是它的實作 (相當於前面 implement class 的腳色)\n```cpp\nclass Person {\npublic:\n\tvirtual ~Person();\n\tvirtual std::string name() const = 0;\n\tvirtual std::string birthDate() const = 0;\n\tvirtual std::string address() const = 0;\n...\n};\n```\n\n我們暴露給 Client 端的是 Interface class，Interface calss 是 abstract class，然而， **abstract class 不能被具象化**。因此，用此方法設計時，需要在  interface class 裡面提供一個「讓 client 端獲取物件」的特殊方法。\n\n這個特殊方法通常稱為 [[工廠函式 (Factory Function)]]，它們會回傳一個 interface class pointer，卻指向動態配置(被 `new` 出來) 的 derived class 物件。這種函式在 interface class 內往往宣告為 `static`。如下例的 `create`: \n\n```cpp\nclass Person {\npublic:\n...\nstatic std::tr1::shared_ptr\u003cPerson\u003e \ncreate(const std::string\u0026 name, // Person initialized with the\n\t\tconst Date\u0026 birthday, // given params; see Item 18 for\n\t\tconst Address\u0026 addr); // why a tr1::shared_ptr is returned ...\n};\n```\n\nInterface Class 所對應的實作類別會是一個具象類 (concrete class)，它必須擁有真正的 constructor。假設這個實作類別是 `RealPerson`: \n\n```cpp\nclass RealPerson: public Person {\npublic:\n\tRealPerson(const std::string\u0026 name, const Date\u0026 birthday,\n\tconst Address\u0026 addr)\n\t: theName(name), theBirthDate(birthday), theAddress(addr)\n\t{}\n\tvirtual ~RealPerson() {}\n\tstd::string name() const; // implementations of these \n\tstd::string birthDate() const; // functions are not shown, but \n\tstd::string address() const; // they are easy to imagine\nprivate:\n\tstd::string theName;\n\tDate theBirthDate;\n\tAddress theAddress;\n};\n```\n\n現在知道 `RealPerson` 的 constructor 長相，`Person::create` 的實作也是輕而易舉: \n```cpp\nstd::tr1::shared_ptr\u003cPerson\u003e Person::create(const std::string\u0026 name,\nconst Date\u0026 birthday, const Address\u0026 addr)\n{\n\treturn std::tr1::shared_ptr\u003cPerson\u003e( \n\t\t\tnew RealPerson( name, birthday, addr));\n}\n```\n\n## 成本\n以上說明了兩種花俏的手法，它能降低耦合，減少編譯時間。成本呢?\n\n### Handle Class 的成本\n1. 每次對 Handle class 取值都是間接取值: handle class 需要跟 impl pointer 取得資料。\n2. 與不用 pimpl pattern 手法想比 (不去耦合)，每增加一個 handle class 物件，就會增加一個 impl pointer 的大小 (通常以 smart pointer 存)。\n3. impl object 是以動態記憶體配置 (`new`)，承受動態記憶體配置與釋放的成本，也有可能遇到 `bad_alloc` (記憶體不足)。\n### Interface Class 的成本\n1. Interface Class 每個函式都是 virtual function，每次的函式呼叫都要付出間接跳躍 (indirect jump) 的成本。見: [[為多型用途的基礎類別宣告 virtual 解構式]]\n2. 只要有 virtual function，就會有 vptr (virtual table pointer)，其成本參見:  [[Do not Declare Virtural Function in Non-polymorphic Base Class]]\n\n\n## 結論\n\n不論 handle class 或 interface class，一旦脫離 inline 函式都無法有太大的作為(why? 不過就是都要在 class 定義式中直接把實作寫完的意思)。因為這類 class 是為了隱藏實作細節或函式本體的!! [[了解 Inline 的裡裡外外#向 Compiler 發出申請]]\n\n\n\n","lastmodified":"2023-05-07T06:09:55.529193552Z","tags":["cpp"]},"/notes/Resource/Books/The-Second-Brain":{"title":"打造第二大腦","content":"\u003e 成為一個「能傳達資訊、且具有出色詮釋能力」的人! \n\n- Key Feature In this sentence:\n\t- Can construct infomation\n\t- Can express info effectively\n\n## CODE \n\n### C (Capture)\n\u003e 將資訊蒐集在沒有雜訊的地方，你可以心無旁騖地找到它。\n\n- 即使只是看一眼收藏，也要慎選收藏的地方。\n- 不好的地方: 個人信箱、FB 的收藏 (很容易被社群吸走) ...\n- 適合的地方: 屬於自己的聊天室 (Line keep)\n\n### O (Orgnize)\n\u003e 以 Project 分類 ，不要以類別分類。\n\n- 淺台詞: 以目的導向分類。ex. 「專注力協議」的書摘應該放在「成為心無旁鶩的人」而不是「心理學」。\n- 像是歸類在「心理學」、或是「工作生產力」這種圖書館式的分類，你不分看標題也知道它是哪一類，不需要做無意義的分類。\n- 放在「成為心無旁鶩的人」，點進去這個目標，此書摘就會快速地浮現上來，告訴你快使用它! \n- 知識必須用到才有用! \n\n### D (Distill, 萃取)\n\u003e 用 Bullet Point 告訴未來的你，這篇筆記在說什麼?\n\n- 4 個層次的萃取，每一次萃取約保留 10~20% 的訊息量。\n- 萃取的時機很重要，無效的萃取反而遺失重要訊息。\n- How to partice? Distill the note when read it once time.\n\n### E (Express, 表達)\n\u003e Any way. Deliver it, and share! \n\n\n## 釐清目標: 你想解決什麼問題?\n\u003e Which problems do you want to resovle by The Second Brain? \n\n**費曼: 12道難題**\n它應該具有轉移性，核心精神不變，但領域可能改變的特質。記得這些你的目標，當資訊流過你身邊時，驗證他們是否能幫助你解決這些難題? If true, Capture it! \n\nMy current thinking: \n1. How to improve poor english?\n2. How to spend time \u0026 learning effectively?\n3. How to take effective note?\n4. How to debug (gdb) effective?\n\n## Capture: What Info Can put into Your Second Brain?\n\n- 摘要! 通常不應超過原資訊量的 1/10\n- 具有啟發性的，改變你的想法的 (不懂 太抽象)\n- 在未來可以被使用的 (ex. How to own a project? How to leader a team?)\n- 跟你自身相關的: 珍貴的，你想永久記憶的回憶。\n- 相反、不同觀點的: 避免佐證偏差 (confirmation bias)，可以使你跳脫當前認知的。\n\n\u003e 記住，重新消化過的資訊更好吸收! \n\n## Organize: Where Do the Info Put?\n\n不使用圖書館式的分類法，作者提出 PARA 方法，可以看出重要程度依序遞減。人的注意力有限，請第一眼，就看到最可能幫助你的資料。\n\n\u003e 讓最重要的任務、最短期的目標的相關資料上，沒有過多的雜訊\n\nP (Project): 短期任務\n- Working project\n- Personal project (ex. blog), side project, 減重... \n\n\nA (Area): 長期任務，長期想掌握的目標\n- 健康，不同於 project 中的「減重」是明確目標、是達成健康的手段，健康是長期目標。\n\nR (Resource): 未來有用處的\n- 有興趣的東西、嗜好: 精油、咖啡\n- 研究的可提: effective\n- 有用的參考: travel plan\n\nA (Archive): 備而不用\n- 不再有興趣的\n\n\n\n## Distill 萃取\n\n- 不要花相同的時間，處理相同的原始資料\n- 摘要! 用簡短的 bullet point 列出重點。\n- 誤區: 當不能了解其用處時，不應強行消化，否則重點非重點。\n\n\u003e My opinion: 每調閱它、閱讀一次，就萃取一次。\n\n### 參考方法: 4 個層次萃取\n\n每個步驟間應保留約 10~20% 的資料量，否則 brief isn't brief.\n1. 擷取段落\n2. 粗體字\n3. 螢光筆 highlight\n4.  bullet point \n\n### 以會議筆記舉例\n\n1. 列出所有討論出來，需要做的 (need to do)\n2. 劃出重點項目、關鍵字\n3. 簡短列出: 如何執行 (execute)\n\n## Express 表達\n\n### 哲學思辨: 如何騰出專注力，卻不消耗專注力?\n\u003e 使用中間產物\n\nProject 自起點到終點(成品)，有許多中間產物，例如: 草稿、大綱、顧客回覆。收集這些資料，放進第二大腦，達到重複使用! \n\n### 中間產物\n1. Note\n2. 不使用的 Proposal \n\t1. 以及檢討，為何不使用。可能是有重大缺陷，需要避免以後踩到。\n3. 半成品??? \n4. 團隊的文件，這相當於他人的經驗\n\n\n### 切分「一件事」\n一件事有很多碎片，如果你是從零開始，可以把完成這件事需要那些碎片寫下來，並把你花費專注力 build 好的碎片存起來，讓這些碎片可以 Re-use。\n\n同時，你在從零建構碎片時，也可以吸取別人的經驗，Reuse 別人的碎片! \n\n\n\n\n## Resource\n- Author's website: https://www.buildingasecondbrain.com/resources\n- Obsidian As a Second Brain: https://www.youtube.com/watch?v=nz99I7apNLI\u0026list=WL\u0026index=2\n- Should Logseq be Your Second Brain? https://www.youtube.com/watch?v=VJ2reQcpbYA\u0026list=WL\u0026index=3\n- Pick a Notes App: Your Notetaking Style (Part 1) https://www.youtube.com/watch?v=f3dDVtJ2sec\u0026list=WL\u0026index=4\n","lastmodified":"2023-05-07T06:09:55.529193552Z","tags":[]},"/notes/Resource/MOCs/C++-Resources":{"title":"C++ Resources","content":"\n## Books\n- [[../../Project/Effective C++ Series/Effective C++ Outline |Effective C++ Outline]]\n\n## Webs\n- [CppCoreGuidelines](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines)\n- [CppDeveloperRoadmap](https://github.com/salmer/CppDeveloperRoadmap)\n","lastmodified":"2023-05-07T06:09:55.529193552Z","tags":["cpp","moc"]},"/notes/Resource/Restaurant/%E4%B8%AD%E7%94%B0%E5%92%96%E5%93%A9-%E6%80%A7%E6%84%9F%E5%BA%97":{"title":"中田咖哩 性感店","content":"","lastmodified":"2023-05-07T06:09:55.529193552Z","tags":["food"]},"/notes/Resource/Restaurant/%E5%86%89%E5%86%89%E7%94%9F%E6%B4%BB":{"title":"冉冉生活","content":"[冉冉生活](geo:25.0169663,121.4730802)tag:coffee\n\n有多家分店，但似乎服務品質與衛生堪憂。\nIG 說推甜點，鹹食不推。\n\n","lastmodified":"2023-05-07T06:09:55.529193552Z","tags":["food"]},"/notes/Resource/Restaurant/%E5%8F%B0%E5%8C%97-%E8%81%9A%E9%A4%90%E5%9C%B0%E9%BB%9E":{"title":"台北-聚餐地點","content":"\n## 大台北\n\n```mapview\n{\"name\":\"Default\",\"mapZoom\":13,\"centerLat\":25.034179531237598,\"centerLng\":121.5133667131886,\"query\":\"\",\"chosenMapSource\":0}\n```\n\n## 板橋\n\n\n```mapview\n{\"name\":\"Default\",\"mapZoom\":16,\"centerLat\":25.0165744,\"centerLng\":121.4671392,\"query\":\"\",\"chosenMapSource\":0}\n```\n","lastmodified":"2023-05-07T06:09:55.529193552Z","tags":["food"]},"/notes/Resource/Restaurant/%E6%9C%89%E7%94%B0%E6%89%8B%E5%B7%A5%E7%83%98%E7%84%99%E5%9D%8A":{"title":"有田手工烘焙坊","content":"","lastmodified":"2023-05-07T06:09:55.529193552Z","tags":["coffee"]},"/notes/Resource/Restaurant/%E6%A6%96%E7%8F%88%E7%90%B2":{"title":"榖珈琲","content":"\n\n","lastmodified":"2023-05-07T06:09:55.529193552Z","tags":["coffee"]},"/notes/Resource/Restaurant/%E7%AB%B9%E8%8B%97-%E5%90%83%E9%A3%AF%E6%B8%85%E5%96%AE":{"title":"竹苗-吃飯清單","content":"\n## 新竹\n```mapview\n{\"name\":\"Default\",\"mapZoom\":12,\"centerLat\":24.800967748092074,\"centerLng\":120.9997558523901,\"query\":\"\",\"chosenMapSource\":0}\n```\n\n## 苗栗\n```mapview\n{\"name\":\"Default\",\"mapZoom\":11,\"centerLat\":24.619970429152907,\"centerLng\":120.86059570312501,\"query\":\"\",\"chosenMapSource\":0}\n```\n\n","lastmodified":"2023-05-07T06:09:55.529193552Z","tags":[]},"/notes/Resource/Restaurant/%E7%B4%80%E9%B3%A5":{"title":"紀鳥","content":"炭烤串，預估每人 $600~1000\n有點貴，不如吃秋吉。\n\n菜單: https://www.facebook.com/100063764962092/menu/\n- 雞腿肉 $80/串\n- 豬五花 $90/串\n\n\n![](https://scontent.ftpe7-2.fna.fbcdn.net/v/t39.30808-6/289582140_429281982540630_1852917669230828322_n.jpg?_nc_cat=111\u0026ccb=1-7\u0026_nc_sid=c4c01c\u0026_nc_ohc=RtIEBBHOP9UAX_ES6cO\u0026_nc_ht=scontent.ftpe7-2.fna\u0026oh=00_AfBW9hFk04fkhuBsQiWq2Ukv72vdxrwb6kGP_lYF5cbMlw\u0026oe=64555FFD)\n![](https://scontent.ftpe7-3.fna.fbcdn.net/v/t39.30808-6/289640103_429282499207245_7022422657630070124_n.jpg?_nc_cat=108\u0026ccb=1-7\u0026_nc_sid=c4c01c\u0026_nc_ohc=GK6BgTX6RjIAX-K31jA\u0026_nc_ht=scontent.ftpe7-3.fna\u0026oh=00_AfAGz0sD3TPUHcKXBRWPNBKPgmvNQcjlFBejB8qE75qQqw\u0026oe=6455602E)","lastmodified":"2023-05-07T06:09:55.529193552Z","tags":["bbq"]},"/notes/Resource/Restaurant/%E8%8F%8A%E5%B7%9D%E9%B0%BB%E9%AD%9A%E9%A3%AF%E5%B0%88%E8%B3%A3%E5%BA%97":{"title":"菊川鰻魚飯專賣店","content":"松江南京附近，可以 Inline 預約。乍看 CP 值頗高。\n\n- 名物蒲燒一本鰻三吃 $980 店內主打的餐點之一，是一整尾鰻魚的份量\n![](https://megapx.dcard.tw/v1/images/2870bd74-ea68-4255-8d33-e802e61e22b8/responsive?width=1280)\n\n\nhttps://www.dcard.tw/f/food/p/241885797?cid=CDF4867E-B54D-4F0B-81D6-01BE7DAC077E\n","lastmodified":"2023-05-07T06:09:55.529193552Z","tags":["food"]},"/notes/Resource/Restaurant/%E8%B1%9A%E4%BA%BA%E6%8B%89%E9%BA%B5-%E5%8F%B0%E7%81%A3%E6%9C%AC%E5%BA%97":{"title":"豚人拉麵 台灣本店","content":"跟一蘭差不多，可加湯加料，需加價\n","lastmodified":"2023-05-07T06:09:55.529193552Z","tags":["food"]},"/notes/Resource/Restaurant/%E9%87%91%E8%B3%9E%E5%A3%BD%E5%8F%B8":{"title":"金賞壽司","content":"老闆說鮭魚親子丼升級鮭魚肚+50 = about 470？ \n鮭魚卵不夠新鮮，不要可以少點錢嗎🥲\n\n\n\n","lastmodified":"2023-05-07T06:09:55.529193552Z","tags":["sushi"]},"/notes/Resource/Restaurant/%E9%87%91%E9%96%80%E9%A3%9F%E7%89%A9":{"title":"金門食物","content":"## 山外篇\n津味廣東粥的水煎包好吃\n榕榕園麵館的辣椒醬超讚\n張記牛肉麵記得吃牛肉麵\n野味碳烤的碳烤雞排好吃\n浯日咖啡的乳酪蛋糕很香\n阿芬海產店的炒青菜好吃\n\n## 沙美篇\n小摩洛哥米香蚵爹\n閩式燒餅專賣店\n\n## 金城篇\n牛家莊吃全牛合菜\n(還沒吃的\n金門金山煙燻鵝肉\n荒醣製造\n小島賣派郎\n重慶麻辣魚\n永春廣東粥\n小島商號\n\n## 小金門\n嘉年華冰菓室\n蔡師傅手工麵線","lastmodified":"2023-05-07T06:09:55.529193552Z","tags":[]},"/notes/Resource/Restaurant/%E9%87%91%E9%96%80-%E5%90%83%E5%96%9D%E7%8E%A9%E6%A8%82":{"title":"金門-吃喝玩樂","content":"","lastmodified":"2023-05-07T06:09:55.529193552Z","tags":[]},"/notes/Resource/Restaurant/%E9%90%B5%E7%87%92%E9%A4%83%E5%AD%90":{"title":"鐵燒餃子","content":"\n在新竹市區南部，竹教大附近，百元有找的小吃。\n\nhttps://vivawei.tw/iron-dumpling/\n","lastmodified":"2023-05-07T06:09:55.529193552Z","tags":["food"]},"/notes/Resource/Restaurant/%E9%9B%B2%E5%A3%BD%E5%8F%B8":{"title":"雲壽司","content":"","lastmodified":"2023-05-07T06:09:55.529193552Z","tags":["sushi"]},"/notes/Resource/Restaurant/%E9%AE%A8%E8%B7%A1%E6%97%A5%E6%9C%AC%E6%96%99%E7%90%86":{"title":"鮨跡日本料理","content":"\n江子翠五號出口\n![Menu](https://www.maruplayplay.com/wp-content/uploads/sushikiki34.jpg)\n\n---\n花漾刺身\n![花漾刺身](https://www.maruplayplay.com/wp-content/uploads/sushikiki10.jpg)\n\n鰻魚飯: 下圖應該是大盛 $430。[另有人評論](https://www.walkerland.com.tw/article/view/331364)味道不像肥前屋那麼重。\n\n![](https://www.maruplayplay.com/wp-content/uploads/sushikiki28.jpg)","lastmodified":"2023-05-07T06:09:55.529193552Z","tags":["sushi"]},"/notes/Resource/Restaurant/%E9%BB%91%E5%90%8D%E5%96%AE":{"title":"黑名單","content":"\n\n- 路奇異電力公司: 特別是苗栗店\n- ","lastmodified":"2023-05-07T06:09:55.529193552Z","tags":["food"]},"/notes/Resource/Restaurant/Moni-%E5%92%96%E5%93%A9":{"title":"Moni 咖哩","content":"地點就在台北車站旁邊，方便。 點心看起來不錯。鹹食很普通，不推。\n很想吃鐵鍋舒芙蕾!!\n","lastmodified":"2023-05-07T06:09:55.529193552Z","tags":["food"]},"/notes/Resource/Travel/%E6%97%A5%E6%9C%AC%E6%97%85%E9%81%8A":{"title":"日本旅遊","content":"\n```mapview\n{\"name\":\"Default\",\"mapZoom\":5,\"centerLat\":37.5561912158483,\"centerLng\":138.35449397563937,\"query\":\"\",\"chosenMapSource\":0}\n```\n\n溫泉地圖: https://yadococo.net/?mibextid=Zxz2cZ\n\n---\n# 東京\n\n- [東洋大學](geo:35.7227395,139.7502677)\n- \n### 抹茶\n- [古桑庵](geo:35.6106826,139.6685775)tag:coffee \n- \n### 餐廳\n- 巴西烤肉吃到飽 [シュラスコ\u0026ビアレストラン](geo:35.6775599,139.7693144)tag:food \n\n\n---\n# 大阪\n- 燒肉力丸/烤肉力丸，有很多分店!\n\t- 官網: http://handafood.jp/access/\n\t- 中文 Vlog:  https://www.youtube.com/watch?v=PJ7TLFGoOFk\n\t\t- [燒肉力丸難波道頓堀店](geo:34.668604,135.4985534)tag:bbq\n\n---\n\n\n# 北海道\n## 秋田\n- [ステーキハウス 森吉 森のテラス](geo:40.0898909,140.4098114)tag:bbq\n\n## 仙台\n- 司牛舌: [牛タン焼専門店 司](geo:38.2636452,140.8705123)tag:bbq ，在仙台有多家分店\n\t- Google Map: https://goo.gl/maps/rHR7rjZqH65rzLcr9\n\t- 社團討論: https://www.facebook.com/groups/Tohoku.trip/permalink/3517369665202698/?mibextid=W9rl1R\n- \n- https://natasha-traveler.tw/tsukasa/\n- https://natasha-traveler.tw/tsukasa/","lastmodified":"2023-05-07T06:09:55.529193552Z","tags":[]},"/notes/Resource/Whisky/%E6%A0%BC%E8%98%AD%E5%82%91-%E5%96%AE%E4%B8%80%E9%BA%A5%E8%8A%BD%E5%A8%81%E5%A3%AB%E5%BF%8C":{"title":"格蘭傑-單一麥芽威士忌","content":"Glenmorangie X Single Malt Scotch Whisky\n\n- 買於好事多，跟 \"知多\" 喝起來差不多，CP 值極佳!! \n- 理想價格: 600-650\n\n","lastmodified":"2023-05-07T06:09:55.533193578Z","tags":[]},"/notes/Resource/Whisky/%E9%A1%98%E6%9C%9B%E6%B8%85%E5%96%AE":{"title":"威士忌的願望清單","content":"\n## 待過濾\n- [五支波本威士忌推薦文](https://medium.com/need-a-drink/%E5%8F%AA%E9%9C%80%E4%BA%94%E7%93%B6-%E6%B3%A2%E6%9C%AC-%E5%A8%81%E5%A3%AB%E5%BF%8C-%E7%BE%8E%E5%8F%B0%E5%8F%8B%E5%A5%BD-%E6%8E%A8%E8%96%A6%E6%B8%85%E5%96%AE-my-only-5-bourbon-whisky-i-need-112ff911ffbe)\n\n","lastmodified":"2023-05-07T06:09:55.533193578Z","tags":[]}}