{"/":{"title":"🪴 Main Page","content":"\n我會將我所讀所學的一點點摘要進來，希望有一天他們可以建構起強大的知識網路。\n\n\n\n## 近期閱讀\n\n- [[notes/Resource/Books/The Second Brain]]\n\n\n## 文章引導\n\n- [[notes]]\n- [[tags]]\n- [[notes/Project/Effective C++ Series/Effective C++ Outline]]\n\n\n","lastmodified":"2023-04-21T13:53:16.162319722Z","tags":[]},"/notes/Archive/Special-Syntax-in-Theme-Things-2":{"title":"Special Syntax in Theme Things 2","content":"\n## Basic\n- [ ] to-do\n- [/] incomplete\n- [x] done\n- [-] canceled\n- [\u003e] forwarded\n- [\u003c] scheduling\n\n## Extras\n- [?] question\n- [!] important\n- [*] star\n- [\"] quote\n- [l] location\n- [b] bookmark\n- [i] information\n- [S] savings\n- [I] idea\n- [p] pros\n- [c] cons\n- [f] fire\n- [k] key\n- [w] win\n- [u] up\n- [d] down\n\n\nhttps://github.com/colineckert/obsidian-things\n","lastmodified":"2023-04-21T13:53:16.174319998Z","tags":[]},"/notes/Area/Hugo/Hugo-Publish-Simple-Page":{"title":"以 Hugo 發佈簡單的頁面","content":"## Hugo 建立部落格的範例\n\n直接用 Hugo 建立部落格，不使用 Quartz 的範例:\n\n### Start\n\nhugo new site quickstart  \ncd quickstart  \ngit init  \ngit submodule add https://github.com/theNewDynamic/gohugo-theme-ananke themes/ananke  \necho \"theme = 'ananke'\" \u003e\u003e config.toml  \nhugo server\n\n[https://gohugo.io/getting-started/quick-start/](https://gohugo.io/getting-started/quick-start/)\n\n### 將 Markdown 檔案轉換成 Web Page\n\nhugo server --buildDrafts  \nhugo server -D\n","lastmodified":"2023-04-21T13:53:16.174319998Z","tags":[]},"/notes/Area/Hugo/Hugo-front-matter":{"title":"Hugo 可使用的metadata","content":"\nSource: https://gohugo.io/content-management/front-matter/\n\n舉例:\n\n```yaml\ncategories:\n- Development\n- VIM\ndate: \"2012-04-06\"\ndescription: spf13-vim is a cross platform distribution of vim plugins and resources\n  for Vim.\nslug: spf13-vim-3-0-release-and-new-website\ntags:\n- .vimrc\n- plugins\n- spf13-vim\n- vim\ntitle: spf13-vim 3.0 release and new website\n```\n\n可建立 Obsidian 模板:\n\n```yaml\ntitle: \ndate: {{date}}\ndescription: \n\nslug: alias-name\ntags:\n- default\ncategories:\n- default\n\n```\n\n本頁所使用的 metadata: \n```yaml\ntitle: \"可使用的metadata\"\ndate: 2023-04-09\nslug: usable meta data # 網址變成此名稱\ncategories:\n- blog\n```\n\n這裡，我讓檔案名稱變成\n- filename: `Hugo front matter.md` \n- title: `可使用的metadata` \u003e 頁面標題\n- slug: `usable meta data` \u003e 連結名稱\n\n\n## Category vs. Tag\n\n在打造第二大腦中，作者提出 Tag 是一種打破資料夾邊界的連結方式。我希望，在我的部落格中，我希望讓網頁會 Category 做資料夾壁壘的分類，有必要時再以 tag 打破邊界。\n\n但似乎 quartz 支援的只有 tags 而沒有 categories。我想參考這篇文章試試看能不能打開該功能: \nhttps://ithelp.ithome.com.tw/articles/10244921\n\n## Description\n沒有用，不會改變預覽頁面的內容。\n","lastmodified":"2023-04-21T13:53:16.174319998Z","tags":[]},"/notes/Area/Obsidian/Obsidian-Plugins":{"title":"Obsidian Plugins","content":"## Theme\n- 當前用的是 Thing2\n- [minimal](https://minimal.guide/Home) 也是熱門的主題，且與許多 plugin 相容\n\t- 但是 header 之間不同階級沒有大小之分，我不喜歡，要用需要改 CSS。\n\n\n\n## Plugin\n- Obsidian Dataview mode: like notion https://ithelp.ithome.com.tw/articles/10279262\n\n\n","lastmodified":"2023-04-21T13:53:16.174319998Z","tags":[]},"/notes/Area/Obsidian/Sync-Obsidian":{"title":"Obsidian Publish 的替代選擇","content":"想在 IOS 上面也有 Sync 的 Obsidian 可以用!\n\n社群的作法是裝 ISH 以 Git 同步，我想實驗用 Terminus (比起 ISH 有在維護)\n\n- [Sync with git on iOS for free using iSH](https://forum.obsidian.md/t/mobile-sync-with-git-on-ios-for-free-using-ish/20861)\n- [Setting up iOS git-based syncing with mobile app (using Working Copy)](https://forum.obsidian.md/t/mobile-setting-up-ios-git-based-syncing-with-mobile-app-using-working-copy/16499)\n","lastmodified":"2023-04-21T13:53:16.174319998Z","tags":[]},"/notes/Area/Quartz/%E4%BD%BF%E7%94%A8-Quartz-%E5%BB%BA%E7%AB%8B%E9%83%A8%E8%90%BD%E6%A0%BC":{"title":"使用 Quartz 建立部落格","content":"\n\n## Install\n\n1. Git\n2. Go lang\n3. Hugo: 需要手動加環境變數\n4.  `go-obsidian`\n    ```go\n    go install github.com/jackyzha0/hugo-obsidian@latest\n    ```\n5. **Optional**  `make` `: Windows 下須使用 MinGW 安裝，參考: [C++ 開發環境 在 Windows 11 中安裝 mingw-w64 及設定環境變數](http://kaiching.org/pydoing/cpp-guide4/how-to-install-mingw-w64-and-set-environment-variable.html)\n\nHugo 需要以 PowerShell](https://learn.microsoft.com/en-us/powershell/scripting/install/installing-powershell-on-windows) 或 WSL , Git Bash 這種 linux-based terminal 運行。\n\n## Start to Quzrtz\n官方網站有相關的教學: \n- https://quartz.jzhao.xyz/notes/setup/\n- https://quartz.jzhao.xyz/notes/obsidian/\n\n以下我將擷取最短步驟\n### 摘要步驟\n\n1. Fork quartz 的 Github 專案，並 clone 到 Local。\n2. 在 Clone 下來的倉庫中找到資料夾 `content`\n3. 在 `content` 資料夾中創建 Obsidian 倉庫，或是把既有的倉庫內容放到 content 裡面。\n4. 將 Obsidian 倉庫轉換成 Hugo 可用的\n\n    ```bash\n     hugo-obsidian -input=content -output=assets/indices -index -root=.\n    ```\n\n    需要注意，markdown 檔名不可以有 `.`，且每一篇文章都要有 metadata: 在頁首有 `title` 的資訊，如下: \n\n    ```markdown\n    ---\n    title: \"Private Stuff\"\n    ---\n    ```\n\n    其實有更多的 meta-data 可以設定，可以看 quartz 給的範例。由於使用 quartz 創建模板必須要 metadata，[作者建議](https://quartz.jzhao.xyz/notes/obsidian/)可以直接在 Obsidian 裡面創建模板，讓每新增一個模板都有這些資訊! \n\n5. 啟用 Hugo Server\n\n    ```bash\n     hugo server --enableGitInfo --minify \t# render faster\n     hugo server --disableFastRender \t\t# search bar will enable\n    ```\n\n\n## 關於 Obsidian 模板功能\n- 可以參考此文介紹如何建立模板 [【Obsidian 使用教學】筆記篇 05 — 結合資訊處理流程，讓筆記的 Metadata 變得更詳細](https://medium.com/pm%E7%9A%84%E7%94%9F%E7%94%A2%E5%8A%9B%E5%B7%A5%E5%85%B7%E7%AE%B1/obsidian-%E4%BD%BF%E7%94%A8%E6%95%99%E5%AD%B8-%E7%AD%86%E8%A8%98%E7%AF%87-05-%E7%B5%90%E5%90%88%E8%B3%87%E8%A8%8A%E8%99%95%E7%90%86%E6%B5%81%E7%A8%8B-e6a953438f43)\n- 要注意，插入模板的時候，需要打完檔案名稱，並把 Insert 的鼠標要在 Header 1 下的第一行。\n\n## 發佈到 Github Page\n\n參考 \n\n![[Publish Quartz to Github Page]]\n\n\n## 修改首頁\n\n如果想在首頁放置一些連結，引導到特定頁面，需要注意以下幾點: 雙向連結內放的是「相對於該頁面的路徑」，路徑對應的是檔案名稱。\n\n1.  當檔案名稱有空白時，網址會以 `-` 取代空白，但在雙向連結的撰寫中不可以寫 `-`。\n```\n[[notes/Area/PKM/Setup Quartz]] # OK  \n[[notes/Area/PKM/Setup-Quartz]] # Broken internal link\n```\n2.  注意結尾不要多加反斜線    \n3.  主頁相對於各檔案都是以 `note/` 開始\n","lastmodified":"2023-04-21T13:53:16.174319998Z","tags":[]},"/notes/Area/Quartz/Publish-Quartz-to-Github-Page":{"title":"將 Quartz 發佈到 Github Page","content":"由於我對 github action 不熟悉，在設置到 github page 的時候遇到了一點困難...。\n\n首先，如果專案是從 templage fork 過來的，它應該分成 `hugo` 跟 `master` 兩個 branch。其中\n\n- `hugo`: 存放 config, markdown files (`content` 底下) 的地方\n- `master`: 利用 github action 把專案內容轉成靜態網頁\n\n我因為是 clone 下來再 push 到自己的專案，沒有遵守這兩個命名方式而遇到了一點困難。在我的專案中，`main` 對應的是存放 markdown files (轉換前) 的 page，`publish` 才是 github page 再生成時所根據的 branch。\n\n## 設置 Github Action \n\n如作者的[教學](https://quartz.jzhao.xyz/notes/hosting/)所說，首先要打開 workflow permission。位置是 `Setting \u003e Action \u003e General`。\n\n![Set workflow Permission](https://quartz.jzhao.xyz/notes/images/github-actions.png)\n\n## 設置 Github Page \n\n在 `Setting \u003e Pages` 當中，將設置 Source 項目的 branch 設成 `master` (我則是設成 `pubslish`)。Domain name 除非自己有特別買網域，否則不用動。\n\n![Github page setting](https://quartz.jzhao.xyz//notes/images/github-pages.png)\n\n## Domain Name \n\n一共會影響兩個地方:\n\n- `config.toml`\n- `.github/workflows/deploy.yaml`\n\n如果用 github 預設的網址會是 `\u003cYOUR-GITHUB-USERNAME\u003e.github.io/\u003cProject-Name\u003e`。`config.toml` 的設定很簡單，就寫這個專案 root 網址為何:\n\n```yaml\nbaseURL = \"https://\u003cYOUR-GITHUB-USERNAME\u003e.github.io/\u003cPROJ\u003e/\"\n```\n\n`.github/workflows/deploy.yaml` 則要小心，這裡直接以我的為例，需要改兩個地方。\n\n```yaml\non:\n  push:\n    branches:\n      - main # 作者的範例是 hugo, 因為我有換 branch name 所以要改      \n```\n\n這樣，每當 push 行為發生在 `main` branch 上，就會觸發這個 action。 \n\n\n```yaml\n      - name: Deploy\n        uses: peaceiris/actions-gh-pages@v3\n        with:\n          github_token: ${{ secrets.GITHUB_TOKEN }}\n          publish_dir: ./public\n          publish_branch: publish\t# 作者預設是 master\n          cname: brainynight.github.io # 不用把 proj name 也寫上去\n```\n\n## 預覽變更\n\nGithub Action 當中，已經把建立 graph (`hugo-obsidian`) 的步驟也包含上去了。但要發布之前我們總需要自己本地先看看。\n\n作者其實有 makefile，應該可以 `make server`，會自動建立 graph 和 `hugo server`，或是懶得安裝 `make` 也可以直接打指令。以 windows 想複製 D 槽檔案為例: \n\n```bash\ncp /d/Database/*.md content/notes\nhugo-obsidian -input=content -output=assets/indices -index -root=.\nhugo server --disableFastRender\n```\n\n","lastmodified":"2023-04-21T13:53:16.174319998Z","tags":["Quartz"]},"/notes/Project/Effective-C++-Series/%E6%80%9D%E7%B6%AD%E8%AA%A4%E5%8D%80-%E7%89%A9%E4%BB%B6%E5%BE%88%E5%B0%8F%E5%B0%B1%E5%8F%AF%E4%BB%A5-Pass-By-value":{"title":"思維誤區-物件很小就可以 Pass By value","content":"有三個主因: \n1. 並非「該物件/container」**看起來**很小，用 Pass by value 就沒有問題。許多  STL Container 在實作上的大小也就一個 Pointer 大一點，但 Copy Container 卻有「複製每一個 Pointer 所指向的物件」的風險在。\n2. 視 Compiler 而定，有些 Compiler 對待 Custom class 跟 built-in class 的態度大不相同，即使底層表述(underlying representation) 相同，仍可能以不同的操作對待，導致 Copy 在 Custom Class 就是比較慢。\n3. Type 實作可能發生改變，現在 Copy 的代價不昂貴，不代表以後不會。\n\n## Pass By Value 的代價\n[[The Copying in Pass by value]]\n","lastmodified":"2023-04-21T13:53:16.174319998Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/%E6%89%93%E7%A0%B4-Constness-%E9%99%90%E5%88%B6":{"title":"打破 Constness 限制","content":"\n### Physical Constness\n\u003e 編譯器堅守的觀點: Physical Constness，又稱 Bitwise constness。Const member function 不可以修改任何 non-static member data。\n\n然而，請看下例: `operator[]` 確實不會更動到 member data，可以通過 Bitwise Testing，卻把「改動權」暴露給 Client 端，造成不應該的賦值行為。\n- [[Item28 Avoid returning handles to object internals]]\n\n```cpp\nclass CTextBlock {\n\npublic:\n    // inappropriate (but bitwise const) declaration of operator[]\n    char\u0026 operator[](std::size_t position) const\n    { return pText[position]; }\n    \nprivate:\n    char *pText;\n}\n\nconst CTextBlock ctb(\"World\");\nctb[0]='F'; // Become \"Forld\"\n```\n此例應該將回傳型態修改為 `const char\u0026`。\n\n編譯器堅守的 Bitwise constness 觀念，造成 Const Function 作用過於綁手綁腳，甚至在 Const \u0026 Non-Const function 之間我們可能需要 Own 兩份相似的 Code! \n接下來將說明 `mutable` 與 const cast，他們將幫助我們破除 const 的限制，使程式設計更加靈活。\n\n### Logical Constness\n\u003e 概念上的常數性 (Conceptual Constness)\n\n我對這個論點的解讀是，某些 data 是藏於封裝底下，沒有暴露給 User 修改的。這種 member data 在 logical constness 的觀念下是可被修改的。\n書中舉例，若我們在 `CTextBlock` 當中有一個快取 (cache) 的 member data ，用來記當前字串的長度。當字串沒有修改長度的行為(增加/減少)時，此快取都是有效的。但若有修改行為，則在 `length()` 被 Query 時，我們會需要更新這個快取。\n\n在 Bitwise Constness 的觀念下，修改這個快取用途的 member data 是不合法的，且這也是 Compiler 的觀點。\n解決辦法是，使用關鍵字 `mutable` 宣告這些有資格在 const function 內被改動的 data，`mutable` 使得 const function 在實踐上有討價還價的空間。\n\n\u003e `mutable` 釋放 non-static member data 的 bitwise constness 約束 (釋放 member data 的不可變動性)。\n\n\n### Avoiding Duplication in const and Non-const Member Functions\n\u003e 當 const 和 non-const member function 有等價的實作時，讓 non-const 呼叫 const 可以避免 duplicated code。\n\n若我們在 const \u0026 non-const function 當中，都有相同的程序要做: 邊界檢查、write log、verty data...，即使子步驟都可以抽出來，還是造成「走 flow 的流程」會重複在兩個 function 當中。\n\n```cpp\nclass TextBlock \n{\n\tconst char\u0026 operator[](std::size_t position) const;\n\tchar\u0026 operator[](std::size_t position);\n}\n```\n\n我們該做的是，把所有的東西寫在其中一個，而另一個去呼叫寫著 flow 的 function。這說明了我們的一個需求: 去除 Constness!\n\n我懷疑這個手法在 C++11 \u0026 14 可能有其他解，這裡先跳過細究。簡單來說就是透過 `const_cast` 將 const function 的結果再轉成非 const。\n\n```cpp\nclass TextBlock {\npublic:  \n\t// same as before\n    const char\u0026 operator[](std::size_t position) const {\n        return text[position];\n    }\n\t// now just calls const op[]\n    char\u0026 operator[](std::size_t position) \n    {\n        // cast away const on op[]’s return type\n        // add const to *this's type, call const version of op[]\n        return const_cast\u003cchar\u0026\u003e(\\\n\t        static_cast\u003cconst TextBlock\u0026\u003e(*this)[position]\n\t\t);\n    }\n};\n```\n ","lastmodified":"2023-04-21T13:53:16.174319998Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/%E7%82%BA%E4%BB%80%E9%BA%BC%E8%A6%81%E7%94%A8%E7%8D%A8%E7%AB%8B%E5%8F%A5%E5%B0%87%E7%89%A9%E4%BB%B6%E6%94%BE%E5%85%A5-Smart-Pointer":{"title":"為什麼要用獨立句將物件放入 Smart Pointer","content":"\n\u003e 盡可能確保 `new` 出來的物件，可以立即被放入 smart pointer 裡面，避免任何額外的步驟。只要有多餘的步驟，就可能因為意外而使得 smart pointer 沒有真正掌控到資源。\n\n以獨立一句話將 newed 物件加入 smart pointer，格式如下\n\n```cpp\nstd::shared_ptr\u003cWidget\u003e pw(new Widget);\nprocessWidget(pw, priority());\n```\n\n---\n\n其原因是，如果像以下寫法\n```cpp\nprocessWidget(std::shared_ptr\u003cWidget\u003e pw(new Widget), priority());\n```\n\n編譯器要做的有三件事\n1. 呼叫 `priority`\n2. 執行 `new` \n3. 呼叫 smart pointer constructor\n\n而我們無法確保這三件事的最終順序為何，必然的關係只有 「會先 `new` ，再執行 smart pointer constructor」。而 `priority` 是**可能**安插於 new 之後的。\n\n1. `new` \n2. `priority` (發生錯誤)\n3. smart pointer constructor\n\n如果不幸的，編譯器選擇這種順序，並且在把物件放入 smart pointer 之前發生了錯誤，這塊記憶體將沒有 smart pointer 協助銷毀! \n","lastmodified":"2023-04-21T13:53:16.174319998Z","tags":[]},"/notes/Project/Effective-C++-Series/%E7%82%BA%E5%A4%9A%E5%9E%8B%E7%94%A8%E9%80%94%E7%9A%84%E5%9F%BA%E7%A4%8E%E9%A1%9E%E5%88%A5%E5%AE%A3%E5%91%8A-virtual-%E8%A7%A3%E6%A7%8B%E5%BC%8F":{"title":"為多型用途的基礎類別宣告 virtual 解構式","content":"\n## 多型\n多型有個特點: Base Class 的存在是為了「經由 Base Class Interface 處置 Drived Class Object」，以下例來說， `TimeKeeper` 是一個 Polymorphic Base Class，所以持有一個 `TimeKeeper` Pointer 就可以處理 `WaterClock`, `WristWatch` 物件，這就是上面那句話的意思。\n\n```cpp\nclass TimeKeeper {\npublic:\n\tTimeKeeper();\n\tvirtural ~TimeKeeper();\n};\nclass AtomicClock: public TimeKeeper { ... };\nclass WaterClock: public TimeKeeper { ... };\nclass WristWatch: public TimeKeeper { ... };\n\nTimeKeeper* getTimeKeeper(); \n// Returned pointer may be AtomicClock, WaterClock, WristWatch\n// But they can be owned by base class \"TimeKeeper\"\n// This is polymorphy.\n```\n\n繼承與多型之間並非充分必要條件，**非所有的 Base Class 都是作為多型使用**。\n像是 [[Item47 Use traits classes for information about types]] 的 `input_iterator_tag`，繼承更像是 \"enable 某種特性\" 的用途。 \n\n\n## 多型的 Base Class 沒有 Virtural Destructor 又如何\n多型 (polymorphic) 的手法使我們可以持有 base class 的 Pointer 指向各種 child class 的實作。工廠(Factory) Pattern 就是典型的實作。\n\n\u003e [!question]\n\u003e 為了遵守 factory function 的規矩，哪來的規矩?\n\n為了遵守 factory function 的規矩，factory function 回傳的物件必須位於 heap (在 function 中被 `new` 出來的)，被 `new` 出來的物件必須手動刪除它。\n```cpp\nTimeKeeper* ptk = getTimeKeeper();\ndelete ptk;\n```\n\n儘管 [[Item13]] 和 [[讓介面容易被使用]] 說明了依賴 client 做 delete 有潛在的危險跟不確定，這裡要說明的是更嚴重、更根本性的問題。\n- 我們宣告的是 **Base class pointer**，指向的是 **child class 物件**。\n- Base class 擁有一個 non-virtural 的 destructor\n- C++ 明白的告訴我們，當 child 物件經由擁有 non-virtural destructor 的 Base class pointer 持有，而這個 pointer 被刪除時，屬於 **Undefined behavior**\n\n此 Undefined Behavior **通常**會發生的是，屬於 Base class 部分成功銷毀，只屬於 Child Class 的 member data **沒有被銷毀**，造成**部分銷毀**的詭異狀況。\n\n要消除這種作法的解答就是，給 Base class 的 destructor 設置 `virtural`。\n\n\u003e 一個 Class 若有帶有 `virtural` 的函式，幾乎可以確定**該有**會帶有 `virtural` 的 destructor。如果一個 class 不帶有 `virtural` function，通常代表它不意圖被當作 base class。\n\n (實作都寫完在 base 了，還特意搞繼承 override 幹嘛?)。然而，`virtural` 也不應該亂用: [[Do not Declare Virtural Function in Non-polymorphic Base Class]]。\n\n## 企圖以多型設計架構前，檢查 Base Class 的 Destructor 是否為 Virtual\n\n如果不是 virtural destructor，請想別的辦法!! \n接續前面章節，**並非** class 中沒有 `virtural` function，**就不需要** 考慮 non-virtural destructor 的問題。\n\n以例子來說，若有個 `SpecialString` 繼承 `std::string` (non-virtural destructor)，在 `new` 一個 `SpecialString` 之後指給 `std::string` pointer 之後就會遇到 Undefined Behavior 的問題! \n\n```cpp\nSpecialString *pss = new SpecialString(\"Impending Doom\");\nstd::string *ps;\n\nps = pss;\ndelete ps; // undefined behavior\n```\n\n同樣需要注意的如 `std::vector`, `std::list`, `tr1::unordered_map` ([[Item55 Familiarize yourself with Boost]]) 等。如果你想繼承一個 STL container，但它沒有 virtural destructor，請千萬不要嘗試繼承它! 這只會帶來災難。\n\n## 想要一個抽象類嗎\n想要一個抽象類，卻苦於沒有人選(function)「被 virtural」? 考慮 Destructor 吧: [[Pure Virtual Destructor]]\n\n\n","lastmodified":"2023-04-21T13:53:16.174319998Z","tags":[]},"/notes/Project/Effective-C++-Series/%E8%A7%A3%E6%A7%8B%E5%BC%8F%E8%88%87%E7%95%B0%E5%B8%B8":{"title":"解構式與異常","content":"\n## 情境: 當Destructor 必須執行某項會丟Exception 的程序\n舉例，我們有一個資料庫連線的 class `DBConnection`，這類資源管理的 Class 在 [[Chapter3]] 中會有更詳細的探討。\n```cpp\nclass DBConnection {\npublic:\n...\nstatic DBConnection create();   // function to return DBConnection objects; params omitted for simplicity\nvoid close(); \n// close connection; throw an exception if closing fails\n};  \n```\n\n\n### 直接 Catch Exception\n為了防止 client 沒有 close connection 就直接刪除物件，我們需要在 destructor 呼叫 `close`，然而這個 function 有丟出 exception 的風險。\n有兩種做法可以簡單的解決\n1. 使用 `std::abort` 提前中止程式，它可以搶在 Exception 傳出去之前，也就是 Undefined Behavior 傳出去之前，強迫程式結束。\n\t```cpp\nDBConn::~DBConn() {\n\ttry { db.close(); }\n\tcatch (...) {\n\t\t// make log entry that the call to close failed;\n\t\tstd::abort();\n\t}\n}\n\t```\n2. 吞下異常。一般來說，這是個壞主意，它抑制了錯誤被知道的機會。\n\t```cpp\nDBConn::~DBConn() {\n\ttry { db.close(); }\n\tcatch (...) {\n\t\t// make log entry that the call to close failed;\n\t}\n}\n\t```\n\n哪種方法好，端看情境如何取捨。不過此兩者做法都不是根本解決之道。\n\n## 解決方法: 讓 Cilent 自己接住 Exception\n更好的做法是重新設計 Interface，讓 client 端自己 `close`，對 Exception 做反應。並在 destructor 當中再設一道確保關閉的雙重保障 -- 如果客戶還是忘了關，再讓 destructor 動手吧! \n\n\n## 質疑\n- 轉移責任到 Client 身上的嫌疑? 並沒有，因為 destructor 中也是有一道 Check。\n- 違反[[讓介面容易被使用]]? \n\n如果某個操作有 raise exception 的風險，又必須處理該 exception，這個異常必須來自 destructor 之外的某個 function (此例: 來自 `close`)，而這有讓 client 端接手的必要性，將它轉移出 destructor 能避免 undefined behavior 的發生有更大的價值。\n","lastmodified":"2023-04-21T13:53:16.174319998Z","tags":[]},"/notes/Project/Effective-C++-Series/%E8%A8%AD%E8%A8%88%E6%96%B0-Class-%E7%9A%84%E6%BA%96%E5%89%87":{"title":"設計新 Class 的準則","content":"在設計 class 之前，思考以下問題\n- 記憶體如何產生跟銷毀? (參見第八章)\n- 物件初始化與賦值的差別? Constructor \u0026 Assignment\n\t-  [[Effective C++ Outline#條款4 確定物件在使用前已經初始化 |條款4 確定物件在使用前已經初始化]]\n- Pass by value 對它代表甚麼? Copy constructor\n- Member data 的合法值?\n\t- 在不管是 constructor, assignment, setter function 在設 data 時，都需要進行錯誤檢查。\n\t- 這意味著你需要考量函式拋出的意外。\n- 它需要配合某個繼承圖系(inheritance graph) 嗎?\n\t- 會受到父輩們的約束，特別是函式是 virtural or non-virtual [[Item34 Differentiate between inheritance of interface and inheritance of implementation]]、[[Item36 Never redefine an inherited non-virtual function]]。\n\t- 如果允許其他類別繼承此 class，請將必要的函式宣告為 virtual，特別是 destructor。\n\t\t- [[Effective C++ Outline#條款7 為多型用途的基礎類別宣告 virtual 解構式|條款7 為多型用途的基礎類別宣告 virtual 解構式]]\n- 需要考量轉換嗎? 隱性轉換與顯性轉換?\n- 甚麼運算子與函式對此新類別式合理的?\n\t- [[Item23 Prefer non-member non-friend functions to member functions]]\n\t- [[Item24 Declare non-member functions when type conversions should apply to all parameters]]\n\t- [[Item26 Postpone variable definitions as long as possible]]\n- 什麼標準宣告式是需要駁回的? 請用 `delete` 明確刪除它。\n- 哪些 member 需要暴露出來? (public/private/protected)\n- 什麼是它的未宣告介面(undeclared interface)?\n\t- 這我看不懂。\n- 這個新的 class 有多一般化? 若要定義的是 type family (一堆 type) ，是否該採用 class template?\n- ","lastmodified":"2023-04-21T13:53:16.174319998Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/%E8%AE%93%E4%BB%8B%E9%9D%A2%E5%AE%B9%E6%98%93%E8%A2%AB%E4%BD%BF%E7%94%A8":{"title":"Item 18 Make interfaces easy to use correctly and hard to use incorrectly","content":"\n## 用 `struct` 包覆簡單的資料結構可以帶來可讀性\n\n考量下面的例子: \n\n```cpp\nclass Date {\npublic:\n\tDate(int month, int day, int year);\n}\nDate(3, 31, 1999); // 正確\nDate(30, 3, 1999); // 可能會誤打\nDate(3, 40, 1999); // 可能有無效值\n```\n\n如果我們改以 `struct`如下，你幾乎不會犯下寫錯格的錯，Compiler 會自動提醒! 甚至可以在 Struct 內簡單的做數值檢驗。\n\n```cpp\nstruct Month;\nstruct Day;\nstruct Year;\n\nclass Date {\npublic:\n\tDate(Month m, Day d, Year y);\n}\n\nDate(Month(3), Day(31), Year(1999)); // 正確\nDate(Day(3), Month(31), Year(1999)); // 型別錯誤\n```\n\n\n## 以函式取代物件\n\n像是月份這樣有一定的範圍，甚至可以直接列舉 12 月份，Client 端透過介面得到月份物件，幾乎沒有錯誤數值的問題!!\n\n類似用法可以參見 [[Static Object]] 當中的 non-local static object 初始化問題。\n\n```cpp\nclass Month {\npublic:\n\tstatic Month Jan() {return Month(1)};\n\tstatic Month Feb() {return Month(2)};\n\t...\nprivate:\n\texplicit Month(int m);\n}\nDate(Month::Jan(), Day(30), Year(1999));\n```\n\n## 和內建型別的行為一致，不要搞怪\n\n當有和 STL lib 相似的屬性時，盡量用一樣的形式。\n\n## 任何介面如果有要求客戶「記得做」某件事，就有「不正確使用」的傾向，因為客戶可能會忘記。\n\n例如: 比起回傳一個 raw pointer 並期許客戶端記得刪除記憶體，回傳 smart pointer 能解決問題。\n\n防範客戶端可能發生的錯誤是有代價的，像是 Shared pointer，它比原本的體積更大、且更慢。但在許多程式中這些成本的影響並不顯著，防範客戶端愚蠢行為帶來的益處卻極為顯著。\n\n","lastmodified":"2023-04-21T13:53:16.174319998Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/%E8%AE%93%E4%BB%8B%E9%9D%A2%E6%98%93%E6%96%BC%E8%A2%AB%E4%BD%BF%E7%94%A8":{"title":"讓介面易於被使用","content":"## Return Const Value\n避免回傳值被修改，如此例中，類別 `Rational` (有理數) 的乘積符號禁止其回傳值被賦予值 (assignment)。\n\n```cpp\nclass Rational { ... }; \nconst Rational operator*(const Rational\u0026 lhs, const Rational\u0026 rhs);\n```\n\n聽起來有點怪，但它可以預防 client 端寫出這種 code: \n```cpp\nRational a, b, c;\n(a*b) = c;\n\nif (a*b = c) { ... };\n```\n\n我想，作者的舉這個例子有 Defensive programming 的概念在。如若這些變數是內建型別 (ex. int)，這種寫法直接就會被擋掉。但像此例，它們是 User-defined 的型別，對於設計 class 的 designer 而言，最好將這種無意義的行為擋掉。","lastmodified":"2023-04-21T13:53:16.174319998Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/Const-in-C++":{"title":"Const in C++","content":"\n#### Const Iterator\n同理上述，宣告一個 iterator 為 `const` 表示這個 iterator 不能改變指向的對象，但是指向的對象之內容本身可以變。 \n```cpp\nconst std::vector\u003cint\u003e::iterator iter = vec.bgein();\n```\n如果想要指向一個不可被改變內容的物件，需要使用 `const_iterator`\n```cpp\nstd::vector\u003cint\u003e::const_iterator citer = vec.bgein();\n```\n\n#### Return Const Value\n[[讓介面易於被使用]]\n\n#### Const member function\n[[Const member function]]\n\n#### Const Argument\n在真實的程式設計中，比較多用於 function argument 是 const pointer / const referecne。\n如下例: `print` function 定義了一個 const reference 的 argument，當它在調用 operator `[]` 的時候，就會用到上面的 API。且定義 const return value 可以避免錯誤的寫入值，達成 const object 的目的。\n```cpp\nvoid print(const TextBlock\u0026 ctb) // in this function, ctb is const \n{ \n\tstd::cout \u003c\u003c ctb[0]; // calls const TextBlock::operator[] \n\tctb[1] = 'x';        // raise error!!!\n}\n```\n\n#### 打破 Constness 限制\n前面說的是對於 Client 端，我們須保持資料的不可變動性。\n\n然而在類別內部的設計中，基於維護性、或某些理念，我們希望它不要那麼死板，比起 Compiler 所堅持的 Constness，或許邏輯上的 Constness 更加重要。接下來，將說明 Compiler 認知 Constness 為何 ，與如何「部分的」打破 Const 限制。\n[[打破 Constness 限制]]\n","lastmodified":"2023-04-21T13:53:16.174319998Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/Const-member-function":{"title":"Const member function","content":"\n\u003e The purpose of const on member functions is to identify which member functions may be invoked on const object.\n\n使 Interface 意圖更加清楚，有兩個重要的優點\n1. 可知道哪個 function 會更動到物件\n2. 改善 C++ 程式效率與 \"pass by reference to const\" 息息相關，使 function 可操作 Const Object 。\n\n直接看例子: 我們定義了如下的 Interface。\n\n```cpp\nclass TextBlock\n{\npublic:\n\t// operator[] for const objects\n\tconst char\u0026 operator[](std::size_t position) const\n\t{ return text[position]; }\n\t\n\t// operator[] for non-const objects\n\tchar\u0026 operator[](std::size_t position) \n\t{ return text[position]; }\nprivate:\n\tstd::string text;\n};\n```\n\n在 Client 端，`const TextBlock` 與 `TextBlock` 物件會 call 到的  `TextBlock::operator[]` **是不同的**!! 有宣告 Interface 的第一條 (const function)，才有辦法操作 `const TextBlock` 的物件。\n```cpp\nconst TextBlock ctb(\"World\");\nstd::cout \u003c\u003c ctb[0]; // calls const TextBlock::operator[]\n\nTextBlock tb(\"Hello\");\nstd::cout \u003c\u003c tb[0]; // calls non-const TextBlock::operator[]\n```\n\n\n\u003e [!question] \n\u003e 如果宣告 Const 但是不定義 const TextBlock 會怎樣?\n","lastmodified":"2023-04-21T13:53:16.174319998Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/Copying-Function":{"title":"Copying Function","content":"\n\u003e Effective C++ 中，Copying Function 指的是 Copy construcot \u0026 Copy Assignment\n\n1. 當 Programmer 自己定義 Copying function 時，Compiler 不會警告你出錯!\n2. 在繼承的架構中\n\t1. 不只屬於 Child Class 的 member data 要全部 copy\n\t2. 還要記得 call Parent Class 的 copying function。\n\n\t```cpp\n// Copy Construcotr \nPriorityCustomer::PriorityCustomer(const PriorityCustomer\u0026 rhs)\n: Customer(rhs), // invoke base class copy ctor\npriority(rhs.priority)\n{\n\tlogCall(\"PriorityCustomer copy constructor\");\n}\n\n// Copy Assignment\nPriorityCustomer\u0026\nPriorityCustomer::operator=(const PriorityCustomer\u0026 rhs)\n{\n\tlogCall(\"PriorityCustomer copy assignment operator\");\n\tCustomer::operator=(rhs); // assign base class parts\n\tpriority = rhs.priority;\n\treturn *this;\n}\n\n\t```\n3. Copy Constructor 與 Copy Assignment 不應該 Call 彼此，如果有 Reusable Code，應該另外抽一個 private function 去共用。","lastmodified":"2023-04-21T13:53:16.174319998Z","tags":["cpp","tofix"]},"/notes/Project/Effective-C++-Series/Default-Generated-Functions":{"title":"Default Generated Functions","content":"\n```cpp\nclass Empty; // you declare, but implement nothing. \n\n// Compiler silently create.\nclass Empty {\npublic:\n\n    Empty() { ... } // default constructor\n    Empty(const Empty\u0026 rhs) { ... } // copy constructor\n    ~Empty() { ... } // destructor — see below for whether it's virtual\n    Empty\u0026 operator=(const Empty\u0026 rhs) { ... } // copy assignment operator\n}\n\nEmpty e1;      // default constructor\n\t\t\t   // destructor\nEmpty e2(e1);  // copy constructor\ne2 = e1;       // copy assignment\n```\n\n\n- Default constructor (without parameter) \u0026 destructor\n\t- 給編譯器放一些喚起 base class, non-static member data constructor \u0026 destructor 的地方。\n\t- Compiler 生成的 destructor 是一個 non-virtural\n\t  [[為多型用途的基礎類別宣告 virtual 解構式]]\n\t- 只要有宣告 Constructor，編譯器就不會幫我們多掛 default constructor 上去。\n- Copy Constructor \u0026 Copy Assignment: 將 source 物件的每一個 non-static member data copy 過去。\n\n## Default Copy Assignment\n儘管 Copy Assignment `operator=` 也可以自動生成，卻是有條件的自動生成，只有當自動生成的代碼合法時才會生成。\n\n但 default copy assignment 常很有機會變得幾乎無用武之地。\n1. 當 User-defined Class 有 member data 是 Reference 或 `const`，自動生成的 code 會不合法。\n2. 當 base class 把 copy assignment 宣告成 private，compiler 無法喚起 parent 的 private function，直接裝死。\n\n在 C++ 當中，一旦 Reference 被宣告，是不允許改指向不同物件的，而 Compiler 更不會自動去修改 \"被 Reference 物件\" 的內容。這種情況，Compiler 會直接拒絕生成 Copy assignment。\n如果想讓一個有 reference member data 的 class 有 Copy assignment，需要自行實作。相似的，更改 `const` 成員是不合法的，需自行實作。","lastmodified":"2023-04-21T13:53:16.174319998Z","tags":[]},"/notes/Project/Effective-C++-Series/Deleted-Function":{"title":"Deleted Function","content":"\n\n```cpp\nclass A{    \npublic:\n  A(int x) : m(x) {}\n  A\u0026 operator = (const A \u0026) = delete;  // Declare the copy assignment operator\n                                       // as a deleted function.\n  A(const A\u0026) = delete;                // Declare the copy constructor\n                                       // as a deleted function.\n\nprivate:\n  int m;\n};\n\nint main(){\n  A a1(1), a2(2), a3(3);\n  a1 = a2;     // Error, the usage of the copy assignment operator is disabled.\n  a3 = A(a2);  // Error, the usage of the copy constructor is disabled.\n}\n```\n\n\n## 舊的做法\n以 C++11 為分水嶺，C++98 只能透過宣告 private 藏住不要 Compiler 生成的 function。\n確實 client code 會無法呼叫。但這並不絕對安全，因為 member function 跟 frient function 還是可以呼叫 private function。更安全的做法是，宣告 private 後故意不實作。\n","lastmodified":"2023-04-21T13:53:16.174319998Z","tags":[]},"/notes/Project/Effective-C++-Series/Do-not-Declare-Virtural-Function-in-Non-polymorphic-Base-Class":{"title":"Do not Declare Virtural Function in Non-polymorphic Base Class","content":"\n\u003e 無端將不該擁有 `virtual` 的 class 宣告 virtual，與無端將所有的 function 宣告成 virtual，都是有毒的。 \n\n當類別不作為 Base Class，或是不作為多型時的基本 Class 時，不應該使用 virtual。\n原因是，`virtual` 背後是以 vptr (virtual table pointer) 和 vtbl (virtual table) 實作 virtual，需要耗費額外的記憶體。\n1. 將不能把資料結構式傳給其他語言 (C, FORTRAN) 撰寫的 function，因為它們沒有 vptr 的對應內容\n2. 增加物件大小，書中舉例一個 `Point` 物件，其中擁有兩個 int (64bits, in 32 bits system)，增加一個 `virtual` (一個 vptr) 將使 memory 達到 96 bits，相當其物件大小的 50%，在 64bits system 甚至達到增加 100%。\n","lastmodified":"2023-04-21T13:53:16.174319998Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/Effective-C++-Outline":{"title":"Effective C++ Outline","content":"## Chapter 1\n\n### 條款1 C++ 是一個語言聯邦\nC++ 融合了多種形式的 programming 手法，物件導向、procedural、generic、metaprogramming、functional...。\n\n### 條款2 盡量以 `const` , `enum`, `inline` 取代 `#define`\n- 以 const, enum, inline 取代 `#define`， 寧可以編譯器 (compiler) 取代前處理器 (pre-processor)。 \n- 對於單純的常數，以 `const` 或 `enum` 取代\n- 對於形似 function 的巨集(macro)，用 `inline` 取代。\n#### Const\n- [[Replace define with const]]\n- [[The definition and declaration of static const]] P14\n#### Enum\n- [[enum hack]]\n#### Inline\n\n\n### 條款3 盡可能使用 const\n盡可能的使用 `const`，它可以確保物件不被改變。特別是 custom class designer 更加需要注意 operator 的 constness。\n\n- `const` 在星號左邊: 被 point 的物件是常數\n- `const` 在星號右邊: pointer 自身是常數\n```c++\nchar greeting[] = \"Hello\";\nchar* p greeting;\n\nconst char* p = gretting; // non-const ptr, const data\nchar const* p = gretting; // same \n\nchar* const p = greeting; // const ptr, non-const data\nconst char* const p = greeting; // const ptr, const data\n```\n\n當 `const` 在 `*` 前，不管是先寫 const 修飾的類、或是先寫 const 都是一樣的，就是在修飾 `char` 物件具有常數性。\n[[Const in C++]]\n\n\n### 條款4 確定物件在使用前已經初始化\n不是所有的物件宣告時自帶初始化，它的規則過於複雜，只需要謹記: 宣告時就要初始化!\n(通常是 C-style 的，像是 array 不保證會發生初始化)，而 non-C part 的 (like `std::vector`) 有其他規則，就自帶初始化)\n\n對於內建型別 (int, char, double)，初始化就是手動給值。對於內建型別之外的，則要寫 constructor。\n\n為了避免沒有初始化帶來的不確定性，確保三件事\n1. 對於不是 member data 的 built-in type object，手動初始化。C++ 並不保證會初始化所有的 Built-in type Object (ex. array)。\n2. 對於 Custom Class，使用 [[Member Initialization List]] 初始化 member data。原因參見 [[Identify Initialization and Assignment]]\n3. 若初始化順序具有不確定性，想辦法加強 design，確保不會發生 circle (兩個變數相互依賴) 或競速問題。\n4. 當 static object 之間有依賴關係時，local static objects 勝過 non-local static objects。參見 [[Static Object]]\n\n## Chapter2 建構、解構、賦值運算\n\n### 條款5 了解 C++默默編寫並呼叫哪些函式\n當我們宣告了一個 Class，而不去實踐任何細節，Compiler 會偷偷地幫我們生成一些 function，他們分別是\n- default constructor, destructor\n- copy constructor, copy assignment\n且都是 public inline function - [[Item30 Understand the ins and outs of inlining]]\n\n更確切來說，是當這些 function 被需要 (被呼叫) 時產生。\n[[Default Generated Functions]]\n\n### 條款6 明確拒絕不要編譯器自動生成的函式\n在 C++11 引入了新的概念 [Deleted functions](https://www.ibm.com/docs/en/zos/2.4.0?topic=definitions-deleted-functions-c11)，書中教的方法依然有其壞處。直接在 declaration 後面接著 `=delete` 就可以阻止 copmiler 生成它。\n\n```cpp\nA(const A\u0026) = delete;\n```\n\n[[Deleted Function]]\n\n### 條款7 為多型用途的基礎類別宣告 virtual 解構式\n申明，這條規則**只針對**多型的 Base Class\n- 首先就先說明多型的用意: [[為多型用途的基礎類別宣告 virtual 解構式]]\n\n### 條款8 不讓異常逃離解構式\nC++ 不會禁止 Exception 發生於 Destructor，但這麼做具有相當的風險。一旦 Exception 發生而跳出了 Destructor，會中止銷毀物件的程序。\n特別是 STL Container 或 Array 這種資料結構中，若前面有某個 element 在銷毀過程中 thorw Exception 使得 Container 的 Destructor 被中斷，則後面的 elements 有可能不被銷毀，而導致記憶體洩漏! \n\n[[解構式與異常]]\n\n### 條款9 不在建構與解構中呼叫 virtual 函式\n\n不要在 Constructor 與 Destructor 中呼叫 virtural 函式。這和 Java 與 C# 不同!!!\n\n[[Virtual Function]]\n\n\n### 條款10 讓 operator= 回傳自身的 reference\n讓 `operator=`, `operator+=` 等 assignment 符號回傳自身的 Reference。\n這是一項協議，並非強制規定。但在 STL 提供的型別，或是即將 support 的 type ([[Item54 Familiarize yourself with the standard library including TR1]])，都會遵守這個協定，請從眾。\n\n### 條款11 在 operator= 處理自我賦值\n\n在撰寫 `operator=` 時，需要考量當 `rhs==this` 的狀況。\n即使不是如下面的方式 handle 自我賦值，記住，不要讓這個函式 raise exception (exception safety) 就對了。\n\n```cpp\nWidget\u0026 Widget::operator=(const Widget\u0026 rhs)\n{\n\tif (this == \u0026rhs) return *this; // assignment to self\n\tdelete pb;\n\tpb = new Bitmap(*rhs.pb);\n\treturn *this;\n}\n```\n\n### 條款12 複製物件時記得每一個部分\n\n當 Programmer 自己定義 [[Copying function]] 時，Compiler 不會警告你出錯! 你需要自己注意!!\n\n## Chapter3 資源管理\n\n### 條款13 使用資源管理器\n\n- 資源取得的時機就是初始化的時機 (Resource Acquisition Is Initialization, [RAII](https://zh.wikipedia.org/zh-tw/RAII))\n- [[Smart Pointer]] 是個好選擇\n\n### 條款14 仔細考慮資源管理類別的 Copy 行為\n\n- 有些資源並不是 Heap-based Resource，就不一定適合 auto_ptr。\n- 書中以 Mutex (互斥鎖) 舉例。\n\n\u003e [!Todo]\n\u003e 查一查 RAII，這整個章節我看不太懂。\n\n\n\u003e [!question]\n\u003e (此處是舊版，新版有對應的東西嗎?\n\n### 條款15 在資源管理類中提供對原始資源的存取\n\n儘管使用 [[Smart Pointer]] 管理資源很方便，我們仍有機會需要取得原始的 Pointer。Smart Pointer 同時有提供顯示介面 (explicit) 與隱式介面: \n- explicit : 以 `get` 取得 Raw Pointer。\n- implicit : `operator*`, `operator-\u003e`。\n\n### 條款16 成對的使用 `new` 和 `delete` 並採用相同型式\n1. 盡可能不要用 C-style Array\n2. STL所提供的 vector, string 等 templates 可以降低對 Array 的需求，減少錯誤的發生。\n\n\n### 條款17 以獨立的語句將物件放入 Smart Pointer\n\n```c++\nstd::shared_ptr\u003cWidget\u003e pw(new Widget);\nprocessWidget(pw, priority());\n```\n\n[[為什麼要用獨立句將物件放入 Smart Pointer]]\n\n## Chapter 4 設計與宣告\n### 條款18 讓介面容易被使用、防範誤用\n\n[[讓介面容易被使用]]\n\n### 條款19 設計 Class 猶如設計 Type\n設計 Class 請遵守準則想過一遍: [[設計新 Class 的準則]]\n\n### 條款20 以 Pass by const ref 取代 Pass by value \n\n合理的 Pass by value 幾乎只有下面三種選擇\n1. 內建型態\n2. STL Iterator \n3. Function Object\n\n除此之外，包含 STL Container 應盡可能用 Pass by const reference !\n- [[思維誤區-物件很小就可以 Pass By Value]]\n\n### 條款21 當必須回傳物件時，不要考慮回傳 Reference \n\n絕對不要\n 1. 將 Pointer 或 Reference 指向一個 local 物件回傳。\n 2. 讓 Reference 指向 heap-based object (`new`)\n 3. 當設計出「回傳 ptr/ref 指向 local static」，並且有很多個物件都採用這種形式時提高警覺，很有可能走入了 Bad design。對於怎麼樣是「合理」使用 Local static object : 參見 [[Static Object]]。\n\n\n### 條款22 將成員變數宣告成 Private\n\n- 只提供必要的 Getter 給客戶端，隱藏你的實作有絕佳的好處。\n\n思維誤區: Protected 不比 Public 具有更好的封裝性\n- 取消一個 Public Member Data 的成本: 所有使用他的客戶端\n- 取消一個 Protected Member Data 的成本 : 所有繼承他的 Derived Class\n這兩種 Access Level 的封裝性都不佳，仍該盡可能的使用 Private。\n\n### 條款23 寧以non-member, non-friend替換 member函數\n[[Item23 Prefer non-member non-friend functions to member functions]]\n\n\n\n### 條款24 如果所有的參數都需要型別轉換，請為此採用 non-member 函式\n[[Item24 Declare non-member functions when type conversions should apply to all parameters]]\n\n\n### 條款25 考慮寫出一個不拋異常的 Swap 函式\n\n\n## Ch5 Implementation\n\n### 條款26 盡可能延後變數定義式的出現時間\n[[Item26 Postpone variable definitions as long as possible]]\n\n### 條款2\n\n### 條款2\n\n\n\n\n\n\n簡體目錄: https://blog.csdn.net/weixin_45926547/article/details/121276226\n","lastmodified":"2023-04-21T13:53:16.174319998Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/Identify-Initialization-and-Assignment":{"title":"Identify Initialization and Assignment","content":"\n\u003e C++ 規定，member data initialization 發生在**進入 Constructor 之前**。在 Constructor 賦值屬於 assignment。 正確的 initialization 是使用 member initialization list (成員初值列)，取代賦值 (assignment)。\n\n此例中，第一種的做法效率好: \n- 第一種作法使用  member initialization list 是對 member data 做 Copy Construct。\n- 第二種作法 `m_name`會隱含的 call 一次 `std::string` 的 default constructor，再以 Copy assignment 被賦予值\n\n```cpp\nclass Book {\n    private:\n        std::string m_name;\n    public:\n        // good way\n        Book(const std::string\u0026 name): m_name { // copy construct\n        }\n        // bad way\n        Book(const std::string\u0026 name) {\n            m_name = name;  // copy assignment\n        }\n}\n```\n","lastmodified":"2023-04-21T13:53:16.174319998Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/Implicit-TemplateInstantiation":{"title":"Implicit TemplateInstantiation","content":"\u003e Occurs when a template is used to declare a pointer variable or a variable with the provided arguments","lastmodified":"2023-04-21T13:53:16.174319998Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/Item23-Prefer-non-member-non-friend-functions-to-member-functions":{"title":"Item23 Prefer non-member non-friend functions to member functions","content":"物件導向要求，資料(data) 以及操作資料的函式應該盡量綁在一起，不代表物件導向推崇 member function 是比較好的選擇。\n\n物件導向要求資料應該盡可能地被封裝，與直觀相反的，non-member function 的封裝性優於  member function。為什麼? \n\n## 封裝\n\n為什麼封裝被推崇? \n\u003e 封裝使得我們在改變事物時，只影響有限的客戶。\n\n- 被封裝的東西變得不可見 -\u003e 越多封裝就越少 client 可以 access -\u003e 對實作方而言，有更大的彈性改變它，因為能 access 它的客戶有限，改變的影響力小。\n\n### 如何衡量封裝程度\n這個問句可以換句話說，如何量測「有多少 function 可以看到某一塊資料?」。\n\n\u003e 計算能夠存取該資料的函式，越多函式存取則封裝度越低。\n\n對於 Private Member data 而言，能存取它的就是所有的 member function。","lastmodified":"2023-04-21T13:53:16.174319998Z","tags":[]},"/notes/Project/Effective-C++-Series/Item24-Declare-non-member-functions-when-type-conversions-should-apply-to-all-parameters":{"title":"Item24 Declare non-member functions when type conversions should apply to all parameters","content":"\n","lastmodified":"2023-04-21T13:53:16.174319998Z","tags":[]},"/notes/Project/Effective-C++-Series/Item26-Postpone-variable-definitions-as-long-as-possible":{"title":"Item26 Postpone variable definitions as long as possible","content":"","lastmodified":"2023-04-21T13:53:16.174319998Z","tags":[]},"/notes/Project/Effective-C++-Series/Item28-Avoid-returning-handles-to-object-internals":{"title":"Item28 Avoid returning handles to object internals","content":"","lastmodified":"2023-04-21T13:53:16.174319998Z","tags":["empty"]},"/notes/Project/Effective-C++-Series/Item30-Understand-the-ins-and-outs-of-inlining":{"title":"Item30 Understand the ins and outs of inlining","content":"","lastmodified":"2023-04-21T13:53:16.174319998Z","tags":["empty"]},"/notes/Project/Effective-C++-Series/Item47-Use-traits-classes-for-information-about-types":{"title":"Item47 Use traits classes for information about types","content":"","lastmodified":"2023-04-21T13:53:16.174319998Z","tags":["empty"]},"/notes/Project/Effective-C++-Series/Item54-Familiarize-yourself-with-the-standard-library-including-TR1":{"title":"Item54 Familiarize yourself with the standard library including TR1","content":"","lastmodified":"2023-04-21T13:53:16.174319998Z","tags":["empty"]},"/notes/Project/Effective-C++-Series/Item55-Familiarize-yourself-with-Boost":{"title":"Item55 Familiarize yourself with Boost","content":"","lastmodified":"2023-04-21T13:53:16.174319998Z","tags":["empty"]},"/notes/Project/Effective-C++-Series/Member-Initialization-List":{"title":"Member Initialization List","content":"\n\u003e 無論如何，使用 member initializer list 對 member data 初始化是最好的。儘管這麼做對內建型別的資料沒差，對非內建型別卻有巨大的意義。\n\n如果你就是想要 call member data 的 default constructor，依然可以透過 member initializer list 達成。只要給予空括號，不填內容即可。\n這樣的好處是明白地列出所有 member data，避免有 data 忘記給初始值，特別是對**非內建型別**的member data，沒有初始化的結果是災難的。\n\n對於內建型別的 Reference \u0026 const，他們**不能被賦值**，**必須透過 member initializer list 初始化**。\n- Related: [[Item5 Know What Functions C++ Silently Writes and Calls]]\n\n## 合理的使用 Assignment\n某些時候，類別擁有多個 Constructor，每個 Constructor 都需要有自己的 Member initializer list，這又會導致 dumplicated。\n這時候可以是當地將一些 Assignment 和 Initialize 效率差不多的 member data (通常是內建型別)，移到一個 \"統一初始化\" 的 private function，供所有的 Constructor 呼叫。\n這種作法 (pseudo-initialization, 偽初始化) 特別在數值是由讀檔得到的時候特別有用，但可以的話，盡可能使用 member initializer list。\n","lastmodified":"2023-04-21T13:53:16.174319998Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/Pure-Virtual-Destructor":{"title":"Pure Virtual Destructor","content":"現在的情境是，如果，你想要有一個抽象類 -- 抽象類的好處是自身無法被實例化。然而，抽象類的定義是，至少有一個 function 是 Pure Virtural Function。該選擇 \"誰\" 成為 Pure virtural function 呢? 洽巧手上沒有適合的人選! Destructor 會是個好選擇。因為\n1. Abstract Class 總是被當作 Base Class\n2. Base Class 作為多型用途時，應當帶有 virtural destructor\n3. Pure Virtural Function 可使該 Class 形成 Abstract\n三個點串起來--「讓 destructor 變成 Pure Virtural 吧」，這樣不會有不該被 virtural 的 function 遭殃! \n\n\u003e Abstruct Class 是不能被實例化的 Class，但可以持有 Abstruct Class 的 Pointer 去操控 Child instance。\n\n不過須記得一個技巧 -- 依然為這個 Base Class 的 Destructor 提供一個空的實作。\n這是因為 Destructor 的運作規則，在繼承架構中，most derived class (最 child 的) 的 destructor 會最先被呼叫，接著是每一個 Base Class 的 Destructor。即使 `AWOV` 作為抽象類沒有實例化的問題，其 destructor 依然會被呼叫，所以需要提供一個空的實作，Linker (編譯器的一部分?) 會報錯。\n```cpp\nclass AWOV {\npublic:\n\tvirtural ~AWOV() = 0;\n}\n\nAWOV::~AWOV() {}; // 依然為它提供一個實作\n```\n\n ","lastmodified":"2023-04-21T13:53:16.174319998Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/Replace-define-with-const":{"title":"Replace define with const","content":"\n## 以編譯器取代前處理器\n\n `#define` 的本質是 word replacement，如: `#define RATIO 1.653`，編譯器可能不認得 `RATIO` 並在錯誤訊息中從頭到尾以 1.653 取代 `RATIO`。\n```cpp\n const double Ratio=1.653; // Prefer\n```\n\n當以 `const` 取代 `#define` 時，有兩個需要注意的點\n1. 定義常數指標 (const pointer): 常數指標用於 「不允許此Pointer更改指向的對象」，因此需要對 pointer 宣告 const\n\n```cpp\nconst std::string = authorName(\"Scott\");\n ```\n\n2. Class 的專屬常數: 目的是限制常數的 Scope，因此要宣告在 class 內部。而為了使這個常數只有一個實體(所有 instance 共享同一個常數)，還需要宣告 `static`。\n\n```cpp\nclass Player {\nprivate:\n\tstatic const int num = 5;\n\tint scores[num];\n}\n ``` \n\n\n## 具有 Access Level\n第二點的用途，設置一個在某特定類別才生效的常數變是 `#define` 做不到的，`#deinfe` 不在乎 scope，不能帶來封裝性，更沒有 `private #deinfe` 這種東西。\n","lastmodified":"2023-04-21T13:53:16.174319998Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/Singleton":{"title":"Singleton","content":"","lastmodified":"2023-04-21T13:53:16.174319998Z","tags":["empty"]},"/notes/Project/Effective-C++-Series/Smart-Pointer":{"title":"Smart Pointer","content":"在[[為多型用途的基礎類別宣告 virtual 解構式]]文章中的 `TimeKeeper` 例子，我們提及了工廠函式 (factory function)，在該例子，我們把 delete `new` resource 的責任交給 Client。\n\n然而有很多情況--例如 main flow 中過早的 return，resource 可能沒有成功被銷毀。善用 Pointer-like 物件，並把銷毀資源的操作**確實**的寫在 Destructor 中可以避免這些問題。\n\nSmart Pointer 的原理是利用一個 object 去 own (or manage, 管理) 一個 heap-based 的資源，當 Smart Pointer Object 脫離 Scope，Compiler 試圖去 destructor 時，藉機呼叫手上 Object 的 destructor。\n\n## Smart Pointer 當中的顯式與隱式轉換\n1. Smart Pointer 的 `get` function 是一種顯式轉換 (explicit)，允許 client 取得原始物件的原始型別指標。\n2. Smart Pointer Override 了 `operation*` 和 `operator-\u003e`，因此 client 端可以直接對它做指標操作，有如對待 raw pointer，這隱含的是隱式轉換 (implicit)\n\n## 顯式/隱式轉換介面\n如上述， `get` function 是一種顯式轉換 (explicit)，它的優點是使用時意圖清楚，缺點是很醜。\n其實，亦可以提供個隱式轉換的介面，如此當這個物件被放到 base resource 的類別時，就不用特別透過 `get` 提取 base resource，缺點是會提升發生錯誤的風險。\n\n選擇何種，取決於使用情境，記住 [[讓介面容易被使用]]，不要讓你的介面容易被誤用，即可。","lastmodified":"2023-04-21T13:53:16.174319998Z","tags":[]},"/notes/Project/Effective-C++-Series/Static-Object":{"title":"Static Object","content":"\n\u003e 壽命從被建構出來，持續到程式結束為止。\n\n因此 Stack 和 Heap-based 物件都不是 static object。\n這種物件包含 Global Object，定義在 Namespace Scope 的物件，Class \u0026 Function \u0026 File 內宣告成 `static` 的物件。\n- Function 內的 static object 稱為 local static object (Scope 只在 function 內)\n- 其他被稱為 non-local static object\n它們的 deconstructor 會在 main 結束時被喚起。\n\n當我們有兩個編譯單元 ([[Translation Unit]])，通常表示兩份 Source Code。兩份 Source Code 中都有 non-local static object，且其中一份 static object 的初始化需要使用到另一份 source code 的 static object。\n\n問題在於，有可能要被使用的那個物件尚未被初始化! \n\u003e C++ 對於不同 [[Translation Unit]] 中 non-local Static object 初始化的順序並沒有明確的定義。\n\u003e The relative order of initialization of non-local static objects defined in different translation units is undefined.\n\n這是有原因的，因為決定這個順序非常困難，近乎無解，甚至不值得去找解。\n\n這種問題常見於[[Implicit TemplateInstantiation]] 模板隱式具現化。 (? 不確定翻譯)\n\n## Make Non-local Static Object become Local Static Object\n\n\u003e C++ 保證，函式內的 Local static object 會在該函式被呼叫期間，首次遇到該物件的定義式時初始化。\n\n我們可以利用此原則，解決 dependency of 2 non-local static object in 2 different translated units 的問題。\n\n\u003e 將每個 non-local static object 搬到專屬的 function 內，以 local static object 的方式存在。Design Pattern 中的 [[Singleton]] 就式常見的實作方式。\n\n其原理在於，所以比起直接呼叫 non-local static object，使用 function call 的做法更佳。更棒的是，若你從未呼叫「模擬該 non-local static object 的 function」，則 「那個 object 」根本**不會初始化**，有延遲初始化的功效在! 這是真正的 non-local static object 所不能及的。\n\n`static` 可以確保唯一性，Singleton 本身就常常與 Static 搭配使用。\n\n```cpp\nclass FileSystem { ... };\n\nFileSystem\u0026 tfs()\n{\n    static FileSystem fs;\n    return fs;\n}\n\nclass Directory { ... };\nDirectory::Directory( params )\n{\n    std::size_t disks = tfs().numDisks();\n}  \n\n// The first call function.\nDirectory\u0026 tempDir()\n{\n    static Directory td( params );\n    return td;\n}\n```\n此種手法稱為 reference-returning。\n\n在此例子中，`tmpDir` 創建物件 `td`，在 call `Directory` Constructor 時，會再 call `tfs` ，此時才創建 static object `fs`。透過 function call，確保了物件初始化的順序，先初始化 `fs`，再創建 `td`。\n\n### 優點\n特別在頻繁呼叫的時候，搭配 [[Item30 Understand the ins and outs of inlining]]。\n\n### 缺點\n在 multi-thread 中有不確定性。任何一種 non-const static 物件如果**依賴於其他事件的發生**，都很麻煩。常見的解決方法是，在 single-threaded startup portion 手動喚起所有 reference-returning function，手動解決 race conditions。\n","lastmodified":"2023-04-21T13:53:16.174319998Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/The-Copying-in-Pass-by-value":{"title":"The Copying in Pass by value","content":"\n## Simple Pass By Value\n考量下面的程式 `validateStudent(s)` 執行的成本有什麼?\n\n```cpp\nclass Person;\nclass Student: public Person;\nbool validateStudent(Student s); // pass by value = copy\nStudent s = Student();\nvalidateStudent(s); \n```\n\n成本是\n- Student Copy Constructor\n- Person Copy Constructor\n一個 Copy Ctor 就意味著一次全部 member data 的 Copy，所以 data 越多呼叫越多 Copy Ctor!! \n\n## 多型函式\n當 Signature 是 Parent，傳入的是 Child，更糟糕的是會發生 Slicing! 只有 `Person` 部分的資料會被 Copy，`Worker` 的資料都被切割了。\n\n```cpp\nclass Worker: public Person;\nbool showName(Person s);\n\nWorker w = Worker();\nshowName(w);\n```","lastmodified":"2023-04-21T13:53:16.174319998Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/The-definition-and-declaration-of-static-const":{"title":"The definition and declaration of static const","content":"","lastmodified":"2023-04-21T13:53:16.174319998Z","tags":["empty"]},"/notes/Project/Effective-C++-Series/Translation-Unit":{"title":"Translation Unit","content":"\n\u003e A translation unit is the source code giving rise to a single object file. It's basically a single source file, plus all of its `#include` files.\n\n編譯單元指: 產出單一目的檔 (single object file) 的那些 source code，通常是 source code + included header file.","lastmodified":"2023-04-21T13:53:16.174319998Z","tags":["cpp"]},"/notes/Project/Effective-C++-Series/Virtual-Function":{"title":"Virtual Function","content":"\n## 在 Ctor / Dtor 呼叫 virtual function\n![[Itm10_TranscationUML.png]]\n\n在這裡，Transcation 的 Constructor 呼叫的會是 `Transcation::logTranscation`。\n又，該 function 為 Pure virtural function，若它沒被定義，則當編譯器呼叫時會引發錯誤，而若有.... 就會 Link 到該 base class function。Related: [[Item34 Differentiate between inheritance of interface and inheritance of implementation]]\n一個不正式的講法: Base Calss 建構期間，所呼叫的 virtual function 不是 virtual function。  \n\n\u003e [!important] \n\u003e 在 Drived Class Object 執行 Based Class Constructor 期間，物件的型別實際上是 Base Class。\n\n這是根本的原因，由於在 Based Class Constructor 物件是 Base Class，呼叫 Base Class 的 function 也是自然的事。\n不只是 virtual function 會被決議(resolve to) 至 Base Class，如果使用 `dynamic_cast` (Runtime type infomation)，也會把物件視為 Base Class! [[Item27  Minimize casting]]\n\n相同的問題也存在於 Destructor，在 Destructor 中 Drived Class 的部分會先被消滅，一旦進入 Base Class Destructor ，C++ 就會看待它為一個 Base Class。\n\n## 以傳遞參數給 non-virtual function，取代使用 Virtual function\n將 virtual function 從 con/desturctor 中移除! 說來容易，卻不易察覺。Constructor 可能 call 別的 function，而 virtual 可能藏身在其中! 並且，很難確保 Child Class 也會服從這項規定。\n\n替代方案是，使用 non-virtual function，把 Log 以 string 的方式傳給 Base Class 的 non-virtual Log function。\n","lastmodified":"2023-04-21T13:53:16.174319998Z","tags":[]},"/notes/Project/Effective-C++-Series/enum-hack":{"title":"enum hack","content":"","lastmodified":"2023-04-21T13:53:16.174319998Z","tags":["empty"]},"/notes/Resource/Books/The-Second-Brain":{"title":"打造第二大腦","content":"\u003e 成為一個「能傳達資訊、且具有出色詮釋能力」的人! \n\n- Key Feature In this sentence:\n\t- Can construct infomation\n\t- Can express info effectively\n\n## CODE \n\n### C (Capture)\n\u003e 將資訊蒐集在沒有雜訊的地方，你可以心無旁騖地找到它。\n\n- 即使只是看一眼收藏，也要慎選收藏的地方。\n- 不好的地方: 個人信箱、FB 的收藏 (很容易被社群吸走) ...\n- 適合的地方: 屬於自己的聊天室 (Line keep)\n\n### O (Orgnize)\n\u003e 以 Project 分類 ，不要以類別分類。\n\n- 淺台詞: 以目的導向分類。ex. 「專注力協議」的書摘應該放在「成為心無旁鶩的人」而不是「心理學」。\n- 像是歸類在「心理學」、或是「工作生產力」這種圖書館式的分類，你不分看標題也知道它是哪一類，不需要做無意義的分類。\n- 放在「成為心無旁鶩的人」，點進去這個目標，此書摘就會快速地浮現上來，告訴你快使用它! \n- 知識必須用到才有用! \n\n### D (Distill, 萃取)\n\u003e 用 Bullet Point 告訴未來的你，這篇筆記在說什麼?\n\n- 4 個層次的萃取，每一次萃取約保留 10~20% 的訊息量。\n- 萃取的時機很重要，無效的萃取反而遺失重要訊息。\n- How to partice? Distill the note when read it once time.\n\n### E (Express, 表達)\n\u003e Any way. Deliver it, and share! \n\n\n## 釐清目標: 你想解決什麼問題?\n\u003e Which problems do you want to resovle by The Second Brain? \n\n**費曼: 12道難題**\n它應該具有轉移性，核心精神不變，但領域可能改變的特質。記得這些你的目標，當資訊流過你身邊時，驗證他們是否能幫助你解決這些難題? If true, Capture it! \n\nMy current thinking: \n1. How to improve poor english?\n2. How to spend time \u0026 learning effectively?\n3. How to take effective note?\n4. How to debug (gdb) effective?\n\n## Capture: What Info Can put into Your Second Brain?\n\n- 摘要! 通常不應超過原資訊量的 1/10\n- 具有啟發性的，改變你的想法的 (不懂 太抽象)\n- 在未來可以被使用的 (ex. How to own a project? How to leader a team?)\n- 跟你自身相關的: 珍貴的，你想永久記憶的回憶。\n- 相反、不同觀點的: 避免佐證偏差 (confirmation bias)，可以使你跳脫當前認知的。\n\n\u003e 記住，重新消化過的資訊更好吸收! \n\n## Organize: Where Do the Info Put?\n\n不使用圖書館式的分類法，作者提出 PARA 方法，可以看出重要程度依序遞減。人的注意力有限，請第一眼，就看到最可能幫助你的資料。\n\n\u003e 讓最重要的任務、最短期的目標的相關資料上，沒有過多的雜訊\n\nP (Project): 短期任務\n- Working project\n- Personal project (ex. blog), side project, 減重... \n\n\nA (Area): 長期任務，長期想掌握的目標\n- 健康，不同於 project 中的「減重」是明確目標、是達成健康的手段，健康是長期目標。\n\nR (Resource): 未來有用處的\n- 有興趣的東西、嗜好: 精油、咖啡\n- 研究的可提: effective\n- 有用的參考: travel plan\n\nA (Archive): 備而不用\n- 不再有興趣的\n\n\n\n## Distill 萃取\n\n- 不要花相同的時間，處理相同的原始資料\n- 摘要! 用簡短的 bullet point 列出重點。\n- 誤區: 當不能了解其用處時，不應強行消化，否則重點非重點。\n\n\u003e My opinion: 每調閱它、閱讀一次，就萃取一次。\n\n### 參考方法: 4 個層次萃取\n\n每個步驟間應保留約 10~20% 的資料量，否則 brief isn't brief.\n1. 擷取段落\n2. 粗體字\n3. 螢光筆 highlight\n4.  bullet point \n\n### 以會議筆記舉例\n\n1. 列出所有討論出來，需要做的 (need to do)\n2. 劃出重點項目、關鍵字\n3. 簡短列出: 如何執行 (execute)\n\n## Express 表達\n\n### 哲學思辨: 如何騰出專注力，卻不消耗專注力?\n\u003e 使用中間產物\n\nProject 自起點到終點(成品)，有許多中間產物，例如: 草稿、大綱、顧客回覆。收集這些資料，放進第二大腦，達到重複使用! \n\n### 中間產物\n1. Note\n2. 不使用的 Proposal \n\t1. 以及檢討，為何不使用。可能是有重大缺陷，需要避免以後踩到。\n3. 半成品??? \n4. 團隊的文件，這相當於他人的經驗\n\n\n### 切分「一件事」\n一件事有很多碎片，如果你是從零開始，可以把完成這件事需要那些碎片寫下來，並把你花費專注力 build 好的碎片存起來，讓這些碎片可以 Re-use。\n\n同時，你在從零建構碎片時，也可以吸取別人的經驗，Reuse 別人的碎片! \n\n\n\n\n## Resource\n- Author's website: https://www.buildingasecondbrain.com/resources\n- Obsidian As a Second Brain: https://www.youtube.com/watch?v=nz99I7apNLI\u0026list=WL\u0026index=2\n- Should Logseq be Your Second Brain? https://www.youtube.com/watch?v=VJ2reQcpbYA\u0026list=WL\u0026index=3\n- Pick a Notes App: Your Notetaking Style (Part 1) https://www.youtube.com/watch?v=f3dDVtJ2sec\u0026list=WL\u0026index=4\n","lastmodified":"2023-04-21T13:53:16.174319998Z","tags":[]},"/notes/Resource/Whisky/%E6%A0%BC%E8%98%AD%E5%82%91-%E5%96%AE%E4%B8%80%E9%BA%A5%E8%8A%BD%E5%A8%81%E5%A3%AB%E5%BF%8C":{"title":"格蘭傑-單一麥芽威士忌","content":"Glenmorangie X Single Malt Scotch Whisky\n\n- 買於好事多，跟 \"知多\" 喝起來差不多，CP 值極佳!! \n- 理想價格: 600-650\n\n","lastmodified":"2023-04-21T13:53:16.174319998Z","tags":[]},"/notes/Resource/Whisky/%E9%A1%98%E6%9C%9B%E6%B8%85%E5%96%AE":{"title":"威士忌的願望清單","content":"\n## 待過濾\n- [五支波本威士忌推薦文](https://medium.com/need-a-drink/%E5%8F%AA%E9%9C%80%E4%BA%94%E7%93%B6-%E6%B3%A2%E6%9C%AC-%E5%A8%81%E5%A3%AB%E5%BF%8C-%E7%BE%8E%E5%8F%B0%E5%8F%8B%E5%A5%BD-%E6%8E%A8%E8%96%A6%E6%B8%85%E5%96%AE-my-only-5-bourbon-whisky-i-need-112ff911ffbe)\n\n","lastmodified":"2023-04-21T13:53:16.174319998Z","tags":[]}}